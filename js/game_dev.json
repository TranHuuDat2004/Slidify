{
    "title": "Phát triển trò chơi với Unity",
    "description": "Xây dựng 4 game 2D có thể chơi được bằng C# và nắm vững các nguyên tắc cơ bản về phát triển game.",
    "thumbnail": "images/unity.png",
    "sections": [
        {
            "title": "Tuần 1: Introduction. C# & Unity3D Basics",
            "slides": [
                {
                    "id": 1,
                    "title": "Trang 1: Bìa - Giới thiệu môn học",
                    "image": "images/game-dev/week1/slide_1.png",
                    "notes": "Bài giảng 1 thuộc môn CE318/CE818: High-level Games Development. Giảng viên: Diego Perez. Nội dung chính: Giới thiệu tổng quan, ngôn ngữ C# và các khái niệm cơ bản về Unity3D.",
                    "terms": {}
                },
                {
                    "id": 2,
                    "title": "Trang 2: Đề cương bài giảng",
                    "image": "images/game-dev/week1/slide_2.png",
                    "notes": "Nội dung bài giảng tuần này bao gồm 4 phần chính:\n1. Tổng quan khóa học (Bắt đầu từ slide 4).\n2. Giới thiệu về C#.\n3. Scripting trong C# cho Unity3D.\n4. Câu hỏi và Demo.",
                    "terms": {}
                },
                {
                    "id": 3,
                    "title": "Trang 3: Chuyển tiếp - Đề cương",
                    "image": "images/game-dev/week1/slide_3.png",
                    "notes": "Chuẩn bị vào phần đầu tiên: Tổng quan về khóa học.",
                    "terms": {}
                },
                {
                    "id": 4,
                    "title": "Trang 4: Tổng quan khóa học",
                    "image": "images/game-dev/week1/slide_4.png",
                    "notes": "Slide này cung cấp cái nhìn tổng quan về nội dung và mục tiêu của khóa học.\n\nKhóa học sẽ tập trung vào các kiến thức nền tảng của lập trình game console, đặc biệt là game 3D được phát triển bằng <b>Unity3D phiên bản 5.1.4</b>.\n\n<b>Các chủ đề chính bao gồm:</b>\n- Xây dựng game 3D và sử dụng trình soạn thảo của Unity3D.\n- Các khái niệm toán học 2D-3D trong game.\n- Quản lý input của người chơi, vật lý game, camera và animations.\n- Điều hướng (Navigation), Giao diện người dùng (GUI), ánh sáng và âm thanh.\n- Hệ thống hạt (Particle Systems) và địa hình (Terrains).\n- Thiết kế game, Gameplay và Trí tuệ nhân tạo (Game AI).\n\nĐây là một khóa học mang tính thực tiễn cao, sử dụng nhiều ví dụ mã nguồn và khuyến khích thiết kế game sáng tạo trong các buổi thực hành.",
                    "terms": {
                        "Unity3D": "Một game engine đa nền tảng mạnh mẽ được sử dụng để tạo ra các trò chơi 2D, 3D và các trải nghiệm tương tác khác.",
                        "Game Engine": "Là một framework phần mềm cung cấp các công cụ và chức năng cốt lõi (như đồ họa, vật lý, âm thanh) để các nhà phát triển xây dựng trò chơi một cách hiệu quả.",
                        "Game AI (Artificial Intelligence)": "Trí tuệ nhân tạo trong game, dùng để điều khiển hành vi của các nhân vật không phải người chơi (NPC), tạo ra các thử thách và tương tác thông minh.",
                        "Particle Systems (Hệ thống hạt)": "Một kỹ thuật trong đồ họa máy tính dùng để mô phỏng các hiện tượng 'mờ ảo' như lửa, khói, mưa, vụ nổ bằng cách sử dụng một số lượng lớn các hạt nhỏ."
                    }
                },
                {
                    "id": 5,
                    "title": "Trang 5: Kết quả học tập & Đánh giá",
                    "image": "images/game-dev/week1/slide_5.png",
                    "notes": "Sau khi hoàn thành môn học này, bạn sẽ có khả năng:\n- Hiểu được kiến trúc của game 2D/3D.\n- Thiết kế và lập trình các game 2D/3D đơn giản bằng Unity3D.\n- Lập trình các hành vi AI cơ bản cho nhân vật (NPC).\n- Thiết kế và lập trình các hiệu ứng đồ họa trong môi trường 3D.\n- Thiết kế và lập trình các đối tượng trong game (game objects).\n\n<b>Phương pháp đánh giá:</b>\n- <b>Kiểm tra tiến độ (30%):</b>\n  - Bài 1 (15%) - Nội dung từ Tuần 1 - 4.\n  - Bài 2 (15%) - Nội dung từ Tuần 5 - 9.\n- <b>Bài tập thực hành mỗi hai tuần (10%).</b>\n- <b>Một bài tập lớn duy nhất (60%):</b>\n  - Phần I (20%) - Hạn nộp ngày 22 tháng 11, 2016.\n  - Phần II (40%) - Hạn nộp ngày 9 tháng 1, 2017.",
                    "terms": {
                        "Learning Outcomes (Kết quả học tập)": "Các kiến thức và kỹ năng cụ thể mà sinh viên dự kiến sẽ đạt được sau khi hoàn thành một môn học.",
                        "Assessment (Đánh giá)": "Quá trình đo lường và cho điểm mức độ hiểu biết và năng lực của sinh viên thông qua các bài kiểm tra, bài tập.",
                        "Game Architecture (Kiến trúc game)": "Cấu trúc tổng thể của một trò chơi, bao gồm cách các thành phần (như đồ họa, logic game, input) tương tác với nhau.",
                        "Game Objects": "Trong Unity, đây là bất kỳ vật thể nào tồn tại trong một màn chơi, từ nhân vật, vật phẩm cho đến các yếu tố vô hình như camera hay nguồn sáng."
                    }
                },
                {
                    "id": 6,
                    "title": "Trang 6: Lịch trình khóa học",
                    "image": "images/game-dev/week1/slide_6.png",
                    "notes": "<b>Lý thuyết (Lectures):</b>\n- Mỗi thứ Ba, 1h chiều tại phòng 3.320, kéo dài 2 tiếng.\n- Bao gồm thảo luận, demo phần mềm và các câu hỏi ôn tập (sử dụng Kahoot!).\n\n<b>Thực hành (Labs):</b>\n- Mỗi thứ Sáu, 1h chiều tại phòng CES Lab 1, kéo dài 2 tiếng.\n- Sẽ có hướng dẫn từng bước, tutorials và các bài tập mở.\n- Trợ giảng là Emily Marriot (email: ecmarr@essex.ac.uk).\n\n<b>Lịch học chi tiết:</b>\n- Lý thuyết: Thứ Ba, Tuần 2-5 & 7-10, 1h-3h chiều, Phòng 3.320.\n- Lý thuyết: Thứ Ba, Tuần 6 & 11, 2h-3h chiều, Phòng 3.320.\n- Thực hành: Thứ Sáu, Tuần 2-11, 1h-3h chiều, Phòng CES Lab 1.\n- Kiểm tra: Thứ Ba, Tuần 6 (ngày 8/11) và Tuần 11 (ngày 13/12), 1h-2h chiều.\n\nCuối cùng, phần trình bày/demo cho bài tập lớn (phần II) có thể sẽ diễn ra vào <b>Tuần 16</b>.",
                    "terms": {
                        "Lecture": "Buổi học lý thuyết, nơi giảng viên trình bày và giảng giải các khái niệm chính của môn học.",
                        "Lab (Laboratory session)": "Buổi học thực hành, nơi sinh viên áp dụng kiến thức lý thuyết vào việc giải quyết các bài tập cụ thể, thường là trên máy tính.",
                        "Tutorial": "Một bài hướng dẫn chi tiết, thường là từng bước một, để giúp người học thực hiện một nhiệm vụ cụ thể.",
                        "Kahoot!": "Một nền tảng học tập dựa trên trò chơi, được sử dụng để tạo và tham gia các câu đố trắc nghiệm một cách tương tác."
                    }
                },
                {
                    "id": 7,
                    "title": "Trang 7: Yêu cầu bài tập",
                    "image": "images/game-dev/week1/slide_7.png",
                    "notes": "Tất cả bài tập trong môn CE318 đều là <b>bài tập cá nhân</b>. Mọi buổi thực hành, thuyết trình và demo đều là <b>bắt buộc</b> (sẽ bị 0% điểm nếu vắng mặt không có lý do chính đáng).\n\n<b>Bài tập mỗi hai tuần (10%):</b>\n- Sẽ có 4 bài tập dạng này. Các bài tập sẽ được đánh giá tại phòng lab.\n\n<b>Bài tập lớn (60%):</b>\n- Yêu cầu phát triển một game hoàn chỉnh, gồm 2 phần phải nộp:\n  - <b>Phần I (20%, hạn nộp Thứ Tư 22/11):</b> Bao gồm Game Prototype (10%) + Kế hoạch phát triển (5%) + 5 phút thuyết trình (5%, có peer review).\n  - <b>Phần II (40%, hạn nộp Thứ Hai 09/01):</b>\n    - Đối với môn <b>CE318</b>: Game hoàn chỉnh (20%) + Báo cáo cuối kỳ (10%) + 10 phút thuyết trình (10%, có peer review).\n    - Đối với môn <b>CE818</b>: Game hoàn chỉnh (15%) + Báo cáo cuối kỳ (10%) + Case Study (10%) + 10 phút thuyết trình (5%, có peer review).",
                    "terms": {
                        "Mandatory": "Bắt buộc, có nghĩa là phải tham gia hoặc hoàn thành, nếu không sẽ bị phạt hoặc không đủ điều kiện qua môn.",
                        "Deliverable": "Một sản phẩm hoặc kết quả cụ thể, hữu hình phải được tạo ra và nộp lại để hoàn thành một dự án hoặc một phần của dự án.",
                        "Game Prototype": "Một phiên bản chơi thử rất sớm của một trò chơi, được tạo ra để kiểm tra các cơ chế gameplay cốt lõi và xác định xem trò chơi có vui hay không.",
                        "Peer reviewed": "Được đánh giá, nhận xét bởi những người cùng vai trò (trong trường hợp này là các sinh viên khác trong lớp).",
                        "Case Study": "Một bài phân tích chuyên sâu về một trường hợp, vấn đề, hoặc dự án cụ thể để rút ra các bài học kinh nghiệm."
                    }
                },
                {
                    "id": 8,
                    "title": "Trang 8: Peer Review & Giải thưởng Game hay nhất",
                    "image": "images/game-dev/week1/slide_8.png",
                    "notes": "Trong môn học này, các bạn sẽ tham gia đánh giá lẫn nhau dựa trên các tiêu chí sau:\n- Phần thuyết trình cuối kỳ.\n- Mức độ \"vui\" (fun) của game.\n- Tính thẩm mỹ (aesthetics) của game.\n- Game hay nhất về tổng thể.\n\n<b>Quy tắc đánh giá:</b>\n- Danh tính của người đánh giá sẽ được <b>giữ ẩn danh</b> với người được đánh giá, nhưng sẽ không ẩn danh với giảng viên/trợ giảng.\n- Giảng viên có quyền không tính các điểm số cực đoan (quá cao hoặc quá thấp) mang tính không khách quan.\n\n<b>Giải thưởng:</b>\n- Vào kỳ mùa Xuân, sẽ có 3 giải thưởng được trao cho 3 hạng mục cuối (Vui, Thẩm mỹ, Tổng thể) dựa trên đánh giá của các bạn cùng lớp.\n- Phần thưởng có thể là 3 voucher (trị giá khoảng 20 Bảng Anh) để mua hàng trên Amazon hoặc Waterstones.",
                    "terms": {
                        "Peer Review": "Là quá trình các cá nhân cùng vai trò (ví dụ: sinh viên) đánh giá, nhận xét công việc của nhau. Điều này giúp cung cấp nhiều góc nhìn và thúc đẩy việc học hỏi lẫn nhau.",
                        "Aesthetics (Tính thẩm mỹ)": "Trong game, đây là yếu tố liên quan đến vẻ đẹp và phong cách nghệ thuật của trò chơi, bao gồm đồ họa, âm thanh, và cảm giác tổng thể mà nó mang lại.",
                        "Anonymous (Ẩn danh)": "Việc thực hiện một hành động mà không tiết lộ danh tính của người thực hiện.",
                        "Voucher": "Một loại phiếu hoặc mã có giá trị tiền tệ nhất định, có thể dùng để đổi lấy hàng hóa hoặc dịch vụ."
                    }
                },
                {
                    "id": 9,
                    "title": "Trang 9: Tài liệu tham khảo",
                    "image": "images/game-dev/week1/slide_9.png",
                    "notes": "Đây là danh sách các tài liệu và tài nguyên web được đề xuất cho môn học:\n\n<b>Ngôn ngữ C#:</b>\n1. <b>C# 4.0 Pocket Reference</b> của <i>Albahari and Albahari</i>.\n2. <b>Essential C# 4.0</b> của <i>Mark Michaelis</i>.\n3. MSDN C# Ref: msdn.microsoft.com/en-us/library/618ayhy6.aspx\n\n<b>Unity3D:</b>\n1. http://unity3d.com/: Nơi chứa tài liệu Manual, Scripting API, Samples, Tutorials... (hầu hết tài liệu khóa học được lấy từ đây).\n2. <b>Beginning 3D Game Development with Unity 4, 2nd Edition</b> của <i>Sue Blackman</i> (rất khuyến khích).\n3. <b>Unity 4.x Cookbook</b> của <i>Matt Smith</i> (sách tham khảo bổ sung).\n4. <b>Unity 4.x Game AI Programming</b> của <i>Aung Sithu Kyaw, Thet Naing Swe</i> (dành cho Game AI trong Unity).\n5. <b>Unity 4x Game Development by Example, Beginners Guide</b> của <i>Ryan Henson Creighton</i> (dành cho người mới bắt đầu).\n\n<b>Game AI:</b>\n1. <b>Artificial Intelligence for Games</b> của <i>Millington and Funge</i>.\n2. <b>Game Artificial Intelligence</b> của <i>Ahlquist and Novak</i>.",
                    "terms": {
                        "MSDN (Microsoft Developer Network)": "Là cổng thông tin chính thức của Microsoft dành cho các nhà phát triển, cung cấp tài liệu kỹ thuật, mã mẫu, và công cụ cho các sản phẩm và công nghệ của Microsoft.",
                        "API (Application Programming Interface)": "Giao diện lập trình ứng dụng. Đây là một tập hợp các quy tắc và công cụ cho phép các ứng dụng phần mềm khác nhau giao tiếp với nhau. 'Scripting API' của Unity là tập hợp các lệnh bạn có thể dùng để điều khiển engine.",
                        "Cookbook (sách lập trình)": "Một loại sách hướng dẫn lập trình được trình bày dưới dạng các 'công thức' (recipes). Mỗi 'công thức' là một giải pháp cho một vấn đề lập trình cụ thể."
                    }
                },
                {
                    "id": 10,
                    "title": "Trang 10: Chuyển tiếp - Giới thiệu về C#",
                    "image": "images/game-dev/week1/slide_10.png",
                    "notes": "Kết thúc phần Tổng quan khóa học.\n\nPhần tiếp theo sẽ giới thiệu chi tiết về ngôn ngữ lập trình C#.",
                    "terms": {}
                },
                {
                    "id": 11,
                    "title": "Trang 11: Giới thiệu về C#",
                    "image": "images/game-dev/week1/slide_11.png",
                    "notes": "Tất cả các game làm bằng Unity3D thường chứa các đoạn mã (scripts) được viết bằng C#, Javascript hoặc Boo.\n\nTrong môn học này, chúng ta sẽ <b>chỉ sử dụng C#</b>, một ngôn ngữ lập trình hướng đối tượng được phát triển bởi Microsoft trong khuôn khổ .NET framework của họ.\n\nUnity3D đi kèm với một IDE mặc định gọi là <b>MonoDevelop</b>, cung cấp các tính năng như tô màu cú pháp (syntax highlighting) và gỡ lỗi (debug).",
                    "terms": {
                        "C# (C Sharp)": "Một ngôn ngữ lập trình hiện đại, hướng đối tượng, được phát triển bởi Microsoft. Nó là ngôn ngữ chính được sử dụng để lập trình trong Unity.",
                        "IDE (Integrated Development Environment)": "Môi trường phát triển tích hợp. Đây là một ứng dụng phần mềm cung cấp các công cụ cần thiết cho việc phát triển phần mềm, bao gồm trình soạn thảo mã, trình biên dịch, và công cụ gỡ lỗi (debugger).",
                        "MonoDevelop": "Một IDE mã nguồn mở, đa nền tảng, từng là IDE mặc định đi kèm với Unity. Các phiên bản Unity gần đây đã chuyển sang sử dụng Visual Studio.",
                        "Debug": "Quá trình tìm kiếm và sửa lỗi (bugs) trong một chương trình máy tính."
                    }
                },
                {
                    "id": 12,
                    "title": "Trang 12: C# cơ bản - Dành cho người biết Java",
                    "image": "images/game-dev/week1/slide_12.png",
                    "notes": "Slide này trình bày một chương trình C# cơ bản và chỉ ra một số điểm khác biệt so với Java:\n\n- Từ khóa <b>using</b> được dùng để 'import' các gói, mà trong C# được gọi là <b>namespace</b>.\n- Một namespace có thể chứa nhiều class, và tên file không nhất thiết phải trùng với tên namespace hay tên class bên trong nó.\n- Quy ước đặt tên: Tên phương thức (ví dụ: <b>Main</b>) bắt đầu bằng chữ hoa, trong khi các kiểu dữ liệu có sẵn (ví dụ: <b>class</b>, <b>string</b>) thì không.",
                    "terms": {
                        "using directive": "Trong C#, đây là chỉ thị được sử dụng ở đầu file mã nguồn để khai báo các namespace sẽ được sử dụng, cho phép bạn sử dụng các class trong namespace đó mà không cần ghi đầy đủ tên.",
                        "namespace": "Một 'container' dùng để tổ chức mã nguồn và tránh xung đột tên. Nó tương tự như khái niệm 'package' trong Java.",
                        "Main method": "Điểm khởi đầu của mọi ứng dụng C#. Khi chương trình được chạy, phương thức Main() là phương thức đầu tiên được thực thi."
                    }
                },
                {
                    "id": 13,
                    "title": "Trang 13: C# cơ bản - Biến, tham số & namespace",
                    "image": "images/game-dev/week1/slide_13.png",
                    "notes": "Tổng quan về các khái niệm biến, tham số và namespace trong C#:\n\n- <b>Biến và hằng số:</b> Khai báo với các kiểu dữ liệu như int, double, string, bool. Từ khóa <b>const</b> dùng để khai báo hằng số.\n- <b>Biến Static:</b> Biến được chia sẻ chung cho tất cả các đối tượng (instance) của một class.\n- <b>Chuyển đổi kiểu:</b> Có thể là ngầm định (implicit, ví dụ int sang double) hoặc tường minh (explicit/casting, ví dụ double sang short).\n- <b>Params và tham số tùy chọn:</b> Từ khóa <b>params</b> cho phép một phương thức nhận một số lượng đối số không xác định. Tham số tùy chọn là tham số có giá trị mặc định.\n- <b>Namespaces:</b> Có thể được lồng vào nhau để tạo ra một cấu trúc phân cấp, giúp tổ chức code tốt hơn.",
                    "terms": {
                        "static": "Một từ khóa chỉ định rằng một thành viên (biến hoặc phương thức) thuộc về chính kiểu dữ liệu đó, chứ không thuộc về một đối tượng cụ thể của kiểu đó.",
                        "Casting (Ép kiểu)": "Là việc chuyển đổi tường minh một giá trị từ kiểu dữ liệu này sang kiểu dữ liệu khác, có thể gây mất mát dữ liệu (ví dụ: ép kiểu một số double thành int sẽ mất phần thập phân).",
                        "params": "Từ khóa cho phép một phương thức nhận một mảng các đối số. Nó phải là tham số cuối cùng trong danh sách tham số của phương thức."
                    }
                },
                {
                    "id": 14,
                    "title": "Trang 14: C# cơ bản - Kiểu tham trị và tham chiếu",
                    "image": "images/game-dev/week1/slide_14.png",
                    "notes": "Trong C#, các kiểu dữ liệu được chia thành hai loại chính:\n\n- <b>Kiểu tham trị (Value types):</b> Chứa trực tiếp giá trị của nó. Ví dụ: int, float, bool, char, và các <b>Struct</b> (như Vector3). Khi gán hoặc truyền một biến kiểu tham trị, một bản sao của giá trị sẽ được tạo ra.\n- <b>Kiểu tham chiếu (Reference types):</b> Chứa một địa chỉ bộ nhớ trỏ đến nơi chứa giá trị. Ví dụ: các <b>Class</b> (như Transform, GameObject). Khi gán hoặc truyền một biến kiểu tham chiếu, chỉ có địa chỉ bộ nhớ được sao chép, các biến vẫn trỏ đến cùng một đối tượng.\n\n<b>Ví dụ:</b> Thay đổi một bản sao của <b>transform.position</b> (là Vector3, một struct) sẽ không ảnh hưởng đến bản gốc. Nhưng thay đổi thuộc tính của một bản sao của <b>transform</b> (là một class) sẽ ảnh hưởng đến bản gốc.\n\n- Từ khóa <b>ref</b> và <b>out</b> dùng để truyền các đối số vào phương thức theo kiểu tham chiếu.",
                    "terms": {
                        "Value Type (Kiểu tham trị)": "Một kiểu dữ liệu lưu trữ giá trị của nó trực tiếp trong bộ nhớ. Các kiểu cơ bản như int, double, bool và các struct là kiểu tham trị.",
                        "Reference Type (Kiểu tham chiếu)": "Một kiểu dữ liệu lưu trữ một tham chiếu (địa chỉ bộ nhớ) đến đối tượng thực tế. Các class, interface, delegate, và array là kiểu tham chiếu.",
                        "ref": "Từ khóa dùng khi truyền đối số vào phương thức, cho phép phương thức đó thay đổi giá trị của biến gốc. Biến truyền vào phải được khởi tạo trước.",
                        "out": "Tương tự như 'ref', nhưng biến truyền vào không cần được khởi tạo trước. Phương thức nhận tham số 'out' bắt buộc phải gán một giá trị cho nó trước khi kết thúc."
                    }
                },
                {
                    "id": 15,
                    "title": "Trang 15: C# cơ bản - Class, Interface và Kế thừa",
                    "image": "images/game-dev/week1/slide_15.png",
                    "notes": "Các khái niệm về Class, Interface và Kế thừa trong C# tương tự như Java:\n\n- Một class chỉ có thể <b>kế thừa (subclass)</b> từ một class khác, nhưng có thể <b>thực thi (implement)</b> nhiều interface.\n- <b>Interface</b> là một 'hợp đồng' định nghĩa các phương thức mà một class phải có nếu nó thực thi interface đó.\n- Sử dụng từ khóa <b>override</b> để cung cấp một định nghĩa mới cho một phương thức đã được định nghĩa ở lớp cha (base class).\n- Sử dụng từ khóa <b>base</b> để truy cập đến các thành viên (ví dụ: phương thức) của lớp cha từ bên trong lớp con.",
                    "terms": {
                        "Inheritance (Kế thừa)": "Một cơ chế cho phép một class (lớp con) thừa hưởng các thuộc tính và phương thức từ một class khác (lớp cha).",
                        "Interface": "Một tập hợp các định nghĩa về phương thức và thuộc tính. Một class khi 'thực thi' một interface phải cung cấp định nghĩa chi tiết cho tất cả các thành viên của interface đó.",
                        "override": "Từ khóa dùng trong lớp con để cung cấp một triển khai mới cho một phương thức (virtual hoặc abstract) của lớp cha.",
                        "base": "Từ khóa dùng trong lớp con để truy cập đến các thành viên của lớp cha, ví dụ như gọi constructor hoặc một phương thức đã bị override của lớp cha."
                    }
                },
                {
                    "id": 16,
                    "title": "Trang 16: C# cơ bản - Generics",
                    "image": "images/game-dev/week1/slide_16.png",
                    "notes": "Generics cho phép lập trình viên trì hoãn việc chỉ định một hoặc nhiều kiểu dữ liệu cho đến khi class hoặc phương thức được khai báo và khởi tạo.\n\nNói cách khác, nó cho phép bạn viết một class hoặc phương thức có thể hoạt động với bất kỳ kiểu dữ liệu nào (ví dụ: `int`, `string`, hoặc một class tự định nghĩa như `AClass`) mà không cần viết lại code cho từng kiểu.\n\nVí dụ trên slide minh họa cách tạo một class `GenericList<T>` có thể chứa một danh sách các số nguyên (`int`), chuỗi (`string`), hoặc các đối tượng `AClass`.",
                    "terms": {
                        "Generics": "Một tính năng cho phép viết code linh hoạt, tái sử dụng và an toàn về kiểu (type-safe) bằng cách cho phép các class, interface và phương thức hoạt động với một 'kiểu dữ liệu giữ chỗ' (placeholder type). Kiểu dữ liệu thực tế sẽ được chỉ định khi code được sử dụng.",
                        "Instantiated (Khởi tạo đối tượng)": "Quá trình tạo ra một 'thể hiện' (instance) cụ thể của một class trong bộ nhớ. Thường được thực hiện bằng từ khóa `new`."
                    }
                },
                {
                    "id": 17,
                    "title": "Trang 17: C# cơ bản - Properties",
                    "image": "images/game-dev/week1/slide_17.png",
                    "notes": "Properties (Thuộc tính) là các 'lối tắt' cú pháp cho các phương thức getter và setter thường đi kèm với các biến của class. Chúng giúp kiểm soát việc truy cập vào một biến và có thể được dùng để tạo ra một biến chỉ đọc (read-only).\n\n- <b>Phiên bản ngắn gọn (auto-implemented property):</b> `public double Seconds { get; set; }` tự động tạo ra một biến private ẩn.\n- <b>Phiên bản đầy đủ:</b> Cho phép bạn thêm logic tùy chỉnh vào bên trong `get` (để trả về giá trị) và `set` (để gán giá trị mới, thông qua từ khóa `value`).\n- Có thể sử dụng các access modifier (ví dụ: `private`) trên `get` hoặc `set` để hạn chế quyền truy cập.",
                    "terms": {
                        "Property (Thuộc tính)": "Một thành viên của class đóng vai trò trung gian để truy cập vào một trường dữ liệu private. Nó bao gồm các khối lệnh `get` (để đọc giá trị) và `set` (để ghi giá trị).",
                        "Getter": "Phương thức hoặc khối lệnh `get` trong một property, dùng để truy xuất giá trị của một biến.",
                        "Setter": "Phương thức hoặc khối lệnh `set` trong một property, dùng để gán một giá trị mới cho một biến.",
                        "Access Modifiers (e.g., private, public)": "Các từ khóa dùng để quy định mức độ truy cập (ai có thể thấy và sử dụng) của các thành viên trong một class."
                    }
                },
                {
                    "id": 18,
                    "title": "Trang 18: C# cơ bản - Structs",
                    "image": "images/game-dev/week1/slide_18.png",
                    "notes": "Struct trong C# là một cấu trúc dữ liệu:\n- Giống như một class nhưng nó là một <b>kiểu tham trị (value type)</b>.\n- Không hỗ trợ kế thừa.\n- Constructor mặc định sẽ khởi tạo tất cả các biến về giá trị 0 hoặc null. Bạn không thể gán giá trị cho chúng trong constructor mặc định trừ khi chúng là `const`.\n- Không yêu cầu khởi tạo đối tượng trên vùng nhớ heap.\n- Theo mặc định, struct được truyền theo giá trị (pass by value), trong khi class được truyền theo tham chiếu (pass by reference).",
                    "terms": {
                        "Struct": "Một kiểu dữ liệu giá trị (value type) dùng để đóng gói một nhóm nhỏ các biến liên quan. Rất hữu ích cho các đối tượng nhẹ mà không cần đến các tính năng phức tạp của class như kế thừa.",
                        "Heap": "Một vùng bộ nhớ được sử dụng cho việc cấp phát động. Các đối tượng của class (kiểu tham chiếu) được lưu trữ trên heap.",
                        "Pass by value": "Khi một biến được truyền vào một phương thức, một bản sao của giá trị của biến đó được tạo ra. Mọi thay đổi trên bản sao bên trong phương thức không ảnh hưởng đến biến gốc.",
                        "Pass by reference": "Khi một biến được truyền vào một phương thức, một tham chiếu (địa chỉ bộ nhớ) đến đối tượng gốc được truyền vào. Mọi thay đổi bên trong phương thức sẽ ảnh hưởng trực tiếp đến đối tượng gốc."
                    }
                },
                {
                    "id": 19,
                    "title": "Trang 19: C# cơ bản - Mảng, List & Dictionary",
                    "image": "images/game-dev/week1/slide_19.png",
                    "notes": "C# có hai loại mảng chính: <b>mảng chữ nhật (rectangular)</b> và <b>mảng lởm chởm (jagged)</b>. Trong hầu hết các trường hợp, bạn sẽ sử dụng mảng chữ nhật vì nó hiệu quả hơn.\n\n- <b>List</b> và <b>Dictionary</b> là các cấu trúc dữ liệu generic (giống như trong Java).\n  - <b>List<T>:</b> Một danh sách động có thể thêm, xóa, sắp xếp các phần tử.\n  - <b>Dictionary<TKey, TValue>:</b> Một bộ sưu tập các cặp key-value, cho phép truy xuất giá trị nhanh chóng thông qua key.",
                    "terms": {
                        "Rectangular Array (Mảng chữ nhật)": "Một mảng đa chiều trong đó mỗi 'hàng' có cùng một số lượng 'cột'. Ví dụ: `int[,] a = new int[2,3];`.",
                        "Jagged Array (Mảng lởm chởm)": "Một mảng của các mảng, trong đó mỗi mảng con có thể có một độ dài khác nhau. Ví dụ: `int[][] a = new int[3][];`.",
                        "List<T>": "Một lớp generic trong .NET đại diện cho một danh sách các đối tượng có thể được truy cập bằng chỉ mục. Kích thước của nó có thể thay đổi động.",
                        "Dictionary<TKey, TValue>": "Một lớp generic đại diện cho một bộ sưu tập các cặp khóa-giá trị, cung cấp khả năng tra cứu rất nhanh."
                    }
                },
                {
                    "id": 20,
                    "title": "Trang 20: C# cơ bản - Enumerations",
                    "image": "images/game-dev/week1/slide_20.png",
                    "notes": "Enumerations (hay Enums) được sử dụng thường xuyên trong game để chỉ định các trạng thái khác nhau của trò chơi (ví dụ: màn hình chờ, đang chơi, tạm dừng, v.v.).\n\n- Enum thường được sử dụng kết hợp với câu lệnh `switch`.\n- Mỗi thành viên của enum có một giá trị số nguyên (integral value) tương ứng, theo thứ tự khai báo và bắt đầu từ 0.\n- Bạn có thể gán giá trị tường minh cho các thành viên của enum.\n- Giá trị số nguyên của một thành viên enum có thể được truy xuất bằng cách ép kiểu tường minh (explicit casting).",
                    "terms": {
                        "Enumeration (Enum)": "Một kiểu dữ liệu đặc biệt cho phép một biến là một tập hợp các hằng số được đặt tên trước. Nó giúp làm cho code dễ đọc và dễ bảo trì hơn bằng cách sử dụng tên thay vì các con số 'ma thuật' (magic numbers)."
                    }
                },
                {
                    "id": 21,
                    "title": "Trang 21: C# cơ bản - Các vòng lặp",
                    "image": "images/game-dev/week1/slide_21.png",
                    "notes": "C# có nhiều câu lệnh lặp (iteration statements), tương tự như Java:\n\n- <b>for:</b> Lặp lại một khối lệnh một số lần xác định, thường dùng với một biến đếm.\n- <b>foreach:</b> Duyệt qua tất cả các phần tử trong một bộ sưu tập (như mảng hoặc List) mà không cần dùng đến chỉ số (index).\n- <b>while:</b> Lặp lại một khối lệnh chừng nào một điều kiện còn đúng. Điều kiện được kiểm tra trước mỗi lần lặp.\n- <b>do-while:</b> Tương tự như 'while', nhưng khối lệnh được thực thi ít nhất một lần trước khi điều kiện được kiểm tra.\n\nNgoài ra, C# cũng có các câu lệnh <b>break</b> (để thoát khỏi vòng lặp), <b>continue</b> (để bỏ qua lần lặp hiện tại và đi đến lần tiếp theo), và <b>goto</b>.",
                    "terms": {
                        "Iteration (Sự lặp lại)": "Hành động thực hiện một khối mã nguồn nhiều lần. Các vòng lặp là công cụ chính để thực hiện iteration.",
                        "foreach loop": "Một loại vòng lặp được thiết kế để duyệt qua từng phần tử của một bộ sưu tập một cách đơn giản và dễ đọc.",
                        "break": "Một câu lệnh dùng để chấm dứt ngay lập tức vòng lặp (for, foreach, while, do-while) hoặc câu lệnh switch.",
                        "continue": "Một câu lệnh dùng để bỏ qua phần còn lại của lần lặp hiện tại và chuyển ngay sang lần lặp tiếp theo của vòng lặp."
                    }
                },
                {
                    "id": 22,
                    "title": "Trang 22: C# cơ bản - Các khái niệm bổ sung",
                    "image": "images/game-dev/week1/slide_22.png",
                    "notes": "Một vài khái niệm bổ sung trong C#:\n\n- <b>Comments (Chú thích):</b> Có 3 loại chính: `//` cho chú thích một dòng, `/* ... */` cho chú thích nhiều dòng, và `///` cho chú thích tài liệu XML.\n- <b>Từ khóa 'is':</b> Dùng để kiểm tra xem một đối tượng có tương thích với một kiểu dữ liệu cho trước hay không.\n- <b>Preprocessor directives (Chỉ thị tiền xử lặp):</b> Các lệnh đặc biệt như `#if`, `#elif`, `#else`, `#endif` cho phép trình biên dịch bỏ qua một số dòng code nhất định khi xây dựng và thực thi. Rất hữu ích để viết code chỉ chạy trên một nền tảng cụ thể (ví dụ: Wii, Web) hoặc chỉ trong chế độ gỡ lỗi (DEBUG).",
                    "terms": {
                        "Preprocessor Directive": "Một chỉ thị cho trình biên dịch, được xử lý trước khi quá trình biên dịch mã nguồn thực sự bắt đầu. Chúng thường được dùng để biên dịch có điều kiện (conditional compilation).",
                        "is (keyword)": "Một toán tử trong C# dùng để kiểm tra kiểu của một đối tượng tại thời điểm chạy (runtime). Nó trả về `true` nếu đối tượng là một thể hiện của kiểu đó hoặc một kiểu dẫn xuất từ nó."
                    }
                },
                {
                    "id": 23,
                    "title": "Trang 23: Chuyển tiếp - Scripting trong C# cho Unity3D",
                    "image": "images/game-dev/week1/slide_23.png",
                    "notes": "Kết thúc phần giới thiệu các khái niệm cơ bản của C#.\n\nPhần tiếp theo sẽ tập trung vào cách viết script bằng C# để điều khiển các đối tượng và hành vi trong Unity3D.",
                    "terms": {}
                },
                {
                    "id": 24,
                    "title": "Trang 24: Scripting cho Unity",
                    "image": "images/game-dev/week1/slide_24.png",
                    "notes": "Scripting là một phần thiết yếu của việc làm game, nó quyết định cách người chơi tương tác, cách các yếu tố trong game hoạt động, tạo hiệu ứng đồ họa, AI của kẻ thù, vật lý, v.v.\n\nTrong Unity3D 5.1, có thể viết script bằng 3 ngôn ngữ: C#, UnityScript (Javascript) và Boo. Chúng ta sẽ <b>chỉ sử dụng C#</b> trong môn học này.\n\n- <b>Game Object:</b> Là mỗi thực thể hiện diện trong một Màn chơi (Scene) của game.\n- <b>Components:</b> Mỗi Game Object chứa một bộ sưu tập các Components (ví dụ: đèn, vùng va chạm, animation...).\n- <b>Scripts:</b> Có thể được xem như một loại component hành vi (behaviour component) và cần phải được <b>gắn (attached)</b> vào một Game Object để hoạt động.",
                    "terms": {
                        "Scripting": "Quá trình viết mã nguồn (script) để định nghĩa hành vi, logic và các sự kiện trong một môi trường phần mềm, chẳng hạn như một game engine.",
                        "Game Object": "Trong Unity, đây là đối tượng cơ bản nhất trong một Scene. Mọi thứ bạn thấy và tương tác trong game đều là hoặc được gắn vào một Game Object.",
                        "Component": "Các khối xây dựng chức năng trong Unity. Mỗi component cung cấp một tính năng cụ thể cho một Game Object (ví dụ: `Transform` để xác định vị trí, `Rigidbody` để xử lý vật lý).",
                        "Scene": "Trong Unity, đây là một màn chơi hoặc một cấp độ của game. Nó chứa tất cả các Game Objects, môi trường và giao diện người dùng cho phần đó của trò chơi."
                    }
                },
                {
                    "id": 25,
                    "title": "Trang 25: Cấu trúc của một Script",
                    "image": "images/game-dev/week1/slide_25.png",
                    "notes": "Một Game Object có thể chứa nhiều script. Lý tưởng nhất, mỗi script nên đảm nhận một hành vi cụ thể của đối tượng.\n\nKhi tạo một C# Script mới từ trình soạn thảo Unity, mã nguồn ban đầu sẽ có cấu trúc như sau:\n- Kế thừa từ lớp <b>MonoBehaviour</b>. Đây là lớp cơ sở cho tất cả các script trong Unity.\n- Phương thức <b>Start():</b> Được gọi một lần duy nhất khi script được kích hoạt, thường dùng cho việc khởi tạo.\n- Phương thức <b>Update():</b> Được gọi một lần trong mỗi khung hình (frame). Đây là nơi chứa hầu hết logic của game.\n\n<b>Lưu ý quan trọng:</b> Script trong Unity <b>không có constructor!</b> Bạn không được thêm bất kỳ constructor nào. Unity sẽ tự tạo đối tượng cho bạn trước khi game bắt đầu.",
                    "terms": {
                        "MonoBehaviour": "Lớp cơ sở mà mọi script trong Unity phải kế thừa từ đó nếu muốn được gắn vào một Game Object và tương tác với game engine.",
                        "Start()": "Một phương thức đặc biệt của MonoBehaviour được Unity tự động gọi một lần trong suốt vòng đời của script, sau khi các đối tượng đã được tạo nhưng trước khi vòng lặp Update() đầu tiên bắt đầu.",
                        "Update()": "Một phương thức đặc biệt của MonoBehaviour được Unity tự động gọi ở mỗi khung hình. Logic game chính, như di chuyển và xử lý input, thường được đặt ở đây.",
                        "Frame (Khung hình)": "Một hình ảnh tĩnh duy nhất trong một chuỗi các hình ảnh tạo nên một video hoặc chuyển động trong game. Tốc độ khung hình (FPS - Frames Per Second) đo lường số lượng khung hình được hiển thị mỗi giây."
                    }
                },
                {
                    "id": 26,
                    "title": "Trang 26: Các hàm sự kiện (Event Functions) - Phần 1",
                    "image": "images/game-dev/week1/slide_26.png",
                    "notes": "Unity điều khiển các script bằng cách gọi một tập hợp các hàm được xác định trước, gọi là <b>Event Functions</b> (Hàm sự kiện). Dưới đây là các hàm phổ biến nhất:\n\n<b>Khởi tạo (Initialization):</b>\n- <b>Awake():</b> Hàm đầu tiên được gọi khi scene được tải, chỉ được gọi một lần nếu game object đang 'active'.\n- <b>Start():</b> Được gọi trước frame đầu tiên, chỉ được gọi một lần nếu script (component) đang 'enabled'.\n\n<b>Các sự kiện cập nhật thông thường (Regular Update Events):</b>\n- <b>FixedUpdate():</b> Thường được gọi thường xuyên hơn `Update()`. Dùng cho các tính toán vật lý. Được gọi độc lập với tốc độ khung hình (framerate).\n- <b>Update():</b> Được gọi ở mỗi khung hình. Dùng cho logic game chính.\n- <b>LateUpdate():</b> Được gọi một lần mỗi khung hình, sau khi `Update()` đã kết thúc. Hữu ích cho các hành vi cần chạy sau cùng, ví dụ như camera đi theo người chơi.",
                    "terms": {
                        "Event Function": "Các phương thức đặc biệt trong một script MonoBehaviour mà Unity tự động gọi tại các thời điểm cụ thể trong vòng đời của game (ví dụ: khi bắt đầu, ở mỗi khung hình, khi có va chạm...).",
                        "Awake()": "Được gọi khi một thể hiện của script được tải. Thường dùng để khởi tạo các tham chiếu giữa các script và các thiết lập ban đầu.",
                        "FixedUpdate()": "Được gọi theo một tần suất cố định (ví dụ: 50 lần/giây), không phụ thuộc vào tốc độ khung hình. Đây là nơi lý tưởng để xử lý các logic liên quan đến vật lý (Rigidbody).",
                        "LateUpdate()": "Được gọi sau khi tất cả các hàm Update() đã được thực thi. Thường được sử dụng cho các logic cần đảm bảo đã xử lý xong chuyển động, ví dụ như camera theo sau nhân vật.",
                        "Time.deltaTime": "Khoảng thời gian (tính bằng giây) đã trôi qua để hoàn thành khung hình cuối cùng. Thường được nhân với các giá trị chuyển động trong `Update()` để làm cho chuyển động mượt mà và độc lập với tốc- độ khung hình."
                    }
                },
                {
                    "id": 27,
                    "title": "Trang 27: Các hàm sự kiện (Event Functions) - Phần 2",
                    "image": "images/game-dev/week1/slide_27.png",
                    "notes": "Tiếp tục với các hàm sự kiện phổ biến khác:\n\n<b>Sự kiện GUI (Giao diện người dùng):</b>\n- <b>OnGUI():</b> Dùng cho các chức năng của giao diện người dùng đồ họa (Legacy GUI system).\n- <b>OnMouseDown(), OnMouseEnter(), OnMouseOver():</b> Dùng cho các sự kiện chuột liên quan đến GUI Components.\n\n<b>Sự kiện Vật lý (Physics Events):</b>\n- <b>OnCollisionEnter(), OnCollisionStay(), OnCollisionExit():</b> Dành cho các va chạm với các <b>Colliders</b>.\n- <b>OnTriggerEnter(), OnTriggerStay(), OnTriggerExit():</b> Dành cho các va chạm với các <b>Triggers</b>.",
                    "terms": {
                        "OnCollisionEnter()": "Được gọi khi một Collider/Rigidbody bắt đầu chạm vào một Collider/Rigidbody khác.",
                        "OnTriggerEnter()": "Được gọi khi một Collider đi vào một Collider khác được đánh dấu là 'Trigger'. Trigger dùng để phát hiện sự hiện diện mà không gây ra va chạm vật lý thực sự.",
                        "Execution Order (Thứ tự thực thi)": "Thứ tự cụ thể mà Unity gọi các hàm sự kiện khác nhau (Awake, Start, FixedUpdate, Update...). Việc hiểu rõ thứ tự này rất quan trọng để tránh các lỗi logic."
                    }
                },
                {
                    "id": 28,
                    "title": "Trang 28: Biến trong Script",
                    "image": "images/game-dev/week1/slide_28.png",
                    "notes": "Khi bạn khai báo một biến là <b>public</b> trong một script, nó sẽ tự động xuất hiện trong cửa sổ <b>Inspector</b> của Unity Editor.\n\nĐiều này cho phép bạn thay đổi giá trị của biến trực tiếp từ trình soạn thảo mà không cần sửa code.\n\n<b>Quy tắc ưu tiên:</b>\n- Giá trị bạn thiết lập trong <b>Editor</b> sẽ được ưu tiên hơn và ghi đè lên giá trị bạn khai báo trong code.\n- Tuy nhiên, bạn có thể ghi đè lại giá trị của Editor bằng cách gán một giá trị mới cho biến đó bên trong các hàm <b>Awake()</b> hoặc <b>Start()</b>.",
                    "terms": {
                        "public (keyword)": "Một access modifier. Khi một biến của MonoBehaviour được khai báo là 'public', nó sẽ được hiển thị và có thể chỉnh sửa được trong Inspector của Unity.",
                        "Inspector": "Một cửa sổ trong Unity Editor hiển thị thông tin chi tiết về Game Object hoặc asset đang được chọn. Đây là nơi bạn có thể xem và chỉnh sửa các component và thuộc tính của chúng."
                    }
                },
                {
                    "id": 29,
                    "title": "Trang 29: Mảng trong Script",
                    "image": "images/game-dev/week1/slide_29.png",
                    "notes": "Tương tự như các biến thông thường, khi bạn khai báo một mảng (Array) hoặc một List là <b>public</b>, nó cũng sẽ xuất hiện trong Inspector.\n\nInspector sẽ cung cấp một giao diện tiện lợi để bạn:\n- Thay đổi kích thước (Size) của mảng.\n- Gán các phần tử (Element) vào mảng, thường bằng cách kéo thả các Game Object hoặc các assets khác từ trong Editor vào các ô tương ứng.",
                    "terms": {
                        "GameObject.FindGameObjectsWithTag()": "Một phương thức của Unity dùng để tìm và trả về một mảng chứa tất cả các Game Object trong Scene đang có một 'Tag' (thẻ) cụ thể."
                    }
                },
                {
                    "id": 30,
                    "title": "Trang 30: Các Component của một Game Object",
                    "image": "images/game-dev/week1/slide_30.png",
                    "notes": "Mỗi Game Object chứa một bộ sưu tập các component. Dưới đây là một số component phổ biến nhất:\n\n- <b>Transform:</b> Xác định Vị trí, Xoay, và Tỷ lệ của một đối tượng. Đây là component duy nhất mà mọi Game Object đều bắt buộc phải có.\n- <b>Collider:</b> Định nghĩa hình dạng vật lý của đối tượng cho việc xử lý va chạm.\n- <b>Rigidbody:</b> Cho phép đối tượng được điều khiển bởi hệ thống vật lý của Unity (chịu tác động của trọng lực, lực đẩy...).\n- <b>Scripts:</b> Các component chứa mã nguồn để định nghĩa hành vi.\n- <b>Animator:</b> Giao diện để điều khiển hệ thống animation Mecanim.\n- <b>AudioSource:</b> Đại diện cho các nguồn âm thanh trong không gian 3D.\n- <b>Light:</b> Giao diện script cho các component ánh sáng.\n\n Một script có thể có một game object hoặc một component làm biến. Bạn có thể gán các giá trị này trực tiếp từ Editor.",
                    "terms": {
                        "Transform": "Một component lưu trữ vị trí, góc xoay và tỷ lệ của một Game Object. Mọi Game Object đều có một Transform.",
                        "Collider": "Một component định nghĩa một hình dạng (như hình hộp, hình cầu) cho mục đích va chạm vật lý. Collider không tự di chuyển, chúng chỉ là hình dạng.",
                        "Rigidbody": "Một component cho phép một Game Object được điều khiển bởi hệ thống vật lý của Unity. Để hai vật thể va chạm vật lý với nhau, cả hai phải có Collider và ít nhất một trong hai phải có Rigidbody.",
                        "Animator": "Component dùng để gán các animation (chuyển động) cho một Game Object và điều khiển chúng thông qua các trạng thái và tham số."
                    }
                },
                {
                    "id": 31,
                    "title": "Trang 31: Scripts và Game Objects (1/4)",
                    "image": "images/game-dev/week1/slide_31.png",
                    "notes": "Từ bên trong một script, bạn có thể truy cập đến tất cả các component khác của cùng một Game Object.\n\n<b>Cách truy cập các component:</b>\n1. <b>Lối tắt cũ (Không còn dùng trong Unity 5+):</b> Trước đây, các component phổ biến như `transform`, `rigidbody`, `collider` có thể được truy cập trực tiếp như một biến. Điều này đã bị loại bỏ.\n2. <b>Cách chung (Khuyên dùng):</b> Sử dụng phương thức generic `GetComponent<T>()`. Ví dụ: `GetComponent<Rigidbody>()` sẽ tìm và trả về component Rigidbody đầu tiên trên Game Object đó.\n3. <b>Cách thay thế (Không khuyến khích):</b> Có thể dùng chuỗi để gọi `GetComponent()`, ví dụ: `GetComponent(\"Rigidbody\")`. Tuy nhiên, cách này kém hiệu quả hơn về mặt hiệu suất.",
                    "terms": {
                        "GetComponent<T>()": "Phương thức quan trọng nhất để một script có thể 'giao tiếp' với các component khác trên cùng một Game Object. Nó tìm và trả về một tham chiếu đến component thuộc kiểu `T` được chỉ định."
                    }
                },
                {
                    "id": 32,
                    "title": "Trang 32: Scripts và Game Objects (2/4)",
                    "image": "images/game-dev/week1/slide_32.png",
                    "notes": "Unity cung cấp nhiều biến thể của `GetComponent` để tìm kiếm component ở các đối tượng khác:\n\n- <b>GetComponentInChildren<T>():</b> Trả về component kiểu `T` trên chính Game Object đó <b>hoặc</b> trên bất kỳ đối tượng con (children) nào của nó.\n- <b>GetComponentInParent<T>():</b> Trả về component kiểu `T` trên chính Game Object đó <b>hoặc</b> trên bất kỳ đối tượng cha (parent) nào của nó.\n\nCũng có thể lấy nhiều hơn một component cùng lúc:\n- <b>GetComponents<T>():</b> Trả về một <b>mảng</b> chứa <b>tất cả</b> các component kiểu `T` trên Game Object.\n- <b>GetComponentsInChildren<T>():</b> Trả về một <b>mảng</b> chứa <b>tất cả</b> các component kiểu `T` trên Game Object đó và tất cả các con của nó.\n- <b>GetComponentsInParent<T>():</b> Trả về một <b>mảng</b> chứa <b>tất cả</b> các component kiểu `T` trên Game Object đó và tất cả các cha của nó.",
                    "terms": {
                        "Parent/Children (Cha/Con)": "Trong Unity, bạn có thể tạo ra một hệ thống phân cấp bằng cách kéo một Game Object vào một Game Object khác trong cửa sổ Hierarchy. Đối tượng bị kéo vào sẽ trở thành 'con' và đối tượng kia là 'cha'. Đối tượng con sẽ thừa hưởng các phép biến đổi (vị trí, xoay, tỷ lệ) từ cha của nó."
                    }
                },
                {
                    "id": 33,
                    "title": "Trang 33: Scripts và Game Objects (3/4)",
                    "image": "images/game-dev/week1/slide_33.png",
                    "notes": "Thông thường, trong game sẽ có nhiều Game Object cùng loại (ví dụ: các đồng xu trong Mario, các điểm checkpoint trong game đua xe...).\n\n Một cách hay để giữ cho các đối tượng này được tổ chức gọn gàng là đặt tất cả chúng làm <b>con (children)</b> của một Game Object rỗng chung.\n\nSau đó, có thể truy cập tất cả các đối tượng con này thông qua component <b>Transform</b> của đối tượng cha. Bằng cách lặp qua `transform` của đối tượng cha, bạn có thể lấy được `transform` của từng đối tượng con.",
                    "terms": {}
                },
                {
                    "id": 34,
                    "title": "Trang 34: Scripts và Game Objects (4/4)",
                    "image": "images/game-dev/week1/slide_34.png",
                    "notes": "Ví dụ này minh họa cách các script có thể tham chiếu và lấy component từ các Game Object khác nhau:\n\n- <b>Dòng 6:</b> Khai báo một biến `player` kiểu `GameObject` để chứa tham chiếu đến đối tượng người chơi.\n- <b>Dòng 9:</b> Khai báo một biến `playerHealth` để chứa tham chiếu đến script `PlayerHealth` nằm trên đối tượng người chơi.\n- <b>Dòng 13:</b> Khai báo một biến `enemyHealth` để chứa tham chiếu đến script `EnemyHealth` nằm trên chính đối tượng kẻ thù này.\n\nTrong hàm <b>Awake()</b> (được gọi một lần):\n- <b>Dòng 20:</b> Tìm đối tượng người chơi trong Scene bằng Tag của nó.\n- <b>Dòng 23:</b> Lấy component (script) `PlayerHealth` từ đối tượng người chơi vừa tìm được.\n- <b>Dòng 26:</b> Lấy component (script) `EnemyHealth` từ chính Game Object này.",
                    "terms": {
                        "GameObject.FindGameObjectWithTag()": "Một phương thức của Unity dùng để tìm và trả về Game Object đầu tiên trong Scene có 'Tag' (thẻ) được chỉ định. Đây là một cách hiệu quả để tìm các đối tượng quan trọng như 'Player'."
                    }
                },
                {
                    "id": 35,
                    "title": "Trang 35: Các thao tác với Game Objects và Components",
                    "image": "images/game-dev/week1/slide_35.png",
                    "notes": "Các thao tác cơ bản để quản lý đối tượng và component tại thời điểm chạy (runtime):\n\n<b>Hủy (Destroying):</b>\n- `Destroy(obj, t)`: Hủy một đối tượng hoặc component. Tham số `t` (tùy chọn) là khoảng thời gian trì hoãn (tính bằng giây) trước khi hủy.\n- `Destroy` không hủy ngay lập tức, nó chỉ 'đánh dấu' đối tượng để hủy. Việc hủy thực sự sẽ diễn ra vào cuối khung hình.\n\n<b>Kích hoạt / Vô hiệu hóa (Activating / Deactivating) Game Objects:</b>\n- `SetActive(bool value)`: Bật (`true`) hoặc tắt (`false`) toàn bộ một Game Object. Khi một Game Object bị tắt, tất cả các component của nó (renderer, collider, script...) cũng sẽ bị vô hiệu hóa.\n\n<b>Bật / Tắt (Enabling / Disabling) Components:</b>\n- `Behaviour.enabled = bool`: Bật (`true`) hoặc tắt (`false`) một component cụ thể (thường là script). Các component bị tắt sẽ không được gọi hàm `Update()`.",
                    "terms": {
                        "Destroy()": "Một hàm cơ bản của Unity dùng để xóa một Game Object, một component, hoặc một asset khỏi Scene.",
                        "SetActive()": "Phương thức của Game Object dùng để kích hoạt hoặc vô hiệu hóa nó. Các đối tượng bị vô hiệu hóa sẽ không được vẽ, không va chạm và các script trên đó sẽ không chạy.",
                        "Behaviour.enabled": "Một thuộc tính của các component kế thừa từ `Behaviour` (như script, camera, light...). Thiết lập nó thành `false` sẽ vô hiệu hóa component đó mà không ảnh hưởng đến toàn bộ Game Object."
                    }
                },
                {
                    "id": 36,
                    "title": "Trang 36: Tên và Tag",
                    "image": "images/game-dev/week1/slide_36.png",
                    "notes": "Ngoài việc tham chiếu trực tiếp, Unity còn cho phép tìm kiếm Game Object bằng Tên hoặc Tag.\n\n<b>Tìm theo Tên (Name):</b>\n- `GameObject.Find(string name)`: Tìm và trả về Game Object đầu tiên có tên trùng khớp. Trả về `null` nếu không tìm thấy.\n- <b>Cảnh báo hiệu suất:</b> Không nên sử dụng hàm này liên tục ở mỗi frame (ví dụ trong `Update()`). Thay vào đó, hãy gọi nó một lần ở `Start()` và lưu kết quả vào một biến.\n\n<b>Tìm theo Tag:</b>\n- Tag là một 'nhãn' bạn có thể định nghĩa và gán cho một hoặc nhiều Game Object để phân loại chúng.\n- `GameObject.FindWithTag(string tag)`: Trả về một Game Object 'active' có tag tương ứng.\n- `GameObject.FindGameObjectsWithTag(string tag)`: Trả về một <b>mảng</b> chứa tất cả các Game Object 'active' có tag tương ứng. Trả về một mảng rỗng nếu không tìm thấy.\n- Lưu ý: Các hàm này là <b>static</b>, thuộc về chính lớp `GameObject`.",
                    "terms": {
                        "Tag": "Một thuộc tính tham chiếu dạng chuỗi có thể được gán cho một hoặc nhiều Game Object. Tag rất hữu ích để xác định và nhóm các loại đối tượng (ví dụ: 'Player', 'Enemy', 'Coin').",
                        "static (method)": "Một phương thức thuộc về chính class đó, không phải một thể hiện (instance) cụ thể của class. Bạn có thể gọi nó trực tiếp từ tên class (ví dụ: `GameObject.Find(...)`) mà không cần tạo đối tượng."
                    }
                },
                {
                    "id": 37,
                    "title": "Trang 37: Layer (1/4) - Giới thiệu",
                    "image": "images/game-dev/week1/slide_37.png",
                    "notes": "Layer (Lớp) là một cơ chế mạnh mẽ để tổ chức và phân loại Game Object cho các mục đích cụ thể:\n\n- <b>Rendering:</b> Cho phép Camera chỉ render (hiển thị) một phần của scene.\n- <b>Raycasting:</b> Cho phép các tia vật lý (raycast) chỉ tương tác với hoặc bỏ qua một số loại đối tượng nhất định.\n- <b>Lighting:</b> Cho phép các nguồn sáng chỉ chiếu sáng một số layer nhất định.\n- <b>Collision:</b> Xác định các quy tắc va chạm giữa các nhóm đối tượng.\n- <b>Sorting:</b> Xác định thứ tự hiển thị của các Sprite (đối tượng 2D).\n\nĐể gán một Game Object vào một layer, chỉ cần chọn layer ở menu thả xuống trên cùng của cửa sổ Inspector.",
                    "terms": {
                        "Layer": "Một cơ chế trong Unity dùng để nhóm các Game Object. Layer chủ yếu được sử dụng bởi Camera để chỉ render một phần của scene, và bởi hệ thống vật lý để kiểm soát va chạm.",
                        "Raycasting": "Quá trình 'bắn' ra một tia ảo theo một hướng nhất định để phát hiện xem nó có va chạm với Collider nào trên đường đi hay không. Rất hữu ích cho việc xác định tầm nhìn, bắn súng, tương tác với đối tượng..."
                    }
                },
                {
                    "id": 38,
                    "title": "Trang 38: Layer (2/4) - Tạo Layer mới",
                    "image": "images/game-dev/week1/slide_38.png",
                    "notes": "Unity cung cấp một số layer mặc định (Default, TransparentFX, Ignore Raycast, Water, UI), nhưng bạn có thể tạo các layer mới của riêng mình.\n\nĐể tạo hoặc chỉnh sửa layer, hãy đi tới menu <b>Edit → Project Settings → Tags and Layers</b>.",
                    "terms": {}
                },
                {
                    "id": 39,
                    "title": "Trang 39: Layer (3/4) - Culling Mask",
                    "image": "images/game-dev/week1/slide_39.png",
                    "notes": "Có thể chỉ định cho cả component Camera và Light rằng chúng sẽ ảnh hưởng đến những layer nào thông qua thuộc tính <b>Culling Mask</b>.\n\n- <b>Đối với Camera:</b> Culling Mask quyết định những layer nào sẽ được camera đó render (vẽ lên màn hình).\n- <b>Đối với Light:</b> Culling Mask quyết định những layer nào sẽ được nguồn sáng đó chiếu sáng.\n\nTheo mặc định, tất cả các layer đều được render và chiếu sáng.",
                    "terms": {
                        "Culling Mask": "Một thuộc tính trên Camera và Light cho phép bạn chọn lọc các layer mà chúng sẽ tương tác. 'Culling' có nghĩa là loại bỏ hoặc bỏ qua một cái gì đó."
                    }
                },
                {
                    "id": 40,
                    "title": "Trang 40: Layer (4/4) - Ma trận Va chạm",
                    "image": "images/game-dev/week1/slide_40.png",
                    "notes": "Một trong những ứng dụng mạnh mẽ nhất của Layer là kiểm soát va chạm (Layer-based collision detection).\n\nBạn có thể chỉ định chính xác những nhóm đối tượng nào có thể va chạm với nhau bằng cách bật/tắt các va chạm giữa các layer tương ứng của chúng trong một ma trận gọi là <b>Layer Collision Matrix</b>.\n\nMa trận này có thể được tìm thấy trong <b>Physics 2D Manager</b> (cho game 2D) hoặc <b>Physics Manager</b> (cho game 3D) bằng cách đi tới menu <b>Edit → Project Settings</b>.",
                    "terms": {
                        "Layer Collision Matrix": "Một ma trận dạng bảng trong cài đặt vật lý của Unity, cho phép bạn bật hoặc tắt khả năng va chạm giữa các cặp layer khác nhau."
                    }
                },
                {
                    "id": 41,
                    "title": "Trang 41: Prefab Assets",
                    "image": "images/game-dev/week1/slide_41.png",
                    "notes": "<b>Prefab</b> là một loại asset (tài sản) dùng để lưu trữ một Game Object hoàn chỉnh với tất cả các component và thuộc tính của nó.\n\n- Nó hoạt động như một <b>khuôn mẫu (template)</b> cho Game Object đó.\n- Mọi thay đổi bạn thực hiện trên Prefab asset sẽ ngay lập tức được phản ánh trên tất cả các 'thể hiện' (instances) của nó trong Scene.\n- Có thể ghi đè (override) các component và thiết lập cho từng thể hiện một cách riêng lẻ.\n\n Một prefab có thể được 'khởi tạo' (instantiated) một cách tự động tại thời điểm chạy bằng hàm `Instantiate()`.",
                    "terms": {
                        "Prefab": "Một Game Object đã được cấu hình sẵn và lưu lại như một Asset. Prefab cho phép bạn tạo, cấu hình và lưu trữ một Game Object cùng với tất cả các component, giá trị thuộc tính và các Game Object con của nó như một tài sản có thể tái sử dụng.",
                        "Instantiate()": "Hàm của Unity dùng để tạo ra một bản sao (clone) của một đối tượng tại thời điểm chạy. Thường được dùng để 'đẻ' ra các đối tượng từ Prefab (ví dụ: tạo viên đạn, kẻ thù...)."
                    }
                },
                {
                    "id": 42,
                    "title": "Trang 42: Invoke - Lên lịch các lệnh gọi hàm",
                    "image": "images/game-dev/week1/slide_42.png",
                    "notes": "Họ các phương thức <b>Invoke</b> cho phép bạn lên lịch để gọi một hàm sau một khoảng thời gian trễ. Chỉ các hàm có kiểu trả về là `void` và không có tham số mới có thể được gọi bằng cách này.\n\n- <b>Invoke(string methodName, float time):</b> Gọi hàm `methodName` sau `time` giây.\n- <b>InvokeRepeating(string methodName, float time, float repeatRate):</b> Gọi hàm `methodName` lần đầu sau `time` giây, sau đó lặp lại việc gọi hàm đó sau mỗi `repeatRate` giây.\n- <b>CancelInvoke():</b> Hủy tất cả các lệnh gọi `Invoke` trên script (MonoBehaviour) này.\n- <b>CancelInvoke(string methodName):</b> Chỉ hủy các lệnh gọi `Invoke` đến hàm `methodName`.",
                    "terms": {
                        "Invoke": "Một cơ chế đơn giản trong Unity để thực thi một phương thức sau một khoảng thời gian trễ. Hữu ích cho các hành động đơn giản, hẹn giờ."
                    }
                },
                {
                    "id": 43,
                    "title": "Trang 43: Coroutines (1/2) - Giới thiệu",
                    "image": "images/game-dev/week1/slide_43.png",
                    "notes": "<b>Coroutine</b> là một hàm có khả năng tạm dừng việc thực thi và trả lại quyền điều khiển cho Unity, sau đó tiếp tục lại từ nơi nó đã dừng ở một frame sau đó.\n\n- Nó được bắt đầu bằng cách gọi `StartCoroutine()`.\n- Phương thức được gọi phải có kiểu trả về là <b>IEnumerator</b>.\n- Nó có thể trả về (tạm dừng) bằng từ khóa <b>yield return</b>.\n- Ở lần cập nhật (update) tiếp theo, hàm sẽ tiếp tục thực thi từ sau điểm `yield return`.\n- Coroutine kết thúc khi phương thức chạy xong, hoặc khi `StopCoroutine()` được gọi.",
                    "terms": {
                        "Coroutine": "Một loại hàm đặc biệt trong Unity cho phép bạn thực hiện các tác vụ kéo dài qua nhiều frame. Nó giống như một hàm có thể 'tạm dừng' và 'tiếp tục' mà không chặn luồng chính của game.",
                        "IEnumerator": "Một interface trong .NET định nghĩa hành vi cho việc lặp qua một bộ sưu tập. Trong Unity, các hàm coroutine phải trả về kiểu này.",
                        "yield return": "Câu lệnh được sử dụng bên trong một coroutine để tạm dừng việc thực thi. Giá trị trả về sau 'yield return' sẽ quyết định khi nào coroutine sẽ tiếp tục (ví dụ: `yield return null` sẽ tiếp tục ở frame tiếp theo, `yield return new WaitForSeconds(3f)` sẽ tiếp tục sau 3 giây)."
                    }
                },
                {
                    "id": 44,
                    "title": "Trang 44: Coroutines (2/2) - Ví dụ",
                    "image": "images/game-dev/week1/slide_44.png",
                    "notes": "Ví dụ này minh họa một Coroutine tên là `Movement` dùng để di chuyển một đối tượng đến một vị trí `target` một cách mượt mà.\n\n- Vòng lặp `while` sẽ tiếp tục chạy chừng nào khoảng cách giữa vị trí hiện tại và vị trí mục tiêu còn lớn hơn 0.05f.\n- Bên trong vòng lặp, `Vector3.Lerp` được dùng để tính toán vị trí mới, di chuyển một chút về phía `target` ở mỗi frame.\n- `yield return null;` tạm dừng coroutine và sẽ tiếp tục lại ở frame tiếp theo, tạo ra hiệu ứng di chuyển mượt mà qua nhiều frame.",
                    "terms": {
                        "Vector3.Lerp(a, b, t)": "Hàm nội suy tuyến tính (Linear Interpolation) trả về một điểm nằm trên đường thẳng giữa hai điểm `a` và `b`. Tham số `t` là một giá trị từ 0 đến 1, quyết định vị trí của điểm trả về (0 là tại `a`, 1 là tại `b`)."
                    }
                },
                {
                    "id": 45,
                    "title": "Trang 45: Các thói quen lập trình tốt",
                    "image": "images/game-dev/week1/slide_45.png",
                    "notes": "Các nguyên tắc để giữ cho mã nguồn dễ bảo trì, dễ mở rộng và dễ đọc:\n\n- <b>Nguyên tắc Đơn trách nhiệm (Single Responsibility):</b> Mỗi class chỉ nên chịu trách nhiệm cho một nhiệm vụ duy nhất. Thay vì một class `Player.cs` làm mọi thứ, hãy tách nó ra thành `PlayerInput.cs`, `PlayerWeapons.cs`, `PlayerInventory.cs`...\n- <b>Nguyên tắc Đảo ngược sự phụ thuộc (Dependency Inversion):</b> Nếu class A phụ thuộc vào B, thì B nên là một interface hoặc một abstract class.\n- <b>Module hóa (Modularization):</b> Các hành vi độc lập nên được đặt trong các hàm hoặc thậm chí các class riêng biệt.",
                    "terms": {
                        "Single Responsibility Principle": "Một nguyên tắc thiết kế phần mềm phát biểu rằng mỗi module, class, hoặc hàm chỉ nên có trách nhiệm đối với một phần chức năng duy nhất.",
                        "Dependency Inversion Principle": "Một nguyên tắc thiết kế phần mềm phát biểu rằng các module cấp cao không nên phụ thuộc vào các module cấp thấp. Cả hai nên phụ thuộc vào các 'trừu tượng' (abstractions, ví dụ như interface)."
                    }
                },
                {
                    "id": 46,
                    "title": "Trang 46: Chuyển tiếp - Câu hỏi & Demo Lab",
                    "image": "images/game-dev/week1/slide_46.png",
                    "notes": "Kết thúc phần lý thuyết về Scripting trong C# cho Unity.\n\nPhần cuối cùng sẽ là các câu hỏi kiểm tra và xem trước nội dung buổi thực hành (Lab).",
                    "terms": {}
                },
                {
                    "id": 47,
                    "title": "Trang 47: Cảm ơn & Tổng kết thuật ngữ",
                    "image": "images/game-dev/week1/slide_47.png",
                    "notes": "Cảm ơn bạn đã theo dõi bài giảng Tuần 1. Dưới đây là danh sách tổng hợp các thuật ngữ quan trọng đã xuất hiện trong tuần này để bạn tiện ôn tập.",
                    "terms": {}
                }
            ]
        },
        {
            "title": "Tuần 2: 3D Games and User Input",
            "slides": [
                {
                    "id": 1,
                    "title": "Trang 1: Bìa - 3D Games and User Input",
                    "image": "images/game-dev/week2/slide_1.png",
                    "notes": "Bài giảng 2: Game 3D và Tương tác người dùng (User Input).\n\nTuần này sẽ tập trung vào các khái niệm toán học cơ bản trong game và cách quản lý các tín hiệu đầu vào từ người chơi.",
                    "terms": {}
                },
                {
                    "id": 2,
                    "title": "Trang 2: Đề cương bài giảng",
                    "image": "images/game-dev/week2/slide_2.png",
                    "notes": "Nội dung chính của bài giảng Tuần 2 bao gồm 3 phần:\n\n1. <b>Toán học trong Game (Math in Games)</b>.\n2. <b>Quản lý Tương tác người dùng (Managing Player Input)</b>.\n3. <b>Câu hỏi ôn tập và Xem trước buổi thực hành</b>.",
                    "terms": {}
                },
                {
                    "id": 3,
                    "title": "Trang 3: Chuyển tiếp - Toán học trong Game",
                    "image": "images/game-dev/week2/slide_3.png",
                    "notes": "Chuẩn bị vào phần đầu tiên: Các khái niệm toán học cơ bản được ứng dụng trong lập trình game.",
                    "terms": {}
                },
                {
                    "id": 4,
                    "title": "Trang 4: 2D Vectors",
                    "image": "images/game-dev/week2/slide_4.png",
                    "notes": "Vector là một đối tượng hình học có <b>độ lớn (magnitude)</b> và <b>hướng (direction)</b>.\n\nVector có thể được dùng để biểu diễn:\n- Một <b>điểm (point)</b> trong không gian.\n- Một <b>hướng (direction)</b> kèm theo một <b>độ lớn (magnitude)</b>.\n\nTrong Unity, các vector 2D có nhiều thuộc tính và phương thức hữu ích, có thể tham khảo thêm tại tài liệu của Unity.",
                    "terms": {
                        "Vector": "Một đại lượng toán học có cả độ lớn và hướng. Trong lập trình game, nó thường được dùng để biểu diễn vị trí, vận tốc, và lực.",
                        "Magnitude (Độ lớn)": "Độ dài của một vector, thường được tính bằng căn bậc hai của tổng bình phương các thành phần của nó. Nó biểu thị 'cường độ' của vector (ví dụ: tốc độ, độ lớn của lực).",
                        "Direction (Hướng)": "Hướng mà vector đang trỏ tới trong không gian.",
                        "Left Hand Rule Coordinates": "Hệ tọa độ quy tắc bàn tay trái. Trong hệ tọa độ này (được dùng bởi Unity), nếu bạn xòe bàn tay trái, ngón cái chỉ theo trục X dương, ngón trỏ chỉ theo trục Y dương, thì ngón giữa sẽ chỉ theo trục Z dương."
                    }
                },
                {
                    "id": 5,
                    "title": "Trang 5: 2D Vectors & Hình học cơ bản",
                    "image": "images/game-dev/week2/slide_5.png",
                    "notes": "Vector 2D được cấu tạo bởi hai thành phần (x, y). Với các vector bắt đầu từ gốc tọa độ (0,0), chúng biểu diễn khoảng cách từ gốc dọc theo trục X và Y.\n\nĐộ dài (hay độ lớn - magnitude) của một vector được xác định bởi norm của nó, tính theo công thức Pythagoras: `magnitude = ||vec|| = sqrt(x² + y²)`.\nTrong Unity, giá trị này có thể được truy cập dễ dàng thông qua thuộc tính `.magnitude`.\n\n<b>Ví dụ:</b> Một vector có thể biểu diễn tốc độ di chuyển của một vật thể. Nếu vector là (2, 5), vật thể đang di chuyển 2 đơn vị/giây theo trục X và 5 đơn vị/giây theo trục Y. Độ lớn của vector này là `sqrt(2² + 5²) = sqrt(29) ≈ 5.385`, đây chính là tốc độ tuyến tính của vật thể.",
                    "terms": {
                        "Vector2": "Một struct trong Unity dùng để biểu diễn các vector và điểm trong không gian 2D. Nó chứa hai thành phần public là `x` và `y`.",
                        "magnitude (thuộc tính)": "Một thuộc tính của các kiểu Vector (Vector2, Vector3...) trong Unity, trả về độ dài của vector đó."
                    }
                },
                {
                    "id": 6,
                    "title": "Trang 6: Các phép toán trên Vector (1/5)",
                    "image": "images/game-dev/week2/slide_6.png",
                    "notes": "Tổng quan về các phép toán cơ bản trên vector:\n\n- <b>Phép cộng (Addition):</b> Cộng từng thành phần tương ứng. Có tính giao hoán (`a + b = b + a`).\n- <b>Phép trừ (Subtraction):</b> Trừ từng thành phần tương ứng. Không có tính giao hoán (`a - b != b - a`).\n- <b>Nhân vô hướng (Scalar multiplication):</b> Nhân một số với từng thành phần của vector, làm thay đổi độ lớn của vector.\n- <b>Phủ định (Negation):</b> Đảo ngược dấu của tất cả các thành phần, tạo ra một vector có cùng độ lớn nhưng ngược hướng.\n- <b>Tích vô hướng (Dot product):</b> Một phép toán giữa hai vector cho kết quả là một số vô hướng (scalar).\n- <b>Tích có hướng (Cross product):</b> Một phép toán giữa hai vector trong không gian 3D, cho kết quả là một vector mới vuông góc với cả hai vector ban đầu.",
                    "terms": {
                        "Scalar (Vô hướng)": "Một đại lượng chỉ có độ lớn, không có hướng (ví dụ: một con số như 5, -10.5).",
                        "Dot Product (Tích vô hướng)": "Phép toán `a · b = ||a|| ||b|| cos(θ)`. Kết quả là một số vô hướng. Rất hữu ích để tính góc giữa hai vector hoặc để 'chiếu' một vector lên một vector khác.",
                        "Cross Product (Tích có hướng)": "Phép toán `a x b`. Chỉ xác định trong không gian 3D, kết quả là một vector mới vuông góc với mặt phẳng chứa hai vector ban đầu. Rất hữu ích để tìm vector pháp tuyến của một mặt phẳng."
                    }
                },
                {
                    "id": 7,
                    "title": "Trang 7: Các phép toán trên Vector (2/5)",
                    "image": "images/game-dev/week2/slide_7.png",
                    "notes": "Minh họa hình học của các phép toán trên vector:\n\n- <b>a + b:</b> Đặt gốc của vector b vào đầu của vector a. Vector tổng là vector nối từ gốc của a đến đầu của b (quy tắc hình bình hành).\n- <b>a - b:</b> Tương đương với `a + (-b)`. Là vector nối từ đầu của b đến đầu của a.\n- <b>ac:</b> Vector a được kéo dài hoặc co lại một lượng bằng c. Nếu c < 0, vector sẽ đổi hướng.\n- <b>-a:</b> Vector a có cùng độ lớn nhưng ngược hướng.\n- <b>ab (Dot product):</b> Biểu diễn hình chiếu của vector a lên vector b (hoặc ngược lại) nhân với độ dài của vector kia.\n- <b>a x b (Cross product):</b> Vector kết quả vuông góc với cả a và b, tuân theo quy tắc bàn tay.",
                    "terms": {}
                },
                {
                    "id": 8,
                    "title": "Trang 8: Các phép toán trên Vector (3/5)",
                    "image": "images/game-dev/week2/slide_8.png",
                    "notes": "Trong Unity, bạn có thể sử dụng các toán tử thông thường (`+`, `-`, `*`, `/`) để thực hiện các phép toán cộng, trừ vector, và nhân/chia một vector với một số.\n\n<b>Vector đơn vị (Unit vector):</b>\n- Là một vector bất kỳ có độ dài (magnitude) bằng 1.\n- Vector đơn vị thường được dùng để chỉ định một <b>hướng</b> mà không quan tâm đến độ lớn.\n- Bất kỳ vector nào cũng có thể được 'chuẩn hóa' (normalizing) để trở thành một vector đơn vị bằng cách chia nó cho chính độ dài của nó.\n- Trong Unity, có thể chuẩn hóa một vector bằng cách gọi hàm `Normalize()`.",
                    "terms": {
                        "Unit Vector (Vector đơn vị)": "Một vector có độ lớn chính xác bằng 1. Nó rất hữu ích để biểu diễn một hướng thuần túy.",
                        "Normalizing (Chuẩn hóa)": "Quá trình biến một vector có độ dài bất kỳ thành một vector đơn vị (độ dài bằng 1) nhưng vẫn giữ nguyên hướng ban đầu."
                    }
                },
                {
                    "id": 9,
                    "title": "Trang 9: Các phép toán trên Vector (4/5)",
                    "image": "images/game-dev/week2/slide_9.png",
                    "notes": "<b>Tích vô hướng (Dot Product)</b>, đôi khi được gọi là inner product, cho kết quả là một số vô hướng (scalar).\nCông thức: `a · b = ||a|| ||b|| cos(θ)`, trong đó `θ` là góc (tính bằng radian) giữa hai vector.\n\nĐối với các vector đã được chuẩn hóa (normalized vectors):\n- Tích vô hướng bằng <b>1</b> nếu chúng trỏ về cùng một hướng.\n- Tích vô hướng bằng <b>-1</b> nếu chúng trỏ về hai hướng hoàn toàn đối lập.\n- Tích vô hướng bằng <b>0</b> nếu hai vector vuông góc với nhau.\n\nĐây là một phép toán rất hữu ích để xác định góc giữa hai vector, ví dụ như để xác định góc quay cần thiết để đối mặt với một vị trí nhất định, góc nhìn, v.v.",
                    "terms": {
                        "Radian": "Một đơn vị đo góc. Một vòng tròn đầy đủ là 2π radian (tương đương 360 độ). Hầu hết các hàm lượng giác trong lập trình đều sử dụng radian."
                    }
                },
                {
                    "id": 10,
                    "title": "Trang 10: Các phép toán trên Vector (5/5)",
                    "image": "images/game-dev/week2/slide_10.png",
                    "notes": "Trong Unity, bạn có thể sử dụng các hàm sau để tính toán góc giữa hai vector:\n\n1. <b>Chuẩn hóa (Normalize):</b> Để có kết quả chính xác, bạn nên chuẩn hóa cả hai vector trước khi tính tích vô hướng của chúng.\n2. <b>`Vector2.Dot(a, b)`:</b> Tính tích vô hướng của hai vector a và b.\n3. <b>`Mathf.Acos(dotProduct)`:</b> Tính góc (tính bằng radian) từ giá trị tích vô hướng. Đây là hàm arccos(x).\n4. <b>`Mathf.Rad2Deg`:</b> Một hằng số dùng để nhân với giá trị radian để chuyển đổi nó sang độ (degrees).",
                    "terms": {
                        "Vector2.Dot()": "Một hàm static của lớp Vector2 dùng để tính tích vô hướng giữa hai vector 2D.",
                        "Mathf.Acos()": "Hàm trong lớp Mathf của Unity, trả về giá trị arccos của một số. Kết quả là góc (tính bằng radian) có cosin là số đó.",
                        "Mathf.Rad2Deg": "Một hằng số trong lớp Mathf có giá trị là `180 / PI`. Nhân một góc tính bằng radian với hằng số này sẽ chuyển đổi nó sang độ."
                    }
                },
                {
                    "id": 11,
                    "title": "Trang 11: 3D Vectors",
                    "image": "images/game-dev/week2/slide_11.png",
                    "notes": "Vector 3D là một đối tượng hình học trong không gian 3 chiều, có <b>độ lớn (magnitude)</b> và <b>hướng (direction)</b>.\n\nTương tự như vector 2D, chúng có thể được dùng để biểu diễn một <b>điểm (point)</b> trong không gian hoặc một <b>hướng</b> kèm theo một <b>độ lớn</b>.\n\nTrong Unity, các vector 3D có rất nhiều thuộc tính và phương thức, có thể tham khảo thêm tại tài liệu của Unity về Vector3.",
                    "terms": {
                        "Vector3": "Một struct trong Unity dùng để biểu diễn các vector và điểm trong không gian 3D. Nó chứa ba thành phần public là `x`, `y`, và `z`."
                    }
                },
                {
                    "id": 12,
                    "title": "Trang 12: Các phép toán trên Vector 3D (1/4)",
                    "image": "images/game-dev/week2/slide_12.png",
                    "notes": "Tương tự như Vector2, bạn có thể sử dụng các toán tử thông thường (`+`, `-`, `*`, `/`) để thực hiện các phép toán cộng, trừ, và nhân/chia một Vector3 với một số.\n\nKhái niệm <b>Vector đơn vị (Unit vector)</b> và việc <b>chuẩn hóa (normalizing)</b> một vector bằng hàm `Normalize()` cũng được áp dụng tương tự như trong không gian 2D.",
                    "terms": {}
                },
                {
                    "id": 13,
                    "title": "Trang 13: Các phép toán trên Vector 3D (2/4)",
                    "image": "images/game-dev/week2/slide_13.png",
                    "notes": "Các phép toán cơ bản như <b>Phép cộng (Addition)</b>, <b>Phép trừ (Subtraction)</b>, <b>Nhân vô hướng (Scalar multiplication)</b>, và <b>Phủ định (Negation)</b> được thực hiện trên 3 thành phần (x, y, z) tương tự như với vector 2D.\n\n<b>Tích vô hướng (Dot product)</b> và <b>Tích có hướng (Cross product)</b> cũng có các công thức tương ứng trong không gian 3D.",
                    "terms": {}
                },
                {
                    "id": 14,
                    "title": "Trang 14: Các phép toán trên Vector 3D (3/4)",
                    "image": "images/game-dev/week2/slide_14.png",
                    "notes": "<b>Tích có hướng (Cross Product)</b>, hay còn gọi là vector product, là một phép toán nhị phân trên hai vector trong không gian 3 chiều.\n\nKết quả của `a x b` là một vector mới <b>vuông góc</b> với cả hai vector `a` và `b` (tức là vuông góc với mặt phẳng chứa chúng).\n\nHướng của vector kết quả có thể được xác định bằng <b>'quy tắc bàn tay phải' (right hand rule)</b>.\n\nVí dụ: Hàm `GetNormal` trên slide cho thấy cách tính vector pháp tuyến của một mặt phẳng tam giác bằng cách lấy tích có hướng của hai cạnh của tam giác đó.",
                    "terms": {
                        "Right Hand Rule (Quy tắc bàn tay phải)": "Một quy ước để xác định hướng của vector kết quả trong phép tích có hướng. Nếu bạn cuộn các ngón tay của bàn tay phải từ vector đầu tiên sang vector thứ hai, ngón cái sẽ chỉ theo hướng của vector tích có hướng.",
                        "Normal Vector (Vector pháp tuyến)": "Một vector vuông góc với một bề mặt tại một điểm nhất định. Vector pháp tuyến rất quan trọng trong đồ họa máy tính để tính toán sự phản xạ ánh sáng và các hiệu ứng khác."
                    }
                },
                {
                    "id": 15,
                    "title": "Trang 15: Các phép toán trên Vector 3D (4/4)",
                    "image": "images/game-dev/week2/slide_15.png",
                    "notes": "Một ví dụ ứng dụng của Tích có hướng là tìm trục quay để áp dụng mô-men xoắn (torque) nhằm xoay tháp pháo của một chiếc xe tăng.\n\nBằng cách lấy tích có hướng giữa <b>hướng hiện tại</b> của tháp pháo và <b>hướng mà nó cần đối mặt</b>, chúng ta sẽ có được vector trục quay (trong ví dụ là vector C).\n\nTích có hướng cũng có thể được dùng để xác định vector pháp tuyến của một mặt phẳng (ví dụ: một tam giác trên một bề mặt) nhằm tính toán hướng cho va chạm và ánh sáng.",
                    "terms": {
                        "Torque (Mô-men xoắn)": "Một lực xoắn gây ra sự thay đổi trong chuyển động quay của một vật thể. Trong Unity, bạn có thể áp dụng torque cho một Rigidbody để làm nó quay."
                    }
                },
                {
                    "id": 16,
                    "title": "Trang 16: Smooth Damp",
                    "image": "images/game-dev/week2/slide_16.png",
                    "notes": "<b>Vector3.SmoothDamp</b> là một hàm static rất hữu ích để di chuyển một đối tượng đến một vị trí mục tiêu một cách mượt mà, giống như có một bộ giảm xóc.\n\nVector sẽ được làm mượt theo một hàm giống như lò xo-giảm chấn và sẽ không bao giờ 'vọt lố' (overshoot) qua mục tiêu. Một ứng dụng phổ biến là làm mượt camera đi theo nhân vật.\n\nHàm này trả về vị trí mới và cập nhật lại vận tốc `currentVelocity` (được truyền vào bằng từ khóa `ref`) để duy trì sự mượt mà ở các frame tiếp theo.",
                    "terms": {
                        "Vector3.SmoothDamp()": "Một hàm của Unity dùng để di chuyển dần dần một vector tới một vị trí mong muốn trong một khoảng thời gian nhất định. Rất hữu ích để tạo ra các chuyển động camera hoặc đối tượng mượt mà.",
                        "ref (keyword)": "Từ khóa dùng khi truyền đối số vào phương thức, cho phép phương thức đó thay đổi giá trị của biến gốc. Biến truyền vào phải được khởi tạo trước."
                    }
                },
                {
                    "id": 17,
                    "title": "Trang 17: Transforms",
                    "image": "images/game-dev/week2/slide_17.png",
                    "notes": "Mọi đối tượng trong một Scene đều có một component <b>Transform</b>. Đây là component duy nhất không thể bị xóa bỏ.\n\nTransform quyết định 3 thuộc tính cơ bản của đối tượng:\n- <b>Position (Vị trí):</b> Vị trí của Transform theo tọa độ X, Y, và Z.\n- <b>Rotation (Góc xoay):</b> Góc xoay của Transform quanh các trục X, Y, và Z, tính bằng độ.\n- <b>Scale (Tỷ lệ):</b> Tỷ lệ của Transform dọc theo các trục X, Y, và Z. Giá trị 1 là kích thước gốc.\n\nMỗi Transform có thể có một 'cha' (parent), cho phép bạn áp dụng các thay đổi về vị trí, góc xoay và tỷ lệ một cách phân cấp.",
                    "terms": {
                        "Transform": "Một component lưu trữ vị trí, góc xoay và tỷ lệ của một Game Object. Mọi Game Object đều có một Transform."
                    }
                },
                {
                    "id": 18,
                    "title": "Trang 18: Tọa độ Local và World (1/2)",
                    "image": "images/game-dev/week2/slide_18.png",
                    "notes": "Component Transform của một game object chứa các vector như <b>forward</b>, <b>up</b>, và <b>right</b>. Các vector này xác định <b>hệ tọa độ cục bộ (local coordinate system)</b> của đối tượng.\n\nHệ tọa độ cục bộ (còn gọi là local space, model space, object space) có 3 trục vuông góc với nhau và có thể được dùng để biết đâu là phía trước, phía trên, và bên cạnh của đối tượng.\n\nKhi một phép xoay được áp dụng lên Transform, tất cả các trục này sẽ xoay theo để phản ánh sự thay đổi đó.",
                    "terms": {
                        "Local Space (Không gian cục bộ)": "Hệ tọa độ riêng của một Game Object, với gốc tọa độ (0,0,0) nằm ngay tại tâm của đối tượng đó. Các trục X, Y, Z của nó (right, up, forward) sẽ xoay cùng với đối tượng.",
                        "transform.forward": "Một vector đơn vị trỏ về phía trước (trục Z dương) của đối tượng trong không gian cục bộ của nó.",
                        "transform.up": "Một vector đơn vị trỏ về phía trên (trục Y dương) của đối tượng trong không gian cục bộ của nó.",
                        "transform.right": "Một vector đơn vị trỏ về phía bên phải (trục X dương) của đối tượng trong không gian cục bộ của nó."
                    }
                },
                {
                    "id": 19,
                    "title": "Trang 19: Tọa độ Local và World (2/2)",
                    "image": "images/game-dev/week2/slide_19.png",
                    "notes": "Mặt khác, <b>hệ tọa độ thế giới (world coordinate system)</b> định nghĩa các vector `Vector3.forward`, `Vector3.up`, và `Vector3.right`. Đây là các vector hằng số, chỉ hướng dương của các trục Z, Y, và X tương ứng.\n\nĐây là một hệ tọa độ chung cho tất cả các đối tượng trong Scene.\n\nLưu ý rằng hệ tọa độ cục bộ và hệ tọa độ thế giới không nhất thiết phải thẳng hàng với nhau. Do đó, nói rằng bạn 'xoay quanh vector forward của đối tượng' sẽ chính xác hơn là nói 'xoay quanh trục Z'.",
                    "terms": {
                        "World Space (Không gian thế giới)": "Một hệ tọa độ duy nhất, cố định và chung cho toàn bộ Scene. Mọi đối tượng trong Scene đều có một vị trí và góc xoay được xác định trong không gian này.",
                        "Vector3.forward": "Một vector hằng số `(0, 0, 1)`, đại diện cho hướng 'phía trước' trong không gian thế giới.",
                        "Vector3.up": "Một vector hằng số `(0, 1, 0)`, đại diện cho hướng 'phía trên' trong không gian thế giới.",
                        "Vector3.right": "Một vector hằng số `(1, 0, 0)`, đại diện cho hướng 'bên phải' trong không gian thế giới."
                    }
                },
                {
                    "id": 20,
                    "title": "Trang 20: Transforms.Translate (1/2)",
                    "image": "images/game-dev/week2/slide_20.png",
                    "notes": "Phương thức <b>Transform.Translate</b> di chuyển một transform theo một hướng và khoảng cách được chỉ định bởi vector `translation`.\n\n- Nếu `relativeTo` là `Space.Self` (mặc định), di chuyển sẽ được áp dụng tương đối với hệ tọa độ cục bộ của transform (ví dụ: `Vector3.forward` sẽ di chuyển đối tượng về phía trước của chính nó).\n- Nếu `relativeTo` là `Space.World`, di chuyển sẽ được áp dụng tương đối với hệ tọa độ thế giới.\n\n<b>Ví dụ A:</b> Di chuyển đối tượng về phía trước 1 đơn vị mỗi <b>frame</b>. Điều này sẽ làm đối tượng di chuyển rất nhanh trên các máy tính mạnh.\n<b>Ví dụ B:</b> Nhân với `Time.deltaTime` để di chuyển đối tượng về phía trước 1 đơn vị mỗi <b>giây</b>. Đây là cách làm đúng để chuyển động không phụ thuộc vào tốc độ khung hình.",
                    "terms": {
                        "Transform.Translate()": "Một phương thức của component Transform dùng để di chuyển đối tượng một khoảng cách nhất định theo một hướng nhất định.",
                        "Space.Self": "Một hằng số Enum chỉ định rằng một phép toán (như Translate hoặc Rotate) nên được thực hiện trong không gian cục bộ của đối tượng.",
                        "Space.World": "Một hằng số Enum chỉ định rằng một phép toán nên được thực hiện trong không gian thế giới."
                    }
                },
                {
                    "id": 21,
                    "title": "Trang 21: Transforms.Translate (2/2)",
                    "image": "images/game-dev/week2/slide_21.png",
                    "notes": "<b>Ví dụ C:</b> Chúng ta có thể thay đổi tốc độ di chuyển bằng cách khai báo một biến `speed` và nhân nó vào phép tính. Điều này cho phép di chuyển đối tượng với tốc độ `speed` đơn vị mỗi giây.\n\n<b>Ví dụ D:</b> Ví dụ trước tương đương với việc cung cấp tham số `Space.Self`. Nếu chúng ta muốn di chuyển đối tượng trong không gian tọa độ thế giới (world coordinates), nơi `Vector3.forward` luôn là trục Z dương, chúng ta cần chỉ định `Space.World` làm tham số cuối cùng.\n\nLưu ý: `Time.deltaTime` mặc định được thiết lập là 1/60 ≈ 0.0166, tương ứng với tốc độ khung hình 60 FPS.",
                    "terms": {}
                },
                {
                    "id": 22,
                    "title": "Trang 22: Lerp",
                    "image": "images/game-dev/week2/slide_22.png",
                    "notes": "<b>Lerp (Linear Interpolation - Nội suy tuyến tính)</b> là một hàm nội suy tuyến tính giữa hai điểm `from` và `to` theo một phần `t`.\n\nHàm này thường được sử dụng để tìm một điểm nằm trên đường thẳng giữa hai điểm đầu cuối, hoặc để di chuyển một đối tượng dần dần giữa các điểm đó.\n\nGiá trị `t` được kẹp trong khoảng [0, 1]. Khi `t = 0`, hàm trả về `from`. Khi `t = 1`, hàm trả về `to`. Khi `t = 0.5`, hàm trả về điểm nằm chính giữa `from` và `to`.\n\nVí dụ trên slide cho thấy cách sử dụng `Vector3.Lerp` để làm mượt chuyển động của camera theo một đối tượng `target`.",
                    "terms": {
                        "Lerp (Linear Interpolation)": "Một phép toán tìm một điểm mới nằm trên một đường thẳng giữa hai điểm cho trước. Nó rất phổ biến trong lập trình game để tạo ra các chuyển động mượt mà (smoothing), hiệu ứng mờ dần (fading), hoặc thay đổi giá trị theo thời gian."
                    }
                },
                {
                    "id": 23,
                    "title": "Trang 23: Các phép xoay trong 3D",
                    "image": "images/game-dev/week2/slide_23.png",
                    "notes": "Có ba loại xoay khác nhau có thể được thực hiện quanh một điểm trong không gian 3D, thường được gọi là <b>góc Euler (Euler angles)</b>:\n\n- <b>Pitch:</b> Xoay quanh trục <b>X</b> (làm máy bay ngóc lên hoặc chúc xuống).\n- <b>Yaw:</b> Xoay quanh trục <b>Y</b> (làm máy bay rẽ trái hoặc phải).\n- <b>Roll:</b> Xoay quanh trục <b>Z</b> (làm máy bay nghiêng sang hai bên).",
                    "terms": {
                        "Euler Angles": "Một bộ ba góc (thường là Pitch, Yaw, Roll) dùng để biểu diễn hướng của một vật thể trong không gian 3D. Mặc dù dễ hiểu, chúng có thể gây ra một vấn đề gọi là 'Gimbal Lock'."
                    }
                },
                {
                    "id": 24,
                    "title": "Trang 24: Transforms.Rotate",
                    "image": "images/game-dev/week2/slide_24.png",
                    "notes": "Phương thức <b>Transform.Rotate</b> xoay một transform quanh một `axis` (trục) một góc `angle` (tính bằng độ).\n\n- Nếu `relativeTo` là `Space.Self` (mặc định), phép xoay được áp dụng quanh các trục cục bộ (local axes) của transform.\n- Nếu `relativeTo` là `Space.World`, phép xoay được áp dụng quanh các trục của thế giới (world axes).\n\n<b>Ví dụ A:</b> Xoay đối tượng quanh trục Y (Yaw) với tốc độ `turnSpeed` độ mỗi giây.\n<b>Ví dụ B:</b> Phép xoay có thể được áp dụng quanh trục Y của không gian cục bộ hoặc không gian thế giới.",
                    "terms": {
                        "Transform.Rotate()": "Một phương thức của component Transform dùng để áp dụng một phép xoay cho đối tượng."
                    }
                },
                {
                    "id": 25,
                    "title": "Trang 25: Transform.LookAt",
                    "image": "images/game-dev/week2/slide_25.png",
                    "notes": "Phương thức <b>Transform.LookAt</b> xoay một transform sao cho vector 'forward' (phía trước) của nó trỏ vào vị trí hiện tại của `target` hoặc một `worldPosition` cho trước.\n\nĐây là một cách sử dụng rất hay để hướng camera vào một vị trí hoặc một đối tượng mục tiêu.\n\nTrong ví dụ, camera sẽ luôn xoay để 'nhìn' vào đối tượng `target` ở mỗi frame.",
                    "terms": {
                        "Transform.LookAt()": "Một phương thức của component Transform dùng để xoay đối tượng sao cho trục Z dương (forward) của nó hướng về một vị trí mục tiêu trong không gian thế giới."
                    }
                },
                {
                    "id": 26,
                    "title": "Trang 26: Transform.localScale",
                    "image": "images/game-dev/week2/slide_26.png",
                    "notes": "Unity không cung cấp một hàm `Transform.Scale()` riêng biệt. Tuy nhiên, có thể thay đổi trực tiếp trường `localScale` để điều chỉnh tỷ lệ của transform.\n\n<b>Lưu ý quan trọng về Vật lý:</b>\nNếu bạn muốn di chuyển một đối tượng có Collider (và tương tác với vật lý), bạn <b>không nên</b> sử dụng `Transform.Translate` hoặc `Transform.Rotate`. Thay vào đó, hãy sử dụng các hàm vật lý (sẽ được học ở bài giảng sau).\n\nChỉ nên sử dụng `Transform.Translate` hoặc `Transform.Rotate` khi đối tượng có một Rigidbody được đánh dấu là <b>kinematic</b>.",
                    "terms": {
                        "transform.localScale": "Một thuộc tính của Transform đại diện cho tỷ lệ của đối tượng so với đối tượng cha của nó. Nếu không có cha, nó là tỷ lệ trong không gian thế giới.",
                        "Kinematic (Rigidbody)": "Một loại Rigidbody không bị ảnh hưởng bởi các lực vật lý (như trọng lực hay va chạm). Nó chỉ di chuyển khi được điều khiển trực tiếp từ script thông qua Transform. Rigidbody kinematic vẫn có thể tương tác và gây ra va chạm với các Rigidbody thông thường khác."
                    }
                },
                {
                    "id": 27,
                    "title": "Trang 27: Vấn đề Gimbal Lock (1/2)",
                    "image": "images/game-dev/week2/slide_27.png",
                    "notes": "Việc xoay một đối tượng trực tiếp bằng góc Euler (Pitch, Yaw, Roll) rất trực quan. Tuy nhiên, bên trong, Transform lưu trữ một ma trận được hình thành từ các vector cục bộ (Right, Up, Forward).\n\nCách áp dụng các phép xoay này hoạt động tốt, nhưng nó có thể gặp phải vấn đề <b>gimbal lock</b>: sự mất mát một bậc tự do trong không gian ba chiều, xảy ra khi các trục của hai trong ba gimbal bị đẩy vào một cấu hình song song.",
                    "terms": {
                        "Gimbal Lock": "Một hiện tượng trong không gian 3D xảy ra khi sử dụng góc Euler, khiến cho một trong ba trục xoay trở nên vô dụng (ví dụ: xoay quanh trục Y và trục Z lại cho cùng một kết quả). Điều này làm mất đi một bậc tự do và gây ra các chuyển động xoay không mong muốn.",
                        "Degree of Freedom (Bậc tự do)": "Trong cơ học, đây là số lượng các tham số độc lập định nghĩa cấu hình của một hệ thống. Một vật thể rắn trong không gian 3D có 6 bậc tự do: 3 cho tịnh tiến (di chuyển theo X, Y, Z) và 3 cho quay (xoay quanh X, Y, Z)."
                    }
                },
                {
                    "id": 28,
                    "title": "Trang 28: Vấn đề Gimbal Lock (2/2)",
                    "image": "images/game-dev/week2/slide_28.png",
                    "notes": "Slide này minh họa bằng toán học ma trận về cách vấn đề gimbal lock xảy ra. Khi một góc xoay (ví dụ: β) bằng 0 hoặc 90 độ, hai ma trận xoay khác có thể bị 'khóa' vào nhau, làm cho hai phép xoay riêng biệt (α và γ) lại có cùng một tác dụng, dẫn đến mất một bậc tự do.",
                    "terms": {}
                },
                {
                    "id": 29,
                    "title": "Trang 29: Quaternions (1/3) - Giới thiệu",
                    "image": "images/game-dev/week2/slide_29.png",
                    "notes": "<b>Quaternions</b> là các vector bốn chiều của số thực, cho phép ba phép toán: cộng, nhân vô hướng và nhân quaternion. Chúng được sử dụng để biểu diễn các phép xoay.\n\nUnity sử dụng Quaternions bên trong để biểu diễn tất cả các phép xoay vì chúng không bị gimbal lock và có thể dễ dàng được nội suy.\n\n Một quaternion có bốn thành phần: w, x, y, và z. Các thành phần này hoạt động cùng nhau và <b>không bao giờ</b> nên được sửa đổi riêng lẻ.\n\n<b>Quaternions vs. Euler:</b>\n- Quaternions không bị gimbal lock, cung cấp phép nội suy mượt mà hơn.\n- Các phép tính trên quaternion dễ dàng hơn.\n- Về mặt khái niệm, quaternion khó nắm bắt hơn so với góc Euler.",
                    "terms": {
                        "Quaternion": "Một hệ thống số phức bốn chiều được sử dụng trong đồ họa máy tính để biểu diễn các phép xoay trong không gian 3D. Đây là cách Unity lưu trữ và xử lý tất cả các góc xoay để tránh vấn đề Gimbal Lock."
                    }
                },
                {
                    "id": 30,
                    "title": "Trang 30: Quaternions (2/3) - LookRotation",
                    "image": "images/game-dev/week2/slide_30.png",
                    "notes": "Lớp Quaternion cung cấp nhiều chức năng hữu ích. Một trong những hàm static quan trọng là <b>Quaternion.LookRotation</b>.\n\n`Quaternion.LookRotation(Vector3 forward, Vector3 upwards)` tạo ra một phép xoay với hướng 'phía trước' (forward) và 'phía trên' (upwards) được chỉ định.\n\nKhi được sử dụng để định hướng một Transform, trục Z của đối tượng sẽ được căn chỉnh với vector `forward` và trục Y sẽ được căn chỉnh với vector `upwards`.",
                    "terms": {
                        "Quaternion.LookRotation()": "Một hàm static của lớp Quaternion, tạo ra một giá trị Quaternion đại diện cho một phép xoay. Phép xoay này sẽ làm cho đối tượng 'nhìn' về hướng của vector `forward` được cung cấp."
                    }
                },
                {
                    "id": 31,
                    "title": "Trang 31: Quaternions (3/3) - Slerp & Identity",
                    "image": "images/game-dev/week2/slide_31.png",
                    "notes": "Hai chức năng hữu ích khác của lớp Quaternion:\n\n<b>Quaternion.Slerp(from, to, t):</b>\n- Nội suy hình cầu (Spherical Linear Interpolation) giữa hai phép xoay `from` và `to` theo một phần `t`.\n- Đây là cách chính xác và mượt mà nhất để xoay một đối tượng dần dần từ góc này sang góc khác.\n\n<b>Quaternion.identity:</b>\n- Đại diện cho một phép xoay 'rỗng' (không xoay). Nó hoàn toàn thẳng hàng với các trục của thế giới.\n- Rất hữu ích để reset góc xoay của một đối tượng về trạng thái ban đầu.",
                    "terms": {
                        "Slerp (Spherical Linear Interpolation)": "Một phép toán nội suy trên một mặt cầu. Trong Unity, nó được dùng để tạo ra các phép xoay mượt mà và tự nhiên giữa hai hướng khác nhau với tốc độ không đổi.",
                        "Quaternion.identity": "Một thuộc tính static của lớp Quaternion trả về một phép xoay không có sự thay đổi nào (tương đương với góc xoay (0, 0, 0))."
                    }
                },
                {
                    "id": 32,
                    "title": "Trang 32: Chuyển tiếp - Quản lý Tương tác người dùng",
                    "image": "images/game-dev/week2/slide_32.png",
                    "notes": "Kết thúc phần Toán học trong Game.\n\nPhần tiếp theo sẽ tập trung vào cách Unity quản lý và xử lý các tín hiệu đầu vào từ người chơi (bàn phím, chuột, tay cầm...).",
                    "terms": {}
                },
                {
                    "id": 33,
                    "title": "Trang 33: The Input Manager (1/2)",
                    "image": "images/game-dev/week2/slide_33.png",
                    "notes": "Unity hỗ trợ các loại thiết bị đầu vào truyền thống như bàn phím, tay cầm (joypad), v.v., cũng như màn hình cảm ứng và các cảm biến chuyển động của thiết bị di động.\n\n<b>Input Manager</b> là nơi bạn định nghĩa tất cả các 'trục' (axes) và 'hành động' (actions) đầu vào cho dự án của mình.\nĐể xem Input Manager, hãy chọn menu <b>Edit → Project Settings → Input</b>.\n\nTất cả các trục được định nghĩa sẽ được hiển thị cho người chơi trong game launcher, cho phép họ tùy chỉnh lại các nút bấm theo ý muốn.",
                    "terms": {
                        "Input Manager": "Một công cụ cài đặt trong Unity Editor cho phép bạn định nghĩa và quản lý các 'trục ảo' (virtual axes) cho các tín hiệu đầu vào của người chơi, chẳng hạn như 'Horizontal', 'Vertical', 'Jump', 'Fire1'."
                    }
                },
                {
                    "id": 34,
                    "title": "Trang 34: The Input Manager (2/2)",
                    "image": "images/game-dev/week2/slide_34.png",
                    "notes": "Đây là các cài đặt quan trọng nhất có thể được thiết lập cho mỗi trục:\n\n- <b>Name:</b> Tên chuỗi dùng để tham chiếu đến trục trong script.\n- <b>Positive/Negative Button:</b> Các phím sẽ gửi giá trị dương/âm cho trục (ví dụ: 'd' và 'a').\n- <b>Gravity, Dead, Sensitivity:</b> Các thông số ảnh hưởng đến cách giá trị của trục thay đổi theo thời gian, tạo ra cảm giác 'trơn' hoặc 'nhạy'.\n- <b>Invert:</b> Nếu được bật, các phím dương sẽ gửi giá trị âm và ngược lại.\n- <b>Type:</b> Loại đầu vào (Phím, Chuyển động chuột, Trục tay cầm...).",
                    "terms": {
                        "Axis (Trục)": "Trong Input Manager, đây là một ánh xạ (mapping) từ một hoặc nhiều nút bấm vật lý đến một giá trị số (thường từ -1 đến 1). Ví dụ, trục 'Horizontal' có thể được điều khiển bởi cả phím A/D và mũi tên trái/phải.",
                        "Dead (Dead zone)": "Một khoảng giá trị nhỏ gần 0 mà các tín hiệu từ tay cầm analog sẽ bị bỏ qua. Điều này giúp tránh các chuyển động không mong muốn khi tay cầm không hoàn toàn ở vị trí trung tâm."
                    }
                },
                {
                    "id": 35,
                    "title": "Trang 35: Input truyền thống",
                    "image": "images/game-dev/week2/slide_35.png",
                    "notes": "Mỗi dự án Unity khi được tạo ra đều có các trục đầu vào mặc định sau:\n\n- <b>Horizontal</b> và <b>Vertical</b> được ánh xạ tới các phím w, a, s, d và các phím mũi tên.\n- <b>Fire1, Fire2, Fire3</b> được ánh xạ tới Control, Option (Alt), và Command.\n- <b>Mouse X</b> và <b>Mouse Y</b> được ánh xạ tới sự thay đổi (delta) trong chuyển động của chuột.\n\nTất cả các trục ảo này được truy cập bằng tên của chúng từ script, ví dụ:\n- `Input.GetAxis(\"Horizontal\")`: Trả về một giá trị float từ -1 đến 1.\n- `Input.GetKey(\"a\")`: Trả về một giá trị boolean `true` nếu phím 'a' đang được nhấn.",
                    "terms": {
                        "Input.GetAxis()": "Một hàm của Unity trả về giá trị của một trục ảo đã được định nghĩa trong Input Manager. Giá trị này được làm mượt và nằm trong khoảng [-1, 1].",
                        "Input.GetKey()": "Một hàm của Unity trả về `true` trong mỗi frame mà người dùng đang giữ một phím được chỉ định.",
                        "Mouse Delta": "Lượng di chuyển của chuột kể từ khung hình cuối cùng. Giá trị này không bị giới hạn trong khoảng [-1, 1]."
                    }
                },
                {
                    "id": 36,
                    "title": "Trang 36: Các nút bấm và phím",
                    "image": "images/game-dev/week2/slide_36.png",
                    "notes": "Trong Unity, họ các hàm `GetKey` và `GetButton` là những cách để nhận tín hiệu đầu vào từ các phím hoặc các nút trên tay cầm thông qua lớp `Input`.\n\n- <b>GetKey</b> tham chiếu đến các phím vật lý cụ thể có thể được nhấn (ví dụ: `KeyCode.Space`).\n- <b>GetButton</b> tham chiếu đến các 'hành động' đã được chỉ định trong Input Manager (ví dụ: \"Jump\"). Đây là cách được khuyến khích sử dụng.\n\nCả hai họ hàm này đều có ba thành viên trả về giá trị `boolean`:\n- <b>Get...Down():</b> Trả về `true` <b>chỉ trong một frame duy nhất</b> ngay khi phím/nút được nhấn xuống.\n- <b>Get...():</b> Trả về `true` trong mỗi frame mà phím/nút <b>đang được giữ</b>.\n- <b>Get...Up():</b> Trả về `true` <b>chỉ trong một frame duy nhất</b> ngay khi phím/nút được thả ra.",
                    "terms": {
                        "KeyCode": "Một Enum trong Unity chứa danh sách tất cả các phím vật lý trên bàn phím.",
                        "Input.GetButtonDown()": "Hàm trả về `true` trong frame mà người dùng nhấn nút ảo được chỉ định. Rất hữu ích cho các hành động chỉ xảy ra một lần như nhảy hoặc bắn.",
                        "Input.GetButton()": "Hàm trả về `true` trong mỗi frame mà người dùng đang giữ nút ảo được chỉ định. Hữu ích cho các hành động liên tục như di chuyển hoặc bắn liên thanh.",
                        "Input.GetButtonUp()": "Hàm trả về `true` trong frame mà người dùng thả nút ảo được chỉ định."
                    }
                },
                {
                    "id": 37,
                    "title": "Trang 37: GetAxis và GetAxisRaw",
                    "image": "images/game-dev/week2/slide_37.png",
                    "notes": "<b>`Input.GetAxis()`</b> trả về một giá trị float trong khoảng [-1, 1] và có áp dụng các hiệu ứng làm mượt (smoothing) như Gravity và Sensitivity.\n\n<b>`Input.GetAxisRaw()`</b> trả về một giá trị float chỉ có thể là -1, 0, hoặc 1, không có bất kỳ sự làm mượt nào. Nó phản ánh trực tiếp trạng thái của nút bấm.\n\nCác cài đặt cho `GetAxis()`:\n- <b>Gravity:</b> Tốc độ giá trị quay trở về 0 sau khi nút được thả ra.\n- <b>Sensitivity:</b> Tốc độ giá trị đạt đến -1 hoặc 1 sau khi nút được nhấn.\n- <b>Dead:</b> Khoảng giá trị gần 0 sẽ được coi là 0 (hữu ích cho tay cầm).\n- <b>Snap:</b> Nếu được chọn, giá trị sẽ quay về 0 ngay lập tức nếu cả hai nút dương và âm được nhấn cùng lúc.",
                    "terms": {
                        "Input.GetAxisRaw()": "Tương tự như `GetAxis`, nhưng không có bất kỳ sự làm mượt nào. Giá trị trả về sẽ ngay lập tức là -1, 0, hoặc 1. Hữu ích khi bạn muốn có sự phản hồi tức thì và chính xác."
                    }
                },
                {
                    "id": 38,
                    "title": "Trang 38: Chuột (Mouse)",
                    "image": "images/game-dev/week2/slide_38.png",
                    "notes": "Tín hiệu đầu vào từ chuột có thể được phát hiện bằng các hàm `GetAxis` (cho 'Mouse X', 'Mouse Y') và `GetButton` (cho các nút chuột).\n\nTuy nhiên, Unity cũng cho phép phát hiện các cú nhấp chuột trên một <b>Collider</b> hoặc một <b>GUI Element</b>. Nếu phần tử đó có một script được gắn vào, họ các hàm sau sẽ được gọi:\n\n- <b>OnMouseDown():</b> Được gọi khi người dùng nhấn nút chuột khi con trỏ đang ở trên Collider/GUIElement.\n- <b>OnMouseUp():</b> Được gọi khi người dùng thả nút chuột.\n- <b>OnMouseEnter() / OnMouseExit():</b> Được gọi khi con trỏ chuột đi vào / đi ra khỏi Collider/GUIElement.\n- <b>OnMouseOver():</b> Được gọi ở mỗi frame khi con trỏ chuột đang ở trên Collider/GUIElement.\n- <b>OnMouseDrag():</b> Được gọi khi người dùng đã nhấp và vẫn đang giữ chuột trên Collider/GUIElement.",
                    "terms": {
                        "OnMouseDown()": "Một hàm sự kiện của MonoBehaviour được Unity tự động gọi trên tất cả các script của một Game Object khi người dùng nhấn nút chuột trong khi con trỏ đang ở trên Collider của đối tượng đó."
                    }
                },
                {
                    "id": 39,
                    "title": "Trang 39: Chuyển tiếp - Câu hỏi & Demo Lab",
                    "image": "images/game-dev/week2/slide_39.png",
                    "notes": "Kết thúc phần lý thuyết về Quản lý Tương tác người dùng.\n\nPhần cuối cùng sẽ là các câu hỏi kiểm tra và xem trước nội dung buổi thực hành (Lab).",
                    "terms": {}
                },
                {
                    "id": 40,
                    "title": "Trang 40: Xem trước buổi thực hành",
                    "image": "images/game-dev/week2/slide_40.png",
                    "notes": "Trong buổi thực hành này, bạn sẽ hoàn thành phần thứ hai của bài lab. Hãy nhớ rằng bạn sẽ được đánh giá và sẽ tiếp tục từ nơi bạn đã dừng lại ở tuần trước.\n\nBài giảng tiếp theo: <b>3D Games: Models and Physics</b>.",
                    "terms": {}
                }
            ]
        },
        {
            "title": "Tuần 3: 3D Games: Models and Physics",
            "slides": [
                {
                    "id": 1,
                    "title": "Trang 1: Bìa - 3D Games: Models and Physics",
                    "image": "images/game-dev/week3/slide_1.png",
                    "notes": "Bài giảng 3: Game 3D: Các mô hình và Vật lý.\n\nTuần này sẽ giới thiệu về cách làm việc với các đối tượng 3D và hệ thống vật lý trong Unity.",
                    "terms": {}
                },
                {
                    "id": 2,
                    "title": "Trang 2: Đề cương bài giảng",
                    "image": "images/game-dev/week3/slide_2.png",
                    "notes": "Nội dung chính của bài giảng Tuần 3 bao gồm 3 phần:\n\n1. <b>Các mô hình 3D (3D Models).</b>\n2. <b>Vật lý 3D (3D Physics).</b>\n3. <b>Câu hỏi ôn tập và Xem trước buổi thực hành.</b>",
                    "terms": {}
                },
                {
                    "id": 3,
                    "title": "Trang 3: Chuyển tiếp - Các mô hình 3D",
                    "image": "images/game-dev/week3/slide_3.png",
                    "notes": "Chuẩn bị vào phần đầu tiên: Các mô hình 3D.",
                    "terms": {}
                },
                {
                    "id": 4,
                    "title": "Trang 4: Chế độ 3D",
                    "image": "images/game-dev/week3/slide_4.png",
                    "notes": "Trong Unity 5.4, khi bạn bắt đầu một dự án mới, bạn có thể chọn làm game 2D hoặc 3D. Lựa chọn này sẽ thiết lập trình soạn thảo ở chế độ 2D hoặc 3D tương ứng.\n\nTheo mặc định, cửa sổ <b>Scene View</b> sẽ được đặt ở chế độ xem 3D, mặc dù bạn có thể chuyển đổi sang chế độ xem 2D bất kỳ lúc nào.",
                    "terms": {
                        "Scene View": "Cửa sổ chính trong Unity Editor nơi bạn có thể xem và tương tác với thế giới game của mình một cách trực quan. Bạn có thể di chuyển, xoay, và sắp xếp các Game Object trong cửa sổ này."
                    }
                },
                {
                    "id": 5,
                    "title": "Trang 5: Các đối tượng Game 3D (Primitive Meshes)",
                    "image": "images/game-dev/week3/slide_5.png",
                    "notes": "Unity có một số lưới (meshes) nguyên thủy được định nghĩa sẵn, rất hữu ích cho việc dựng mẫu (prototyping) hoặc làm các đối tượng giữ chỗ (placeholders):\n\n- <b>Cube:</b> Hình lập phương.\n- <b>Sphere:</b> Hình cầu.\n- <b>Capsule:</b> Hình con nhộng (thường dùng cho nhân vật).\n- <b>Cylinder:</b> Hình trụ.\n- <b>Plane:</b> Một mặt phẳng lớn, vô hạn về mặt hình ảnh.\n- <b>Quad:</b> Một mặt phẳng hình vuông, có kích thước 1x1.",
                    "terms": {
                        "Mesh": "Thành phần chính của một mô hình 3D, bao gồm một tập hợp các đỉnh (vertices), cạnh (edges), và mặt (faces) định nghĩa nên hình dạng của vật thể.",
                        "Primitive Mesh": "Các hình dạng hình học 3D cơ bản được cung cấp sẵn bởi một game engine. Chúng là những khối xây dựng đơn giản nhất để tạo ra các đối tượng trong game."
                    }
                },
                {
                    "id": 6,
                    "title": "Trang 6: 3D Transforms",
                    "image": "images/game-dev/week3/slide_6.png",
                    "notes": "Tất cả các đối tượng game 3D đều có một component <b>Transform</b>, quyết định 3 thuộc tính cơ bản: Vị trí (Position), Góc xoay (Rotation), và Tỷ lệ (Scale).\n\nCác thuộc tính này có thể được thiết lập trực tiếp trong Inspector hoặc được điều khiển trong cửa sổ Scene View bằng cách sử dụng các công cụ điều khiển (control gizmos) tương ứng cho Tịnh tiến, Xoay, và Tỷ lệ.",
                    "terms": {
                        "Gizmo": "Các biểu tượng đồ họa được hiển thị trong Scene View để giúp bạn tương tác và điều khiển các đối tượng. Ví dụ, gizmo di chuyển có 3 mũi tên màu đỏ, xanh lá, và xanh dương tương ứng với các trục X, Y, Z."
                    }
                },
                {
                    "id": 7,
                    "title": "Trang 7: Vertices, Triangles, Meshes",
                    "image": "images/game-dev/week3/slide_7.png",
                    "notes": "Một <b>mesh</b> (lưới) là một tập hợp các điểm 3D (gọi là <b>vertices</b> - đỉnh), khi được kết hợp lại với nhau, sẽ định nghĩa nên sự hiện diện vật lý của một đối tượng.\n\nMọi mesh đều được tạo thành từ một chuỗi các <b>triangles</b> (tam giác), được xác định bởi các đỉnh của nó.\n\nTam giác được sử dụng vì:\n- 3 điểm xác định một tam giác duy nhất với các cạnh không cắt nhau.\n- 3 điểm xác định một tam giác trong một mặt phẳng duy nhất (hình dạng phẳng).",
                    "terms": {
                        "Vertices (Đỉnh)": "Các điểm trong không gian 3D, là thành phần cơ bản nhất của một mesh. Mỗi đỉnh chứa thông tin về vị trí và có thể chứa các thông tin khác như màu sắc, tọa độ UV, và vector pháp tuyến.",
                        "Triangles (Tam giác)": "Các mặt phẳng được tạo ra bằng cách nối 3 đỉnh lại với nhau. Đây là đơn vị cơ bản để xây dựng bề mặt của tất cả các mô hình 3D trong đồ họa máy tính thời gian thực."
                    }
                },
                {
                    "id": 8,
                    "title": "Trang 8: Mesh Filter và Mesh Renderer",
                    "image": "images/game-dev/week3/slide_8.png",
                    "notes": "Để một Game Object có thể hiển thị một mesh, nó cần hai component chính:\n\n- <b>Mesh Filter:</b> Component này lấy một mesh từ các asset của bạn và chuyển nó cho Mesh Renderer để render lên màn hình.\n- <b>Mesh Renderer:</b> Component này lấy thông tin hình học (geometry) của đối tượng từ Mesh Filter và render nó tại vị trí được xác định bởi component Transform. Nó cũng xử lý việc đổ bóng, nhận bóng, và áp dụng các vật liệu (materials).",
                    "terms": {
                        "Mesh Filter": "Một component chứa dữ liệu mesh của một đối tượng. Nó không tự render bất cứ thứ gì, mà chỉ giữ thông tin về hình dạng và cung cấp nó cho Mesh Renderer.",
                        "Mesh Renderer": "Một component chịu trách nhiệm vẽ (render) mesh được cung cấp bởi Mesh Filter lên màn hình. Nó xử lý cách đối tượng tương tác với ánh sáng và cách nó được tô màu thông qua các Materials."
                    }
                },
                {
                    "id": 9,
                    "title": "Trang 9: Models (1/2) - Giới thiệu",
                    "image": "images/game-dev/week3/slide_9.png",
                    "notes": "Một <b>model</b> (mô hình) là một mesh đã được áp dụng các vật liệu (material), texture, và shader.\n\n<b>Các định dạng được hỗ trợ:</b>\nViệc nhập (import) các mesh vào Unity có thể được thực hiện từ hai loại tệp chính:\n- Các định dạng tệp 3D đã xuất (Exported), chẳng hạn như <b>.FBX</b> hoặc <b>.OBJ</b>.\n- Các định dạng tệp ứng dụng 3D độc quyền, chẳng hạn như <b>.Max</b> (3D Studio Max) và <b>.Blend</b> (Blender).\n\nUnity có thể đọc được các định dạng .FBX, .dae (Collada), .3DS, .dxf và .obj.",
                    "terms": {
                        "Model (Mô hình)": "Trong ngữ cảnh game, đây là một asset đại diện cho một đối tượng 3D hoàn chỉnh, bao gồm hình dạng (mesh), bề mặt (material, texture), và đôi khi cả các animation.",
                        ".FBX": "Một định dạng tệp 3D phổ biến được phát triển bởi Autodesk, được sử dụng rộng rãi trong ngành công nghiệp game để trao đổi các mô hình 3D, animation, và các dữ liệu scene khác giữa các ứng dụng.",
                        ".OBJ": "Một định dạng tệp hình học 3D đơn giản, chỉ lưu trữ thông tin về hình dạng (đỉnh, mặt, UVs, pháp tuyến) của một mô hình."
                    }
                },
                {
                    "id": 10,
                    "title": "Trang 10: Models (2/2) - Cấu trúc",
                    "image": "images/game-dev/week3/slide_10.png",
                    "notes": "Một mô hình được áp dụng một <b>Model Material</b>.\n\n- Một <b>material</b> (vật liệu) có thể được xem như là 'lớp da' của mesh.\n- Mọi mesh cần một material để có thể được nhìn thấy trên màn hình.\n- Model material (được lưu trong một tệp) có hai phần: <b>texture</b> (họa tiết) và <b>shader</b> (trình đổ bóng).",
                    "terms": {
                        "Material": "Một asset trong Unity định nghĩa cách một bề mặt sẽ được render. Nó kết hợp một Shader và các thuộc tính (như màu sắc, texture) để tạo ra diện mạo cuối cùng của một đối tượng.",
                        "Texture": "Một tệp hình ảnh (ví dụ: .png, .jpg) được 'dán' lên bề mặt của một mô hình 3D để cung cấp chi tiết về màu sắc, hoa văn, hoặc các đặc tính bề mặt khác.",
                        "Shader": "Một chương trình nhỏ chạy trên card đồ họa (GPU), quyết định các thuộc tính của pixel cuối cùng được vẽ lên màn hình. Nó tính toán màu sắc dựa trên ánh sáng, texture, và các thuộc tính khác của material."
                    }
                },
                {
                    "id": 11,
                    "title": "Trang 11: Materials",
                    "image": "images/game-dev/week3/slide_11.png",
                    "notes": "Unity cung cấp một material mặc định cho mỗi mesh (một material màu xám, trơn đơn giản).\n\nMột trong những tham số cơ bản của nó là <b>texture</b>. Một texture chỉ đơn giản là một tệp hình ảnh.\n\nChúng ta có thể tạo một material mới trong Unity và gán texture cho nó. Sau đó, có thể áp dụng material mới này cho đối tượng để thay đổi diện mạo của nó.",
                    "terms": {
                        "Material": "Một asset trong Unity định nghĩa cách một bề mặt sẽ được render. Nó kết hợp một Shader và các thuộc tính (như màu sắc, texture) để tạo ra diện mạo cuối cùng của một đối tượng.",
                        "Texture": "Một tệp hình ảnh (ví dụ: .png, .jpg) được 'dán' lên bề mặt của một mô hình 3D để cung cấp chi tiết về màu sắc, hoa văn, hoặc các đặc tính bề mặt khác."
                    }
                },
                {
                    "id": 12,
                    "title": "Trang 12: Shaders",
                    "image": "images/game-dev/week3/slide_12.png",
                    "notes": "Shader trong Unity được sử dụng thông qua Materials. Mã shader sẽ cho material biết nó cần những thuộc tính nào (màu sắc, textures, độ trong suốt, v.v.).\n\nShader mặc định là <b>Standard Shader</b>, được sử dụng trong material mặc định. Đây là một shader rất linh hoạt có thể được cấu hình theo nhiều cách.\n\nCó ba mục chính trong shader material:\n1. <b>Rendering Mode (Chế độ render):</b>\n   - <b>Opaque:</b> Mặc định, vật thể đặc, không trong suốt.\n   - <b>Cutout:</b> Dùng kênh alpha của texture để 'cắt bỏ' các phần của vật thể.\n   - <b>Fade / Transparent:</b> Làm cho vật thể trong suốt.",
                    "terms": {
                        "Shader": "Một chương trình nhỏ chạy trên card đồ họa (GPU), quyết định các thuộc tính của pixel cuối cùng được vẽ lên màn hình. Nó tính toán màu sắc dựa trên ánh sáng, texture, và các thuộc tính khác của material.",
                        "Standard Shader": "Shader mặc định, đa năng của Unity. Nó có thể tạo ra nhiều loại bề mặt khác nhau (kim loại, nhựa, kính...) chỉ bằng cách điều chỉnh các thông số của nó.",
                        "Alpha Channel": "Một kênh thông tin bổ sung trong một hình ảnh, quy định độ trong suốt của mỗi pixel."
                    }
                },
                {
                    "id": 13,
                    "title": "Trang 13: The Standard Shader",
                    "image": "images/game-dev/week3/slide_13.png",
                    "notes": "Tiếp tục với các mục trong Standard Shader:\n\n2. <b>Main Maps (Các texture chính):</b> Các thuộc tính được định nghĩa bởi các texture map.\n   - <b>Albedo:</b> Màu cơ bản của bề mặt, là sự kết hợp của một texture và một màu sắc.\n   - <b>Metallic:</b> Xác định độ 'kim loại' của bề mặt.\n   - <b>Smoothness:</b> Xác định độ mịn/nhám của bề mặt, ảnh hưởng đến sự phản chiếu.\n   - <b>Normal Map:</b> Tạo ra ảo giác về các chi tiết lồi lõm trên bề mặt.\n   - <b>Height Map:</b> Xác định chiều cao biểu kiến của bề mặt.\n   - <b>Occlusion:</b> Cách bề mặt phản ứng với ánh sáng môi trường.\n   - <b>Emission:</b> Làm cho bề mặt tự phát sáng.\n\n3. <b>Secondary maps:</b> Để định nghĩa các chi tiết bề mặt bổ sung.\n\nStandard Shader còn có một biến thể (Standard, Specular Setup) sử dụng <b>Specular</b> thay vì Metallic.",
                    "terms": {
                        "Albedo": "Màu sắc cơ bản của một bề mặt, không bị ảnh hưởng bởi ánh sáng. Nó giống như màu sắc bạn thấy của một vật thể trong một căn phòng được chiếu sáng đều.",
                        "Normal Map": "Một loại texture đặc biệt dùng để thêm chi tiết bề mặt mà không cần tăng số lượng đa giác của mô hình. Nó mô phỏng các vết lồi lõm nhỏ bằng cách thay đổi cách ánh sáng phản xạ trên bề mặt.",
                        "Specular": "Đề cập đến sự phản chiếu ánh sáng một cách sắc nét, giống như gương. Trái ngược với 'Diffuse' là sự phản xạ khuếch tán, mờ."
                    }
                },
                {
                    "id": 14,
                    "title": "Trang 14: Shaders (Ví dụ)",
                    "image": "images/game-dev/week3/slide_14.png",
                    "notes": "Slide này minh họa ảnh hưởng của các map khác nhau trong Standard Shader lên một hình cầu đơn giản:\n\n- <b>Hình trên bên trái:</b> Chỉ có Albedo (màu gạch).\n- <b>Hình trên bên phải:</b> Albedo + Metallic/Smoothness (bề mặt trông bóng hơn).\n- <b>Hình dưới bên trái:</b> Thêm Occlusion (các khe gạch tối hơn).\n- <b>Hình dưới bên phải:</b> Thêm Normal/Height Map (bề mặt trông lồi lõm, có chiều sâu thực sự).",
                    "terms": {}
                },
                {
                    "id": 15,
                    "title": "Trang 15: Bức tranh toàn cảnh",
                    "image": "images/game-dev/week3/slide_15.png",
                    "notes": "Sơ đồ này tóm tắt mối quan hệ giữa các thành phần rendering:\n\n1. <b>3D Model (Mesh):</b> Chứa dữ liệu hình học cơ bản như vị trí đỉnh, màu đỉnh, pháp tuyến, và dữ liệu UV (để áp texture).\n2. <b>Material:</b> Sử dụng dữ liệu từ Model. Nó chứa các Texture và các giá trị thuộc tính của Shader (ví dụ: màu Albedo, độ mịn...).\n3. <b>Shader:</b> Được sử dụng bởi Material. Nó chứa mã nguồn (viết bằng Cg/HLSL) để thực hiện các phép tính và cuối cùng quyết định màu sắc của từng pixel trên màn hình.",
                    "terms": {
                        "UV data (Texture Mapping)": "Tọa độ 2D được gán cho mỗi đỉnh của một mesh 3D, cho biết phần nào của một texture 2D sẽ được 'dán' lên vị trí đó của mô hình.",
                        "Cg / HLSL": "Các ngôn ngữ lập trình bậc cao được sử dụng để viết shader. Cg (C for Graphics) được phát triển bởi NVIDIA. HLSL (High-Level Shading Language) được phát triển bởi Microsoft cho DirectX."
                    }
                },
                {
                    "id": 16,
                    "title": "Trang 16: Chuyển tiếp - Vật lý 3D",
                    "image": "images/game-dev/week3/slide_16.png",
                    "notes": "Kết thúc phần giới thiệu về các mô hình 3D.\n\nPhần tiếp theo sẽ tập trung vào hệ thống vật lý 3D của Unity.",
                    "terms": {}
                },
                {
                    "id": 17,
                    "title": "Trang 17: Vật lý 3D",
                    "image": "images/game-dev/week3/slide_17.png",
                    "notes": "Unity có một engine vật lý riêng biệt cho tất cả các tương tác 3D trong game.\n\nCác thành phần của engine vật lý 3D trong Unity là:\n- <b>Rigidbodies:</b> Cho phép đối tượng có hành vi vật lý.\n- <b>3D Colliders:</b> Các hình dạng va chạm (Box, Capsule, Mesh, Sphere...).\n- <b>Joints (Khớp nối):</b> Dùng để kết nối các Rigidbody với nhau (Hinge, Spring, Character...).\n- <b>Forces and Torque (Lực và Mô-men xoắn).</b>\n\nChúng ta cũng sẽ xem xét về Physic 3D Materials và Raycasting trong bài giảng này.",
                    "terms": {
                        "Physics Engine": "Một phần mềm mô phỏng các định luật vật lý Newton trong môi trường ảo. Nó chịu trách nhiệm tính toán các hiệu ứng như trọng lực, va chạm, ma sát, và các lực khác."
                    }
                },
                {
                    "id": 18,
                    "title": "Trang 18: 3D Rigidbody (1/3) - Giới thiệu",
                    "image": "images/game-dev/week3/slide_18.png",
                    "notes": "<b>Rigidbody</b> là component chính cho phép một đối tượng có hành vi vật lý. Với một Rigidbody được gắn vào, đối tượng sẽ ngay lập tức phản ứng với trọng lực.\n\nKhi một component Rigidbody kiểm soát chuyển động của đối tượng, bạn <b>không nên</b> cố gắng di chuyển nó từ script bằng cách thay đổi các thuộc tính của Transform như vị trí và góc xoay. Thay vào đó, bạn nên <b>áp dụng các lực</b> để đẩy đối tượng và để engine vật lý tính toán kết quả.\n\n<b>Sleeping (Ngủ đông):</b> Khi một rigidbody di chuyển chậm hơn một tốc độ tối thiểu nhất định, engine vật lý sẽ cho rằng nó đã dừng lại và đặt nó vào chế độ 'ngủ'. Đối tượng sẽ không được cập nhật cho đến khi nhận được một va chạm hoặc một lực tác động mới. Đây là một cơ chế tối ưu hóa hiệu suất.",
                    "terms": {
                        "Rigidbody": "Một component cho phép một Game Object được điều khiển bởi hệ thống vật lý của Unity. Nó cho phép đối tượng của bạn chịu tác động của trọng lực, va chạm với các đối tượng khác, và phản ứng với các lực được áp dụng từ script.",
                        "Force": "Một tác động có thể làm thay đổi chuyển động của một vật thể. Trong Unity, bạn có thể dùng `Rigidbody.AddForce()` để đẩy một đối tượng."
                    }
                },
                {
                    "id": 19,
                    "title": "Trang 19: 3D Rigidbody (2/3) - Các tham số",
                    "image": "images/game-dev/week3/slide_19.png",
                    "notes": "Các tham số chính của component Rigidbody:\n\n- <b>Mass (Khối lượng):</b> Khối lượng của đối tượng. Bạn không nên tạo ra các khối lượng chênh lệch quá lớn (hơn 100 lần) so với các Rigidbody khác.\n- <b>Drag (Lực cản):</b> Lực cản không khí ảnh hưởng đến đối tượng khi di chuyển. 0 nghĩa là không có lực cản.\n- <b>Angular Drag:</b> Lực cản không khí ảnh hưởng đến đối tượng khi xoay.\n- <b>Use Gravity:</b> Nếu được bật, đối tượng sẽ bị ảnh hưởng bởi trọng lực.\n- <b>Is Kinematic:</b> Nếu được bật, đối tượng sẽ không bị điều khiển bởi engine vật lý, và chỉ có thể được điều khiển thông qua Transform của nó.",
                    "terms": {
                        "Mass (Khối lượng)": "Đại lượng vật lý đo lường quán tính của một vật thể. Trong Unity, khối lượng ảnh hưởng đến cách một đối tượng phản ứng với các lực và va chạm.",
                        "Drag (Lực cản)": "Một lực cản trở chuyển động của một vật thể qua một chất lỏng (như không khí). Drag càng lớn, vật thể càng nhanh chóng dừng lại.",
                        "Is Kinematic": "Một thuộc tính của Rigidbody. Khi bật, đối tượng sẽ không phản ứng với các lực vật lý nhưng vẫn có thể gây ra va chạm và kích hoạt trigger. Hữu ích cho các đối tượng chuyển động mà bạn muốn kiểm soát hoàn toàn bằng script (ví dụ: thang máy, cửa tự động)."
                    }
                },
                {
                    "id": 20,
                    "title": "Trang 20: 3D Rigidbody (3/3) - Các tham số khác",
                    "image": "images/game-dev/week3/slide_20.png",
                    "notes": "Các tham số quan trọng khác của Rigidbody:\n\n- <b>Interpolate (Nội suy):</b> Dùng để làm mượt chuyển động của Rigidbody giữa các frame vật lý.\n  - <b>Interpolate:</b> Làm mượt Transform dựa trên vị trí của các frame trước đó.\n  - <b>Extrapolate:</b> Làm mượt Transform dựa trên vận tốc hiện tại.\n- <b>Collision Detection (Phát hiện va chạm):</b>\n  - <b>Discrete:</b> Phát hiện va chạm thông thường.\n  - <b>Continuous:</b> Ngăn chặn các collider di chuyển nhanh đi xuyên qua nhau. Hữu ích cho các vật thể như viên đạn.\n- <b>Constraints (Ràng buộc):</b> Cho phép 'đóng băng' chuyển động hoặc xoay của Rigidbody trên các trục X, Y, Z một cách chọn lọc.",
                    "terms": {
                        "Interpolation (Nội suy)": "Trong vật lý game, đây là kỹ thuật dùng để làm mượt chuyển động của một đối tượng vật lý, vốn được cập nhật ở một tần suất cố định (trong FixedUpdate), để nó trông mượt mà trên màn hình, vốn được cập nhật ở một tần suất thay đổi (trong Update).",
                        "Continuous Collision Detection (CCD)": "Một chế độ phát hiện va chạm chính xác hơn, được thiết kế để ngăn chặn các vật thể di chuyển với tốc độ cao đi xuyên qua các vật thể mỏng khác. Nó tốn nhiều tài nguyên hơn so với phát hiện va chạm 'Discrete'."
                    }
                },
                {
                    "id": 21,
                    "title": "Trang 21: 3D Rigidbody trong Code",
                    "image": "images/game-dev/week3/slide_21.png",
                    "notes": "Các script nằm trong một game object có gắn rigidbody sẽ có thể truy cập đến component này thông qua lệnh gọi `GetComponent<Rigidbody>()`.\n\nCó thể di chuyển một đối tượng có rigidbody bằng cách thay đổi vị trí, vận tốc tuyến tính, vận tốc góc, v.v. của nó. Ví dụ:\n\n- `rigidbody.velocity`: Thiết lập vận tốc di chuyển thẳng của rigidbody.\n- `rigidbody.angularVelocity`: Thiết lập vận tốc xoay của rigidbody.\n- `rigidbody.position`: Thiết lập trực tiếp vị trí của rigidbody (nên dùng trong `FixedUpdate`).\n\nBạn cũng có thể truy cập các biến khác của component rigidbody, chẳng hạn như `drag`, `angularDrag`, `useGravity` hoặc `isKinematic`.",
                    "terms": {
                        "rigidbody.velocity": "Một thuộc tính Vector3 của Rigidbody, đại diện cho vận tốc của đối tượng. Thay đổi giá trị này sẽ làm cho đối tượng di chuyển ngay lập tức với vận tốc mới.",
                        "rigidbody.angularVelocity": "Một thuộc tính Vector3 của Rigidbody, đại diện cho vận tốc góc (tốc độ xoay) của đối tượng."
                    }
                },
                {
                    "id": 22,
                    "title": "Trang 22: 3D Colliders (1/3) - Giới thiệu",
                    "image": "images/game-dev/week3/slide_22.png",
                    "notes": "Các component <b>Collider</b> định nghĩa hình dạng của một đối tượng cho mục đích va chạm vật lý. Một collider là vô hình, không nhất thiết phải có hình dạng giống hệt như mesh của đối tượng, và trên thực tế, một hình dạng xấp xỉ đơn giản thường hiệu quả hơn và không thể phân biệt được trong gameplay.\n\nCó thể thêm nhiều collider vào một đối tượng duy nhất để tạo ra các <b>collider phức hợp (compound colliders)</b>.\n\n Một quy tắc chung là sử dụng <b>mesh colliders</b> cho các vật thể tĩnh trong màn chơi (như mặt đất, tường) và sử dụng các collider nguyên thủy phức hợp để xấp xỉ hình dạng của các đối tượng chuyển động.",
                    "terms": {
                        "Collider": "Một component định nghĩa một hình dạng (như hình hộp, hình cầu) cho mục đích va chạm vật lý. Collider không tự di chuyển, chúng chỉ là hình dạng.",
                        "Compound Collider": "Một cấu trúc vật lý được tạo ra bằng cách kết hợp nhiều collider nguyên thủy (primitive colliders) trên một Game Object duy nhất (có một Rigidbody). Điều này cho phép tạo ra các hình dạng va chạm phứcphức mà vẫn hiệu quả về mặt hiệu suất.",
                        "Mesh Collider": "Một loại collider lấy hình dạng của nó trực tiếp từ mesh của một mô hình 3D. Nó rất chính xác nhưng tốn nhiều tài nguyên hơn để tính toán va chạm, do đó thường chỉ nên dùng cho các vật thể tĩnh."
                    }
                },
                {
                    "id": 23,
                    "title": "Trang 23: 3D Colliders (2/3) - Static Collider",
                    "image": "images/game-dev/week3/slide_23.png",
                    "notes": "Các collider tương tác với nhau theo những cách khác nhau tùy thuộc vào cách các component Rigidbody của chúng được cấu hình. Ba cấu hình quan trọng là:\n\n<b>Static Collider (Collider tĩnh):</b>\n- Là một Game Object có một Collider nhưng <b>không có</b> Rigidbody.\n- Được sử dụng cho các hình học trong màn chơi luôn ở cùng một vị trí và không bao giờ di chuyển (ví dụ: sàn nhà, tường, tòa nhà).\n- Các đối tượng rigidbody đang lao tới sẽ va chạm với collider tĩnh nhưng sẽ không làm nó di chuyển.\n- Engine vật lý giả định rằng các collider tĩnh không bao giờ di chuyển và có thể thực hiện các tối ưu hóa hiệu suất dựa trên giả định này. Do đó, bạn <b>không nên</b> di chuyển, thay đổi tỷ lệ, hoặc bật/tắt các collider tĩnh trong khi game đang chạy.",
                    "terms": {
                        "Static Collider": "Một Game Object có component Collider nhưng không có Rigidbody. Nó được coi là một vật thể bất động trong thế giới vật lý, lý tưởng cho các yếu- tố môi trường."
                    }
                },
                {
                    "id": 24,
                    "title": "Trang 24: 3D Colliders (3/3) - Rigidbody Colliders",
                    "image": "images/game-dev/week3/slide_24.png",
                    "notes": "<b>Rigidbody Collider:</b>\n- Là một Game Object có một Collider và một Rigidbody thông thường (non-kinematic).\n- Các collider rigidbody được mô phỏng hoàn toàn bởi engine vật lý và có thể phản ứng với các va chạm và các lực được áp dụng từ script. Đây là cấu hình Collider được sử dụng phổ biến nhất trong các game có sử dụng vật lý.\n\n<b>Kinematic Rigidbody Collider:</b>\n- Là một Game Object có một Collider và một Rigidbody được đánh dấu là kinematic.\n- Bạn có thể di chuyển một đối tượng kinematic rigidbody từ script bằng cách sửa đổi component Transform của nó, nhưng nó sẽ không phản ứng với các lực như một rigidbody non-kinematic.\n- Nên sử dụng kinematic rigidbody cho các collider có thể được di chuyển hoặc bật/tắt đôi khi nhưng vẫn hoạt động như các collider tĩnh. Ví dụ: một cánh cửa trượt.",
                    "terms": {}
                },
                {
                    "id": 25,
                    "title": "Trang 25: 3D Colliders - Box Collider",
                    "image": "images/game-dev/week3/slide_25.png",
                    "notes": "<b>Box Collider</b> là một collider nguyên thủy có hình dạng khối lập phương cơ bản. Nó rất hữu ích cho bất cứ thứ gì có hình dạng gần giống hình hộp, chẳng hạn như một cái thùng hoặc một cái rương. Một box collider mỏng cũng có thể được dùng làm sàn, tường hoặc dốc.\n\nCác thuộc tính chính:\n- <b>Is Trigger:</b> Nếu được bật, Collider này được sử dụng để kích hoạt các sự kiện và bị bỏ qua bởi engine vật lý (các vật thể khác có thể đi xuyên qua nó).\n- <b>Material:</b> Tham chiếu đến một Physic Material, quyết định cách Collider này tương tác với các collider khác (ví dụ: độ nảy, ma sát).\n- <b>Center / Size:</b> Vị trí tâm và kích thước của Collider trong không gian cục bộ của đối tượng.",
                    "terms": {
                        "Is Trigger": "Một thuộc tính boolean trên một Collider. Khi được bật, collider sẽ không còn là một vật thể rắn vật lý nữa. Thay vào đó, nó sẽ hoạt động như một 'vùng cảm biến' và sẽ gọi các hàm sự kiện như `OnTriggerEnter()` khi một Rigidbody khác đi vào nó.",
                        "Physic Material": "Một asset dùng để điều chỉnh các thuộc tính ma sát và độ nảy của các collider khi chúng va chạm với nhau."
                    }
                },
                {
                    "id": 26,
                    "title": "Trang 26: 3D Colliders - Sphere Collider",
                    "image": "images/game-dev/week3/slide_26.png",
                    "notes": "<b>Sphere Collider</b> là một collider nguyên thủy có hình dạng hình cầu cơ bản. Collider này có thể được thay đổi kích thước thông qua thuộc tính Bán kính (Radius) nhưng không thể được co giãn không đồng đều theo ba trục.\n\nNgoài việc sử dụng cho các vật thể hình cầu như quả bóng tennis, hình cầu cũng hoạt động tốt cho các tảng đá rơi và các vật thể khác cần lăn và nhào lộn.",
                    "terms": {
                        "Sphere Collider": "Một component va chạm cơ bản có hình dạng hình cầu. Nó rất hiệu quả về mặt hiệu suất cho việc tính toán va chạm."
                    }
                },
                {
                    "id": 27,
                    "title": "Trang 27: 3D Colliders - Capsule Collider",
                    "image": "images/game-dev/week3/slide_27.png",
                    "notes": "<b>Capsule Collider</b> được tạo thành từ hai nửa hình cầu được nối với nhau bằng một hình trụ. Nó có hình dạng giống như primitive Capsule.\n\nĐây là loại collider rất phổ biến để sử dụng cho các nhân vật, vì hình dạng tròn ở đáy giúp nhân vật không dễ bị mắc kẹt vào các cạnh của chướng ngại vật trên mặt đất.",
                    "terms": {
                        "Capsule Collider": "Một component va chạm có hình dạng con nhộng. Đây là lựa chọn hàng đầu cho các collider của nhân vật trong cả game 2D và 3D."
                    }
                },
                {
                    "id": 28,
                    "title": "Trang 28: 3D Colliders - Mesh Collider (1/2)",
                    "image": "images/game-dev/week3/slide_28.png",
                    "notes": "<b>Mesh Collider</b> lấy một Mesh Asset và xây dựng Collider của nó dựa trên mesh đó. Nó chính xác hơn nhiều cho việc phát hiện va chạm so với các collider nguyên thủy đối với các mesh phức phức.\n\nTheo mặc định, các collider nguyên thủy không va chạm với các Mesh Collider khác. Mesh Collider tốn nhiều tài nguyên tính toán hơn các loại collider nguyên thủy, vì vậy tốt nhất là sử dụng chúng một cách tiết kiệm.",
                    "terms": {
                        "Mesh Collider": "Một loại collider lấy hình dạng của nó trực tiếp từ mesh của một mô hình 3D. Nó rất chính xác nhưng tốn nhiều tài nguyên hơn để tính toán va chạm, do đó thường chỉ nên dùng cho các vật thể tĩnh."
                    }
                },
                {
                    "id": 29,
                    "title": "Trang 29: 3D Colliders - Mesh Collider (2/2)",
                    "image": "images/game-dev/week3/slide_29.png",
                    "notes": "Các thuộc tính của Mesh Collider:\n\n- <b>Convex:</b> Đặt thành `true` nếu collider không có lỗ hổng hoặc lối vào. Nếu được bật, Mesh Collider này sẽ có thể va chạm với các Mesh Collider khác. Các Convex Mesh Collider bị giới hạn ở 255 tam giác và cần phải là convex để hoạt động với một rigidbody.\n- <b>Is Trigger:</b> Nếu được bật, collider này được sử dụng để kích hoạt các sự kiện. Chức năng trigger trong mesh collider chỉ có thể thực hiện được nếu collider được đánh dấu là convex.",
                    "terms": {
                        "Convex (Lồi)": "Một hình dạng được coi là lồi nếu một đường thẳng nối hai điểm bất kỳ bên trong hình dạng đó cũng nằm hoàn toàn bên trong hình dạng đó. Hình cầu, hình hộp là lồi; hình bánh donut (có lỗ ở giữa) là không lồi (concave). Engine vật lý xử lý va chạm giữa các vật thể lồi hiệu quả hơn nhiều."
                    }
                },
                {
                    "id": 30,
                    "title": "Trang 30: 3D Colliders - Terrain Collider",
                    "image": "images/game-dev/week3/slide_30.png",
                    "notes": "<b>Terrain Collider</b> lấy một đối tượng Địa hình (Terrain) và xây dựng Collider của nó dựa trên địa hình đó.\n\nCác thuộc tính chính:\n- <b>Is Trigger:</b> Nếu được bật, collider này được sử dụng để kích hoạt các sự kiện.\n- <b>Terrain Data:</b> Dữ liệu địa hình.\n- <b>Create Tree Colliders:</b> Khi được chọn, các collider cho cây cối trên địa hình sẽ được tạo ra.",
                    "terms": {
                        "Terrain": "Một hệ thống trong Unity cho phép bạn tạo ra các cảnh quan rộng lớn. Bạn có thể điêu khắc địa hình, vẽ texture, và thêm cây cối, cỏ.",
                        "Terrain Collider": "Một component va chạm đặc biệt lấy dữ liệu hình dạng của nó từ một asset Terrain. Nó được tối ưu hóa cao cho các địa hình lớn."
                    }
                },
                {
                    "id": 31,
                    "title": "Trang 31: 3D Colliders - Wheel Collider",
                    "image": "images/game-dev/week3/slide_31.png",
                    "notes": "<b>Wheel Collider</b> là một collider đặc biệt dành cho các phương tiện trên mặt đất. Nó có sẵn các tính năng phát hiện va chạm, vật lý bánh xe, và một mô hình ma sát lốp dựa trên độ trượt.\n\nNó có thể được sử dụng cho các vật thể khác ngoài bánh xe, nhưng nó được thiết kế đặc biệt cho các phương tiện có bánh xe.",
                    "terms": {
                        "Wheel Collider": "Một component vật lý đặc biệt trong Unity mô phỏng một bánh xe. Nó không chỉ xử lý va chạm mà còn cả hệ thống treo (suspension) và ma sát của lốp xe."
                    }
                },
                {
                    "id": 32,
                    "title": "Trang 32: Colliders as Triggers",
                    "image": "images/game-dev/week3/slide_32.png",
                    "notes": "Các collider được đặt làm <b>triggers</b> sẽ <b>không</b> tham gia vào các va chạm vật lý. Thay vào đó, chúng hoạt động như những vùng cảm biến.\n\nNếu một va chạm xảy ra với một trigger 3D collider, các thông điệp sau sẽ được gửi:\n- <b>OnTriggerEnter(Collider other):</b> Gửi khi một collider khác đi vào trigger.\n- <b>OnTriggerExit(Collider other):</b> Gửi khi một collider khác rời khỏi trigger.\n- <b>OnTriggerStay(Collider other):</b> Gửi một lần mỗi frame cho mỗi collider đang chạm vào trigger.\n\nNgược lại, một collider 3D không được thiết lập làm trigger sẽ tham gia vào các va chạm vật lý, gửi các thông điệp `OnCollisionEnter`, `OnCollisionExit`, và `OnCollisionStay`.",
                    "terms": {
                        "Trigger": "Một collider được cấu hình để phát hiện khi các đối tượng khác đi vào không gian của nó, thay vì gây ra một va chạm vật lý. Rất hữu ích để kích hoạt các sự kiện trong game (ví dụ: mở cửa, kích hoạt một đoạn cắt cảnh)."
                    }
                },
                {
                    "id": 33,
                    "title": "Trang 33: Các lực (Forces)",
                    "image": "images/game-dev/week3/slide_33.png",
                    "notes": "<b>Lực (Force)</b> là bất kỳ tương tác nào có xu hướng làm thay đổi chuyển động của một vật thể. Trong Unity, các lực được biểu diễn dưới dạng vector, và có thể là tuyến tính (được gọi đơn giản là Force) hoặc quay (được gọi là Torque).\n\nSự khác biệt lớn nhất giữa việc điều khiển Transform và Rigidbody là việc sử dụng các lực: rigidbody có thể nhận lực và mô-men xoắn, nhưng Transform thì không.\n\n<b>Quan trọng:</b> Thay đổi Transform trong khi đang sử dụng vật lý có thể gây ra các vấn đề với va chạm và các tính toán khác.\n\nTrong một script, hàm <b>FixedUpdate</b> được khuyến nghị là nơi để áp dụng các lực và thay đổi cài đặt của Rigidbody, vì các cập nhật vật lý được thực hiện theo các bước thời gian đo lường không trùng với cập nhật khung hình.",
                    "terms": {
                        "Force (Lực)": "Một tác động có thể làm thay đổi chuyển động của một vật thể. Trong Unity, bạn có thể dùng `Rigidbody.AddForce()` để đẩy một đối tượng."
                    }
                },
                {
                    "id": 34,
                    "title": "Trang 34: AddForce",
                    "image": "images/game-dev/week3/slide_34.png",
                    "notes": "Hàm `Rigidbody.AddForce()` dùng để áp dụng một lực lên Rigidbody.\n\nTham số <b>ForceMode</b> chỉ định cách lực được áp dụng:\n- <b>ForceMode.Force:</b> Áp dụng một lực liên tục có tính đến khối lượng của đối tượng. Tốt cho các lực đẩy liên tục như động cơ tên lửa.\n- <b>ForceMode.Acceleration:</b> Áp dụng một gia tốc liên tục, bỏ qua khối lượng. Chuyển động không phụ thuộc vào khối lượng.\n- <b>ForceMode.Impulse:</b> Áp dụng một lực tức thời (xung lực), có tính đến khối lượng. Tốt cho các vụ nổ hoặc va chạm.\n- <b>ForceMode.VelocityChange:</b> Áp dụng một thay đổi vận tốc tức thời, bỏ qua khối lượng.",
                    "terms": {
                        "Rigidbody.AddForce()": "Phương thức chính để áp dụng một lực lên một Rigidbody, làm cho nó di chuyển và xoay theo các quy tắc vật lý.",
                        "ForceMode": "Một Enum xác định cách một lực được áp dụng lên một Rigidbody. Các lựa chọn khác nhau cho phép mô phỏng các loại tác động khác nhau (liên tục, tức thời, có hoặc không có ảnh hưởng của khối lượng)."
                    }
                },
                {
                    "id": 35,
                    "title": "Trang 35: AddTorque",
                    "image": "images/game-dev/week3/slide_35.png",
                    "notes": "<b>Torque (Mô-men xoắn)</b> là xu hướng của một lực làm quay một vật thể quanh một trục. Hàm <b>AddTorque</b> thêm một lực mô-men xoắn vào một Rigidbody, làm cho nó bắt đầu quay quanh trục `torque`.\n\nLực được áp dụng theo quy tắc 'vít tay trái' (left hand screw rule).",
                    "terms": {
                        "Rigidbody.AddTorque()": "Phương thức chính để áp dụng một mô-men xoắn (lực xoay) lên một Rigidbody, làm cho nó bắt đầu quay.",
                        "Torque (Mô-men xoắn)": "Một lực xoắn gây ra sự thay đổi trong chuyển động quay của một vật thể. Trong Unity, bạn có thể áp dụng torque cho một Rigidbody để làm nó quay."
                    }
                },
                {
                    "id": 36,
                    "title": "Trang 36: Các lực khác để thêm",
                    "image": "images/game-dev/week3/slide_36.png",
                    "notes": "Ngoài `AddForce`, Rigidbody còn có các phương thức khác để áp dụng lực:\n\n<b>AddRelativeForce:</b>\nThêm một lực vào rigidbody tương đối với hệ tọa độ <b>cục bộ (local)</b> của nó. Ví dụ, áp dụng một lực theo `Vector3.forward` sẽ luôn đẩy đối tượng về phía trước của chính nó, bất kể nó đang xoay về hướng nào.\n\n<b>AddForceAtPosition:</b>\nÁp dụng một `force` tại một `position`. Kết quả là nó sẽ áp dụng cả một mô-men xoắn và một lực lên đối tượng. Để có hiệu ứng chân thực, vị trí nên nằm gần bề mặt của rigidbody. Thường được sử dụng nhất cho các vụ nổ.",
                    "terms": {
                        "Rigidbody.AddRelativeForce()": "Một phương thức áp dụng lực lên Rigidbody trong không gian tọa độ cục bộ của nó. Rất hữu ích cho việc điều khiển các phương tiện như tàu vũ trụ hoặc xe hơi.",
                        "Rigidbody.AddForceAtPosition()": "Một phương thức áp dụng lực tại một điểm cụ thể trên Rigidbody, gây ra cả chuyển động tịnh tiến và chuyển động quay. Lý tưởng để mô phỏng các vụ nổ hoặc các tác động lực không đồng đều."
                    }
                },
                {
                    "id": 37,
                    "title": "Trang 37: Constant Force",
                    "image": "images/game-dev/week3/slide_37.png",
                    "notes": "<b>Constant Force</b> là một component có thể được thêm vào một game object có Rigidbody.\n\nTrong khi `AddForce` chỉ áp dụng một lực trong một frame duy nhất (do đó bạn phải gọi hàm liên tục), `Constant Force` sẽ áp dụng lực ở <b>mỗi frame</b> cho đến khi bạn thay đổi giá trị lực hoặc mô-men xoắn thành một giá trị mới.\n\nComponent này cho phép bạn thiết lập các lực và mô-men xoắn liên tục trong cả không gian thế giới (world space) và không gian cục bộ (local space).",
                    "terms": {
                        "Constant Force": "Một component tiện lợi dùng để áp dụng một lực hoặc mô-men xoắn không đổi lên một Rigidbody ở mỗi bước vật lý, mà không cần viết mã trong `FixedUpdate`."
                    }
                },
                {
                    "id": 38,
                    "title": "Trang 38: Physics Materials (1/2)",
                    "image": "images/game-dev/week3/slide_38.png",
                    "notes": "<b>Physics Material</b> được sử dụng để điều chỉnh các hiệu ứng ma sát và độ nảy của các đối tượng va chạm. Chúng được gán vào component Collider của một game object.\n\n- <b>Dynamic Friction (Ma sát động):</b> Ma sát được sử dụng khi đối tượng đã đang di chuyển. Giá trị từ 0 đến 1. Giá trị 0 cảm giác như băng, giá trị 1 sẽ làm cho nó dừng lại rất nhanh.\n- <b>Static Friction (Ma sát tĩnh):</b> Ma sát được sử dụng khi một đối tượng đang nằm yên trên một bề mặt. Giá trị từ 0 đến 1. Giá trị 1 sẽ làm cho việc bắt đầu di chuyển đối tượng trở nên rất khó khăn.\n- <b>Bounciness (Độ nảy):</b> Bề mặt nảy như thế nào. Giá trị 0 sẽ không nảy, giá trị 1 sẽ nảy lên mà không mất năng lượng.",
                    "terms": {
                        "Physic Material": "Một asset dùng để điều chỉnh các thuộc tính ma sát và độ nảy của các collider khi chúng va chạm với nhau.",
                        "Friction (Ma sát)": "Lực cản lại chuyển động tương đối giữa các bề mặt tiếp xúc. Ma sát tĩnh ngăn cản vật thể bắt đầu di chuyển, trong khi ma sát động làm chậm vật thể đang di chuyển.",
                        "Bounciness (Độ nảy)": "Một thuộc tính xác định mức độ đàn hồi của một vụ va chạm. Giá trị cao hơn sẽ làm cho các vật thể nảy ra xa nhau hơn sau khi va chạm."
                    }
                },
                {
                    "id": 39,
                    "title": "Trang 39: Physics Materials (2/2)",
                    "image": "images/game-dev/week3/slide_39.png",
                    "notes": "Các thuộc tính kết hợp của Physics Material:\n\n- <b>Friction Combine:</b> Cách ma sát của hai đối tượng va chạm được kết hợp với nhau (Lấy trung bình, Lấy giá trị nhỏ nhất, Lấy giá trị lớn nhất, Nhân với nhau).\n- <b>Bounce Combine:</b> Cách độ nảy của hai đối tượng va chạm được kết hợp với nhau. Có các chế độ tương tự như Friction Combine.\n\nCác thuộc tính ma sát theo hướng cụ thể:\n- <b>Friction Direction 2:</b> Ma sát cụ thể cho một hướng cụ thể.\n- <b>Dynamic Friction 2 / Static Friction 2:</b> Ma sát động/tĩnh dọc theo `Friction Direction 2`.",
                    "terms": {}
                },
                {
                    "id": 40,
                    "title": "Trang 40: Joints (1/2) - Giới thiệu",
                    "image": "images/game-dev/week3/slide_40.png",
                    "notes": "<b>Joints (Khớp nối)</b> được sử dụng để hạn chế chuyển động của một đối tượng sao cho nó phụ thuộc vào một đối tượng khác. Sự phụ thuộc này được thực hiện bởi vật lý, thay vì phân cấp đối tượng (parenting).\n\n<b>Fixed Joint (Khớp cố định):</b>\nĐược sử dụng để làm cho hai đối tượng dính chặt vào nhau. Cả hai đối tượng phải có component Rigidbody.\n- <b>Connected Body:</b> Tham chiếu (tùy chọn) đến Rigidbody mà khớp nối phụ thuộc vào. Nếu không được đặt, khớp nối sẽ kết nối với thế giới.\n- <b>Break Force / Break Torque:</b> Lực/Mô-men xoắn cần thiết để làm gãy khớp nối này.",
                    "terms": {
                        "Joint": "Một component vật lý cho phép một Rigidbody được ràng buộc với một Rigidbody khác hoặc một điểm cố định trong không gian. Joints rất cần thiết để tạo ra các cơ chế phức trọng như cửa bản lề, dây xích, hệ thống treo xe..."
                    }
                },
                {
                    "id": 41,
                    "title": "Trang 41: Joints (2/2) - Các loại khác",
                    "image": "images/game-dev/week3/slide_41.png",
                    "notes": "Một số loại khớp nối (Joints) phổ biến khác:\n\n- <b>Spring Joint:</b> Nối hai Rigidbody với nhau, ràng buộc chúng di chuyển giống như được kết nối bằng một lò xo.\n- <b>Hinge Joint:</b> Nối hai Rigidbody với nhau, ràng buộc chúng di chuyển giống như được kết nối bằng một bản lề. Rất phù hợp cho cửa ra vào, cũng có thể được dùng để mô hình hóa dây xích, con lắc, v.v.\n- <b>Character Joint:</b> Nối hai Rigidbody với nhau, giới hạn góc xoay của chúng với nhau. Chủ yếu được sử dụng cho hiệu ứng Ragdoll.\n- <b>Configurable Joint:</b> Một khớp nối có thể tùy chỉnh hoàn toàn, cho phép hạn chế và tăng tốc chuyển động/xoay của các Rigidbody được gắn vào.",
                    "terms": {
                        "Ragdoll": "Một loại animation vật lý thủ tục, thường được sử dụng khi một nhân vật chết. Thay vì một animation được làm sẵn, cơ thể của nhân vật sẽ trở thành một tập hợp các Rigidbody được nối với nhau bằng các khớp, làm cho nó ngã xuống một cách chân thực theo các định luật vật lý."
                    }
                },
                {
                    "id": 42,
                    "title": "Trang 42: Raycasting (1/3) - Giới thiệu",
                    "image": "images/game-dev/week3/slide_42.png",
                    "notes": "Một <b>tia (ray)</b> là một đường thẳng vô hạn bắt đầu từ một điểm gốc và đi theo một hướng nào đó.\n\n Một <b>raycast</b> là một thủ tục bao gồm việc 'bắn' một tia vào tất cả hoặc một số collider nhất định trong scene. Unity cung cấp hàm static `Physics.Raycast`.\n\nCác tham số chính:\n- <b>ray:</b> Điểm bắt đầu và hướng của tia.\n- <b>distance:</b> Chiều dài của tia.\n- <b>hitInfo:</b> Nếu raycast thành công, biến này sẽ chứa thông tin về nơi va chạm.\n- <b>layerMask:</b> Dùng để chọn lọc bỏ qua các collider khi bắn tia.\n\n`Physics.Raycast` trả về `true` nếu tia giao với một collider, và `false` nếu không.",
                    "terms": {
                        "Raycasting": "Quá trình 'bắn' ra một tia ảo theo một hướng nhất định để phát hiện xem nó có va chạm với Collider nào trên đường đi hay không. Rất hữu ích cho việc xác định tầm nhìn, bắn súng, tương tác với đối tượng...",
                        "RaycastHit": "Một struct chứa thông tin chi tiết về một va chạm được trả về từ một hàm Raycast (ví dụ: điểm va chạm, khoảng cách, collider đã va chạm)."
                    }
                },
                {
                    "id": 43,
                    "title": "Trang 43: Raycasting (2/3) - RaycastHit & LayerMasks",
                    "image": "images/game-dev/week3/slide_43.png",
                    "notes": "<b>RaycastHit</b> là một struct được sử dụng để lấy thông tin trả về từ một raycast. Một số trường thông tin của nó bao gồm:\n- `collider`: Collider đã bị bắn trúng.\n- `distance`: Khoảng cách từ gốc của tia đến điểm va chạm.\n- `normal`: Vector pháp tuyến của bề mặt mà tia đã bắn trúng.\n- `point`: Điểm trong không gian thế giới nơi va chạm xảy ra.\n\n<b>LayerMasks:</b> Bằng cách định nghĩa một layer mask, bạn có thể xác định các collider trong các layer cụ thể sẽ bị ảnh hưởng bởi raycast. Raycast với một mask được cung cấp sẽ chỉ bắn trúng các collider được gán cho các layer đó.",
                    "terms": {
                        "LayerMask": "Một mặt nạ bit dùng để lọc các Game Object theo Layer của chúng. Thường được sử dụng trong Raycasting và Camera Culling để chỉ tương tác với các layer mong muốn."
                    }
                },
                {
                    "id": 44,
                    "title": "Trang 44: Raycasting (3/3) - Ví dụ",
                    "image": "images/game-dev/week3/slide_44.png",
                    "notes": "Ví dụ này minh họa cách thực hiện một raycast để bắn súng:\n\n1. <b>Chuẩn bị:</b> Khai báo một biến `RaycastHit`, `range` (tầm bắn), `LayerMask` (chỉ bắn vào những thứ có thể bắn được), và một `Ray`.\n2. <b>Thiết lập Ray:</b> Đặt gốc của tia tại vị trí của súng và hướng của tia là hướng về phía trước của súng.\n3. <b>Thực hiện Raycast:</b> Gọi `Physics.Raycast`, truyền vào ray, `hitInfo` (với từ khóa `out`), tầm bắn, và layer mask.\n4. <b>Xử lý kết quả:</b> Nếu hàm trả về `true` (bắn trúng), lấy component `EnemyHealth` từ collider đã bị bắn trúng và gây sát thương. Đồng thời, vẽ một đường `LineRenderer` đến điểm va chạm. Nếu không trúng, vẽ đường line đến hết tầm bắn.",
                    "terms": {
                        "out (keyword)": "Một từ khóa tham số cho phép một phương thức trả về nhiều hơn một giá trị. Biến được truyền vào với từ khóa 'out' không cần được khởi tạo trước, nhưng phương thức bắt buộc phải gán một giá trị cho nó.",
                        "LineRenderer": "Một component trong Unity dùng để vẽ các đường thẳng trong không gian 3D. Rất hữu ích để hiển thị các tia laser, đường đạn, hoặc các đường dẫn."
                    }
                },
                {
                    "id": 45,
                    "title": "Trang 45: Character Controller (1/2)",
                    "image": "images/game-dev/week3/slide_45.png",
                    "notes": "<b>Character Controller</b> là một component đặc biệt dành cho các đối tượng nhân vật. Trong khi Rigidbody cung cấp vật lý <b>đáng tin cậy</b>, đôi khi bạn không muốn điều đó (ví dụ: nhân vật di chuyển với tốc độ cao và nhảy những khoảng cách không tưởng).\n\n Một đối tượng với component Character Controller:\n- <b>Không</b> phản ứng với các lực (thực tế, không nên dùng nó cùng với một Rigidbody).\n- <b>Không</b> áp dụng lực cho các rigidbody khác.\n- Tự động bao gồm một <b>Capsule Collider</b>, do đó nó phản ứng với các va chạm.",
                    "terms": {
                        "Character Controller": "Một component cung cấp một cách di chuyển nhân vật đơn giản, không dựa trên vật lý thực tế. Nó cho phép bạn dễ dàng tạo ra các chuyển động giống như trong các game platformer hoặc FPS mà không cần phải xử lý các lực phức phức của Rigidbody."
                    }
                },
                {
                    "id": 46,
                    "title": "Trang 46: Character Controller (2/2)",
                    "image": "images/game-dev/week3/slide_46.png",
                    "notes": "Ở cấp độ Scripting, component Character Controller bao gồm một số hàm/biến/thông điệp hữu ích:\n\n- <b>isGrounded:</b> Cho biết controller có đang chạm đất trong frame này hay không.\n- <b>velocity:</b> Vận tốc hiện tại của controller.\n- <b>SimpleMove(Vector3)</b> và <b>Move(Vector3):</b> Dùng để di chuyển nhân vật.\n- <b>OnControllerColliderHit:</b> Được gọi khi va chạm với một collider khác, nếu game object này đang thực hiện một lệnh Move().\n\n<b>Sự khác biệt giữa `SimpleMove` và `Move`:</b>\n- <b>SimpleMove:</b> Di chuyển trên trục XZ, tự động áp dụng trọng lực. Tốc độ tính bằng <i>mét trên giây</i>.\n- <b>Move:</b> Di chuyển trên trục XYZ, <b>không</b> tự động áp dụng trọng lực. Tốc độ tính bằng <i>mét</i> (cần nhân với Time.deltaTime để di chuyển mượt mà).",
                    "terms": {
                        "CharacterController.isGrounded": "Một thuộc tính boolean trả về `true` nếu controller đang chạm vào một collider bên dưới nó. Rất hữu ích để kiểm tra xem nhân vật có thể nhảy hay không.",
                        "CharacterController.SimpleMove()": "Một hàm đơn giản để di chuyển nhân vật. Nó nhận vào vận tốc mong muốn, tự động áp dụng trọng lực và đảm bảo nhân vật trượt dọc theo các bề mặt dốc.",
                        "CharacterController.Move()": "Một hàm mạnh mẽ hơn `SimpleMove`. Nó di chuyển controller một khoảng cách nhất định nhưng không tự động áp dụng trọng lực, cho phép bạn tự lập trình các hành vi vật lý phức tạp hơn như nhảy."
                    }
                },
                {
                    "id": 47,
                    "title": "Trang 47: Các thói quen tốt nhất về Vật lý (1/2)",
                    "image": "images/game-dev/week3/slide_47.png",
                    "notes": "<b>Layers và ma trận va chạm:</b>\n- Theo mặc định, mọi thứ va chạm với mọi thứ, điều này khá kém hiệu quả. <b>Mẹo:</b> Gán các đối tượng vào các layer và vô hiệu hóa các va chạm không cần thiết trong ma trận va chạm.\n\n<b>Raycast:</b>\n- Raycasting rất mạnh mẽ nhưng là một hoạt động tốn kém. <b>Mẹo:</b>\n  - Sử dụng số lượng tia ít nhất có thể.\n  - Đặt khoảng cách giới hạn nếu có thể.\n  - Không sử dụng Raycast bên trong hàm `FixedUpdate()`.\n  - Sử dụng một collider đơn giản hơn để xấp xỉ thay vì raycast vào các mesh collider phức tạp.\n  - Chỉ định một layer mask để giới hạn số lượng va chạm mà raycast kiểm tra.",
                    "terms": {
                        "Bitwise operators (Toán tử bit)": "Các toán tử hoạt động trên các bit riêng lẻ của một số (ví dụ: `<<` dịch trái, `~` đảo bit). Chúng rất hiệu quả để làm việc với LayerMask."
                    }
                },
                {
                    "id": 48,
                    "title": "Trang 48: Các thói quen tốt nhất về Vật lý (2/2)",
                    "image": "images/game-dev/week3/slide_48.png",
                    "notes": "<b>Mẹo về Rigidbody:</b>\n\n- Các game object không có component Rigidbody được coi là <b>static colliders</b>. Việc cố gắng di chuyển các static collider là cực kỳ kém hiệu quả, vì nó buộc engine vật lý phải tính toán lại toàn bộ thế giới vật lý.\n- Việc một Rigidbody có Khối lượng (Mass) lớn hơn không làm cho nó rơi tự do nhanh hơn. Hãy sử dụng Lực cản (Drag) cho việc đó.\n- Nếu bạn đang điều khiển trực tiếp Transform của đối tượng nhưng vẫn muốn va chạm và nhận thông điệp trigger, hãy gắn một Rigidbody và đặt nó thành <b>Kinematic</b>.\n- Bạn không thể làm một đối tượng ngừng quay chỉ bằng cách đặt Angular Drag của nó thành vô cực.",
                    "terms": {}
                },
                {
                    "id": 49,
                    "title": "Trang 49: Chuyển tiếp - Câu hỏi & Demo Lab",
                    "image": "images/game-dev/week3/slide_49.png",
                    "notes": "Kết thúc phần lý thuyết về Vật lý 3D.\n\nPhần cuối cùng sẽ là các câu hỏi kiểm tra và xem trước nội dung buổi thực hành (Lab).",
                    "terms": {}
                },
                {
                    "id": 50,
                    "title": "Trang 50: Xem trước buổi thực hành",
                    "image": "images/game-dev/week3/slide_50.png",
                    "notes": "Trong buổi thực hành này và tuần tới, bạn sẽ tạo ra một game 3D.\n\n- Game sẽ là một game bắn súng không gian 3D, mặc dù nó chỉ mở rộng trong hai chiều khi nhìn từ trên xuống.\n- Bạn sẽ học cách thiết lập một dự án, tạo một scene, đặt các game object, xử lý input để di chuyển người chơi, v.v.\n\nBài giảng tiếp theo: <b>Cameras, Audio, Lights and Shadows</b>.",
                    "terms": {}
                }
            ]
        },
        {
            "title": "Tuần 4: Cameras, Audio, Lights and Shadows",
            "slides": [
                {
                    "id": 1,
                    "title": "Trang 1: Bìa - Cameras, Audio, Lights and Shadows",
                    "image": "images/game-dev/week4/slide_1.png",
                    "notes": "Bài giảng 4: Camera, Âm thanh, Ánh sáng và Bóng đổ.\n\nTuần này sẽ đi sâu vào các yếu tố thị giác và thính giác cốt lõi để tạo ra một thế giới game sống động và có chiều sâu.",
                    "terms": {}
                },
                {
                    "id": 2,
                    "title": "Trang 2: Đề cương bài giảng",
                    "image": "images/game-dev/week4/slide_2.png",
                    "notes": "Nội dung chính của bài giảng Tuần 4 bao gồm:\n\n1. <b>Cameras</b>.\n2. <b>Audio</b>.\n3. <b>Lights and Shadows</b>.\n4. <b>Câu hỏi ôn tập và Xem trước buổi thực hành</b>.",
                    "terms": {}
                },
                {
                    "id": 3,
                    "title": "Trang 3: Chuyển tiếp - Cameras",
                    "image": "images/game-dev/week4/slide_3.png",
                    "notes": "Chuẩn bị vào phần đầu tiên: Tìm hiểu về Camera, 'con mắt' của người chơi trong thế giới game.",
                    "terms": {}
                },
                {
                    "id": 4,
                    "title": "Trang 4: Giới thiệu về Camera",
                    "image": "images/game-dev/week4/slide_4.png",
                    "notes": "<b>Camera</b> là thiết bị thu nhận và hiển thị thế giới game cho người chơi. Chúng có thể được tùy chỉnh, điều khiển bằng script, hoặc làm con của các đối tượng khác. Mỗi scene trong Unity đều cần có ít nhất một camera.\n\nPhân biệt hai không gian tọa độ:\n- <b>Screen Space:</b> Không gian 2D tính bằng pixel, có gốc ở góc dưới bên trái, kích thước bằng độ phân giải màn hình của bạn.\n- <b>Viewport Space:</b> Không gian 2D đã được 'chuẩn hóa', luôn đi từ (0,0) đến (1,1), không phụ thuộc vào độ phân giải.",
                    "terms": {
                        "Camera (in Unity)": "Một component thiết yếu hoạt động như con mắt của người chơi, quyết định những gì sẽ được nhìn thấy và render lên màn hình.",
                        "Screen Space": "Một không gian tọa độ 2D được định nghĩa bằng pixel. Gốc tọa độ (0,0) thường nằm ở góc dưới bên trái của màn hình.",
                        "Viewport Space": "Một không gian tọa độ 2D đã được chuẩn hóa, không phụ thuộc vào độ phân giải. Tọa độ luôn nằm trong khoảng từ (0,0) đến (1,1)."
                    }
                },
                {
                    "id": 5,
                    "title": "Trang 5: Phép chiếu của Camera (Projection)",
                    "image": "images/game-dev/week4/slide_5.png",
                    "notes": "<b>Viewing Frustum</b> là hình dạng của khu vực không gian mà camera có thể nhìn thấy và render. Phép chiếu (projection) của camera cho phép nó mô phỏng phối cảnh.\n\n- Trong <b>Phép chiếu Phối cảnh (Perspective Projection)</b>, viewing frustum có dạng hình chóp.\n- Trong <b>Phép chiếu Trực giao (Orthographic Projection)</b>, viewing frustum có dạng hình hộp.",
                    "terms": {
                        "Viewing Frustum": "Một khối hình học 3D đại diện cho vùng không gian mà một camera có thể nhìn thấy. Bất cứ thứ gì bên trong khối này đều có thể được render.",
                        "Perspective Projection": "Phép chiếu mô phỏng cách mắt người nhìn thế giới thực, trong đó các vật thể ở xa trông nhỏ hơn. Tạo ra cảm giác về chiều sâu.",
                        "Orthographic Projection": "Phép chiếu loại bỏ phối cảnh. Các vật thể giữ nguyên kích thước của chúng bất kể khoảng cách. Thường được sử dụng trong các game 2D."
                    }
                },
                {
                    "id": 6,
                    "title": "Trang 6: Các thành phần của Camera",
                    "image": "images/game-dev/week4/slide_6.png",
                    "notes": "Một Game Object Camera thường bao gồm các component chính sau:\n\n- <b>Transform:</b> Component vị trí, xoay, và tỷ lệ của camera.\n- <b>Camera:</b> Component chính định nghĩa các thuộc tính của camera.\n- <b>GUI Layer:</b> Dùng để bật/tắt việc render các giao diện 2D (hệ thống GUI cũ).\n- <b>Flare Layer:</b> Dùng để bật/tắt hiệu ứng Lens Flare.\n- <b>Audio Listener:</b> Tính toán âm thanh đầu ra. <b>Chỉ có thể có một Audio Listener</b> trong toàn bộ scene.",
                    "terms": {
                        "Audio Listener": "Component hoạt động như 'đôi tai' của người chơi trong không gian 3D. Nó nhận tín hiệu từ các Audio Source trong scene và phát âm thanh qua loa.",
                        "Lens Flare": "Một hiệu ứng đồ họa mô phỏng hiện tượng lóe sáng xảy ra khi một nguồn sáng rất mạnh chiếu trực tiếp vào ống kính máy ảnh.",
                        "Field of View (FOV)": "(Trường nhìn) Góc nhìn của camera, xác định mức độ rộng hay hẹp của cảnh mà camera có thể bao quát.",
                        "Clipping Planes (Near/Far)": "Hai mặt phẳng ảo xác định giới hạn gần nhất và xa nhất của Viewing Frustum. Bất cứ thứ gì quá gần hoặc quá xa sẽ không được render."
                    }
                },
                {
                    "id": 7,
                    "title": "Trang 7: Các thành phần của Camera (2/4)",
                    "image": "images/game-dev/week4/slide_7.png",
                    "notes": "<b>Clear Flags</b> là một cài đặt của component Camera, quyết định những gì sẽ được vẽ ở những vùng trống trên màn hình (những vùng không có đối tượng nào được render).\n\n- <b>Skybox:</b> Các vùng trống sẽ hiển thị skybox hiện tại của camera.\n- <b>Solid Color:</b> Các vùng trống sẽ hiển thị màu nền (Background Color) của camera.\n- <b>Depth Only:</b> Không vẽ gì vào các vùng trống. Thường được dùng khi có nhiều camera xếp chồng lên nhau.\n- <b>Don't Clear:</b> Cảnh được render ở màn hình trước đó không bị xóa đi. Tạo ra hiệu ứng 'vệt' (smear).",
                    "terms": {
                        "Clear Flags": "Một thuộc tính của Camera xác định cách màn hình được xóa trước khi render. Điều này rất quan trọng khi sử dụng nhiều camera.",
                        "Skybox": "Một khối hộp lớn bao quanh toàn bộ scene, có các texture ở mặt trong để mô phỏng bầu trời và chân trời ở xa."
                    }
                },
                {
                    "id": 8,
                    "title": "Trang 8: Các thành phần của Camera (3/4)",
                    "image": "images/game-dev/week4/slide_8.png",
                    "notes": "Tiếp tục với các thuộc tính của component Camera:\n\n- <b>Background Color:</b> Màu nền sẽ được hiển thị nếu Clear Flags được đặt là 'Solid Color'.\n- <b>Culling Mask:</b> Dùng để render có chọn lọc các nhóm đối tượng dựa trên Layer của chúng. Rất hữu ích để tạo một camera riêng chỉ để render giao diện người dùng (UI).\n- <b>Projection:</b> Phép chiếu Phối cảnh (Perspective) hoặc Trực giao (Orthographic).\n- <b>Field Of View (FOV):</b> Độ rộng của góc nhìn camera, tính bằng độ dọc theo trục Y cục bộ.\n- <b>Clipping planes:</b> Các mặt phẳng Gần (Near) và Xa (Far), xác định giới hạn khoảng cách mà việc vẽ sẽ xảy ra.",
                    "terms": {
                        "Culling Mask": "Một thuộc tính trên Camera và Light cho phép bạn chọn lọc các layer mà chúng sẽ tương tác. 'Culling' có nghĩa là loại bỏ hoặc bỏ qua một cái gì đó."
                    }
                },
                {
                    "id": 9,
                    "title": "Trang 9: Các thành phần của Camera (4/4)",
                    "image": "images/game-dev/week4/slide_9.png",
                    "notes": "Các thuộc tính quan trọng khác của Camera:\n\n- <b>Viewport Rect:</b> Bốn giá trị (X, Y, W, H) từ 0 đến 1, xác định phần nào của màn hình sẽ được camera này vẽ lên. (X, Y) là vị trí bắt đầu, (W, H) là chiều rộng và chiều cao.\n- <b>Depth:</b> Vị trí của camera trong thứ tự vẽ. Camera có giá trị Depth lớn hơn sẽ được vẽ đè lên trên camera có giá trị nhỏ hơn.\n- <b>Rendering Path:</b> Các tùy chọn để xác định phương pháp render sẽ được sử dụng.\n- <b>Target Texture:</b> Tham chiếu đến một Render Texture, nơi chứa hình ảnh đầu ra của camera. Hữu ích để tạo màn hình TV trong game, camera giám sát...\n- <b>Occlusion Culling:</b> Bật/tắt tính năng loại bỏ các đối tượng bị che khuất hoàn toàn bởi các đối tượng khác.\n- <b>HDR (High Dynamic Range):</b> Bật/tắt chế độ render dải tương phản động mở rộng, cho hiệu ứng ánh sáng và màu sắc chân thực hơn.",
                    "terms": {
                        "Depth (Camera)": "Một số nguyên quyết định thứ tự render của các camera. Camera có Depth cao hơn sẽ được render sau (và do đó vẽ đè lên) camera có Depth thấp hơn.",
                        "Render Texture": "Một loại Texture đặc biệt có thể được render vào tại thời điểm chạy. Thay vì hiển thị trực tiếp lên màn hình, đầu ra của một camera có thể được chuyển hướng vào một Render Texture.",
                        "Occlusion Culling": "Một tính năng tối ưu hóa hiệu suất, ngăn chặn Unity render các đối tượng không thể nhìn thấy được từ vị trí của camera vì chúng bị các vật thể khác che khuất."
                    }
                },
                {
                    "id": 10,
                    "title": "Trang 10: Ví dụ về Camera đi theo",
                    "image": "images/game-dev/week4/slide_10.png",
                    "notes": "Đây là một kịch bản C# cơ bản để làm cho camera đi theo một đối tượng mục tiêu (target) một cách mượt mà.\n\n- <b>Start():</b> Tính toán `offset` ban đầu, là khoảng cách và hướng từ camera đến mục tiêu.\n- <b>LateUpdate():</b> Được sử dụng thay vì `Update()` để đảm bảo rằng mục tiêu đã hoàn thành tất cả các di chuyển của nó trong frame đó.\n  - Tính toán vị trí `targetCamPos` mà camera muốn hướng tới (vị trí của mục tiêu + offset).\n  - Sử dụng `Vector3.Lerp` để di chuyển vị trí hiện tại của camera về phía `targetCamPos` một cách mượt mà. Giá trị `smoothing * Time.deltaTime` quyết định tốc độ di chuyển.",
                    "terms": {}
                },
                {
                    "id": 11,
                    "title": "Trang 11: Sử dụng nhiều Camera (1/3)",
                    "image": "images/game-dev/week4/slide_11.png",
                    "notes": "Khi có nhiều camera trong scene, tham số <b>Depth</b> sẽ kiểm soát thứ tự mà các camera vẽ lên cảnh.\n\n- Nếu các giá trị Depth khác nhau, camera có giá trị Depth <b>thấp hơn</b> sẽ được vẽ <b>trước</b>.\n- Nếu các giá trị Depth bằng nhau, camera được thêm vào scene trước sẽ được vẽ trước.\n\nLưu ý rằng tất cả các camera thực chất đều vẽ lại toàn bộ cảnh, nhưng camera cuối cùng (có Depth cao nhất) sẽ vẽ đè lên tất cả những camera khác nếu Clear Flags của nó không được đặt thành 'Depth Only'.",
                    "terms": {}
                },
                {
                    "id": 12,
                    "title": "Trang 12: Sử dụng nhiều Camera (2/3)",
                    "image": "images/game-dev/week4/slide_12.png",
                    "notes": "Có thể tránh việc camera sau vẽ đè lên camera trước bằng cách thiết lập thuộc tính <b>Clear Flags</b> thành <b>Depth Only</b> ở một trong các camera (thường là camera có Depth cao hơn).\n\nKhi một camera có Clear Flags là 'Depth Only', nó sẽ chỉ vẽ những đối tượng mà nó nhìn thấy. Phần còn lại của màn hình (những vùng trống) sẽ không được vẽ, cho phép hình ảnh từ camera có Depth thấp hơn được nhìn thấy.",
                    "terms": {}
                },
                {
                    "id": 13,
                    "title": "Trang 13: Sử dụng nhiều Camera (3/3)",
                    "image": "images/game-dev/week4/slide_13.png",
                    "notes": "Hai kỹ thuật phổ biến khi sử dụng nhiều camera:\n\n1. <b>Split Screen (Chia màn hình):</b>\n   - Hai camera vẽ lên các phần khác nhau của viewport. Chúng có thể có cùng giá trị Depth vì chúng không vẽ đè lên nhau.\n   - Để chỉ định phần viewport mà mỗi camera sẽ vẽ, hãy sửa đổi thuộc tính <b>Viewport Rect</b> (X, Y, W, H) của chúng.\n\n2. <b>Culling Masks:</b>\n   - Bằng cách gán các đối tượng vào các Layer khác nhau và thiết lập thuộc tính Culling Mask của camera, có thể làm cho mỗi camera chỉ vẽ các đối tượng từ các layer cụ thể. Ví dụ: một camera chỉ vẽ UI, một camera khác vẽ phần còn lại của game.",
                    "terms": {}
                },
                {
                    "id": 14,
                    "title": "Trang 14: Chuyển tiếp - Âm thanh",
                    "image": "images/game-dev/week4/slide_14.png",
                    "notes": "Kết thúc phần giới thiệu về Camera.\n\nPhần tiếp theo sẽ tập trung vào cách Unity xử lý và phát âm thanh trong game.",
                    "terms": {}
                },
                {
                    "id": 15,
                    "title": "Trang 15: Giới thiệu về Âm thanh",
                    "image": "images/game-dev/week4/slide_15.png",
                    "notes": "Trong Unity, âm thanh được sản xuất bởi các <b>Audio Sources</b> (Nguồn âm) và được tiếp nhận bởi một <b>Audio Listener</b> (Bộ thu âm).\n\n- Chỉ có thể có <b>một Audio Listener</b> trong scene, nhưng có thể có <b>nhiều Audio Sources</b>.\n- Cách âm thanh được cảm nhận phụ thuộc vào nhiều yếu tố, bao gồm khoảng cách và vị trí của nguồn âm.\n- Unity có thể mô phỏng các hiệu ứng về khoảng cách và vị trí của nguồn âm so với bộ thu âm và phát chúng cho người dùng.\n- Unity hỗ trợ import các tệp âm thanh định dạng AIFF, WAV, MP3 và Ogg.",
                    "terms": {
                        "Audio Source": "Một component hoạt động như một chiếc loa trong không gian game. Nó lấy dữ liệu từ một Audio Clip và phát nó trong scene.",
                        "Audio Listener": "Component hoạt động như 'đôi tai' của người chơi trong không gian 3D. Nó nhận tín hiệu từ các Audio Source trong scene và phát âm thanh qua loa của máy tính."
                    }
                },
                {
                    "id": 16,
                    "title": "Trang 16: Audio Clips",
                    "image": "images/game-dev/week4/slide_16.png",
                    "notes": "<b>Audio Clips</b> chứa dữ liệu âm thanh được sử dụng bởi Audio Sources. Unity hỗ trợ các định dạng .aif, .wav, .mp3, và .ogg.\n\nCác cài đặt import quan trọng của một Audio Clip bao gồm:\n- <b>Forced to mono:</b> Ép buộc clip âm thanh được mix thành một kênh duy nhất (mono).\n- <b>Load in Background:</b> Tải âm thanh ở một luồng phụ, không làm chặn luồng chính của game (mặc định: tắt).\n- <b>Preload Audio Data:</b> Tải dữ liệu âm thanh trước khi scene bắt đầu (mặc định: bật).\n- <b>Load type:</b> Cách dữ liệu được xử lý (Giải nén khi tải, Nén trong bộ nhớ, hoặc Streaming).",
                    "terms": {
                        "Audio Clip": "Một asset chứa dữ liệu âm thanh. Nó có thể được xem như một file nhạc hoặc hiệu ứng âm thanh mà bạn kéo vào dự án.",
                        "Mono vs. Stereo": "Mono (monophonic) là âm thanh một kênh. Stereo (stereophonic) là âm thanh hai kênh (trái và phải), tạo ra cảm giác về không gian.",
                        "Streaming (Audio)": "Một kiểu tải âm thanh trong đó file âm thanh được đọc từng phần nhỏ từ ổ đĩa thay vì được tải toàn bộ vào bộ nhớ. Rất hữu ích cho các file nhạc nền dài để tiết kiệm RAM."
                    }
                },
                {
                    "id": 17,
                    "title": "Trang 17: Audio Source (1/2)",
                    "image": "images/game-dev/week4/slide_17.png",
                    "notes": "Component Audio Source phát lại một Audio Clip trong scene. Các thuộc tính chính:\n\n- <b>Audio Clip:</b> Clip âm thanh sẽ được phát.\n- <b>Output:</b> Nơi âm thanh sẽ được xuất ra, có thể là Audio Listener hoặc một Audio Mixer.\n- <b>Mute:</b> Nếu được bật, âm thanh sẽ được phát nhưng bị tắt tiếng.\n- <b>Play On Awake:</b> Nếu được bật, âm thanh sẽ tự động phát ngay khi scene được tải.\n- <b>Loop:</b> Bật tính năng này để làm cho Audio Clip lặp lại khi nó phát đến cuối.",
                    "terms": {}
                },
                {
                    "id": 18,
                    "title": "Trang 18: Audio Source (2/2)",
                    "image": "images/game-dev/week4/slide_18.png",
                    "notes": "Các thuộc tính quan trọng khác của Audio Source:\n\n- <b>Priority (Độ ưu tiên):</b> Xác định độ ưu tiên của nguồn âm này so với các nguồn âm khác (0: quan trọng nhất, 256: ít quan trọng nhất). Dùng giá trị 0 cho nhạc nền để tránh bị tắt đột ngột.\n- <b>Volume (Âm lượng):</b> Độ lớn của âm thanh ở khoảng cách 1 đơn vị thế giới (1 mét) so với Audio Listener.\n- <b>Pitch (Cao độ):</b> Mức độ thay đổi cao độ do làm chậm/tăng tốc Audio Clip. 1 là tốc độ bình thường.\n- <b>Stereo Pan:</b> Điều chỉnh vị trí của trường âm thanh nổi (stereo field) cho các âm thanh 2D.\n- <b>Spatial Blend:</b> Quyết định mức độ ảnh hưởng của engine âm thanh 3D lên nguồn âm. 0 là 2D hoàn toàn, 1 là 3D hoàn toàn.",
                    "terms": {
                        "Pitch": "Cao độ của một âm thanh, tức là mức độ 'cao' hay 'thấp' của nó. Tăng pitch sẽ làm âm thanh nghe cao và nhanh hơn, giảm pitch sẽ làm nó trầm và chậm hơn.",
                        "Spatial Blend": "Một thanh trượt trên Audio Source cho phép bạn chuyển đổi giữa âm thanh 2D (không bị ảnh hưởng bởi vị trí) và 3D (âm lượng và pan thay đổi theo khoảng cách và vị trí tương đối với Audio Listener)."
                    }
                },
                {
                    "id": 19,
                    "title": "Trang 19: Audio Source - Cài đặt âm thanh 3D (1/2)",
                    "image": "images/game-dev/week4/slide_19.png",
                    "notes": "Phần cài đặt 3D Sound Settings của một Audio Source cho phép bạn tùy chỉnh cách âm thanh hoạt động trong không gian 3 chiều.\n\nBiểu đồ hiển thị mối quan hệ giữa các thuộc tính và khoảng cách từ Audio Listener. Nó cho thấy âm lượng (Volume), độ lan tỏa (Spread), và hiệu ứng hồi âm (Reverb Zone) sẽ thay đổi như thế nào khi người nghe di chuyển ra xa nguồn âm.",
                    "terms": {}
                },
                {
                    "id": 20,
                    "title": "Trang 20: Audio Source - Cài đặt âm thanh 3D (2/2)",
                    "image": "images/game-dev/week4/slide_20.png",
                    "notes": "Các thuộc tính chính của 3D Sound Settings:\n\n- <b>Doppler Level:</b> Xác định mức độ hiệu ứng Doppler sẽ được áp dụng (0: không có hiệu ứng).\n- <b>Spread:</b> Điều chỉnh góc lan tỏa của âm thanh. Ở 0 độ, âm thanh là mono. Ở 360 độ, nó là stereo hoàn toàn.\n- <b>Volume Rolloff:</b> Cách âm thanh giảm dần theo khoảng cách đến Audio Listener. Có thể là Logarithmic (mặc định), Linear, hoặc một đường cong tùy chỉnh.\n- <b>Min Distance:</b> Trong khoảng cách này, âm thanh sẽ giữ ở mức âm lượng lớn nhất.\n- <b>Max Distance:</b> Khoảng cách mà âm thanh ngừng giảm dần. Vượt qua điểm này, âm thanh sẽ giữ ở mức âm lượng tại MaxDistance.",
                    "terms": {
                        "Doppler Effect (Hiệu ứng Doppler)": "Sự thay đổi tần số của sóng (ví dụ: âm thanh) liên quan đến một người quan sát đang di chuyển tương đối so với nguồn sóng. Ví dụ: tiếng còi xe cứu thương nghe cao hơn khi nó tiến lại gần và thấp hơn khi nó đi ra xa.",
                        "Volume Rolloff": "Sự suy giảm âm lượng của một âm thanh 3D khi khoảng cách giữa Audio Source và Audio Listener tăng lên."
                    }
                },
                {
                    "id": 21,
                    "title": "Trang 21: Audio Listener",
                    "image": "images/game-dev/week4/slide_21.png",
                    "notes": "<b>Audio Listener</b> nhận tín hiệu đầu vào từ bất kỳ Audio Source nào trong scene và phát nó. Audio Listener không có thuộc tính nào, nó chỉ đơn giản cần được thêm vào để hoạt động.\n\n- Nó luôn được thêm vào Main Camera theo mặc định và chỉ có thể có <b>một cái duy nhất</b> trong scene.\n- Khi Audio Listener được gắn vào một Game Object, bất kỳ Nguồn âm nào đủ gần nó sẽ được thu lại và phát ra loa máy tính.\n- Nếu Nguồn âm là 3D, Listener sẽ mô phỏng vị trí, vận tốc và hướng của âm thanh trong thế giới 3D.",
                    "terms": {}
                },
                {
                    "id": 22,
                    "title": "Trang 22: Reverb Zones",
                    "image": "images/game-dev/week4/slide_22.png",
                    "notes": "<b>Reverb Zones</b> (Vùng hồi âm) lấy một Audio Clip và làm méo nó tùy thuộc vào vị trí của audio listener bên trong vùng hồi âm. Chúng được sử dụng khi bạn muốn thay đổi dần dần từ một điểm không có hiệu ứng môi trường sang một nơi có hiệu ứng, ví dụ như khi bạn đang đi vào một hang động.\n\n- <b>Min Distance:</b> Bán kính của vòng tròn bên trong, xác định vùng có hiệu ứng hồi âm dần dần và vùng hồi âm đầy đủ.\n- <b>Max Distance:</b> Bán kính của vòng tròn bên ngoài, xác định vùng không có hiệu ứng và nơi hiệu ứng hồi âm bắt đầu được áp dụng dần dần.\n- <b>Reverb Preset:</b> Xác định hiệu ứng hồi âm sẽ được sử dụng bởi vùng (hang động, đấu trường, phòng tắm...).",
                    "terms": {
                        "Reverb (Hồi âm)": "Sự tồn tại của âm thanh sau khi một âm thanh được tạo ra. Reverb được tạo ra khi một âm thanh hoặc tín hiệu được phản xạ, gây ra một số lượng lớn các tiếng vang tích tụ và sau đó phân rã khi âm thanh bị hấp thụ bởi các bề mặt của các vật thể trong không gian."
                    }
                },
                {
                    "id": 23,
                    "title": "Trang 23: Scripting - Audio Source (1/2)",
                    "image": "images/game-dev/week4/slide_23.png",
                    "notes": "Các biến và hàm hữu ích khi làm việc với Audio Source từ script:\n\n- <b>bool isPlaying:</b> Trả về `true` nếu clip đang được phát.\n- <b>bool loop:</b> Bật/tắt chế độ lặp lại.\n- <b>float minDistance, maxDistance:</b> Khoảng cách nghe được của âm thanh.\n- <b>bool mute:</b> Tắt/bật tiếng của Audio Source.\n- <b>void Play():</b> Phát Audio Clip.\n- <b>void PlayDelayed(float delay):</b> Phát clip sau một khoảng trễ `delay` giây.\n- <b>void PlayOneShot(AudioClip clip, ...):</b> Phát một clip một lần. Âm thanh này sẽ không bị dừng bởi các lệnh `Stop()` khác.\n- <b>void Pause() / Stop():</b> Tạm dừng / Dừng việc phát clip.",
                    "terms": {
                        "audio.PlayOneShot()": "Một hàm rất hữu ích của Audio Source để phát các hiệu ứng âm thanh ngắn (như tiếng súng, tiếng bước chân) mà không làm gián đoạn âm thanh chính (nhạc nền) đang phát trên cùng một Audio Source."
                    }
                },
                {
                    "id": 24,
                    "title": "Trang 24: Scripting - Audio Source (2/2)",
                    "image": "images/game-dev/week4/slide_24.png",
                    "notes": "Hai ví dụ về scripting cho Audio Source:\n\n<b>Ví dụ 1:</b> Đoạn mã này sẽ Bật/Tắt âm thanh mỗi khi người dùng nhấn phím Space. Nó kiểm tra xem audio có đang phát (`isPlaying`) hay không, nếu có thì `Stop()`, nếu không thì `PlayDelayed(1f)` (phát sau 1 giây).\n\n<b>Ví dụ 2:</b> Đoạn mã này phát một hiệu ứng âm thanh súng (`shootSound`) với âm lượng ngẫu nhiên mỗi khi người dùng nhấn nút 'Fire1'. Nó lấy tham chiếu đến component Audio Source trong hàm `Awake()` và sử dụng `PlayOneShot()` để phát âm thanh.",
                    "terms": {}
                },
                {
                    "id": 25,
                    "title": "Trang 25: Chuyển tiếp - Ánh sáng và Bóng đổ",
                    "image": "images/game-dev/week4/slide_25.png",
                    "notes": "Kết thúc phần Âm thanh.\n\nPhần tiếp theo sẽ tập trung vào một yếu tố cực kỳ quan trọng để tạo ra không khí và chiều sâu cho game: Ánh sáng và Bóng đổ.",
                    "terms": {}
                },
                {
                    "id": 26,
                    "title": "Trang 26: Giới thiệu về Ánh sáng",
                    "image": "images/game-dev/week4/slide_26.png",
                    "notes": "Ánh sáng được dùng để chiếu sáng scene và các đối tượng, tạo ra không khí (mood) và phong vị (flavour) mong muốn cho game.\n\nCó bốn loại ánh sáng cơ bản trong Unity:\n- <b>Point lights (Đèn điểm):</b> Tỏa sáng từ một điểm ra mọi hướng, giống như một bóng đèn.\n- <b>Spot lights (Đèn chiếu):</b> Tỏa sáng từ một điểm theo một hướng nhất định trong một hình nón, giống như đèn pha ô tô.\n- <b>Directional lights (Đèn định hướng):</b> Được đặt ở vị trí vô cực, ảnh hưởng đến mọi thứ trong scene, giống như mặt trời.\n- <b>Area lights (Đèn vùng):</b> Tỏa sáng ra mọi hướng từ một phía của một mặt phẳng hình chữ nhật (chỉ dùng cho lightmap baking).",
                    "terms": {
                        "Light (in Unity)": "Một component tạo ra hiệu ứng ánh sáng trong scene. Các loại ánh sáng khác nhau có thể được sử dụng để mô phỏng các nguồn sáng khác nhau, từ mặt trời đến bóng đèn."
                    }
                },
                {
                    "id": 27,
                    "title": "Trang 27: Point Lights",
                    "image": "images/game-dev/week4/slide_27.png",
                    "notes": "<b>Point lights (Đèn điểm)</b> tỏa sáng ra từ một điểm duy nhất theo mọi hướng.\n\n- Chúng có chi phí trung bình đối với bộ xử lý đồ họa (GPU), mặc dù bóng đổ của đèn điểm là loại tốn kém nhất.\n- Đây là loại đèn phổ biến nhất trong game, thường được dùng cho các vụ nổ, bóng đèn, ngọn đuốc...",
                    "terms": {
                        "Point Light": "Một nguồn sáng phát ra ánh sáng đồng đều theo mọi hướng từ một điểm duy nhất trong không gian.",
                        "Cookie (Light)": "Một texture được sử dụng để che chắn hoặc thay đổi hình dạng và màu sắc của ánh sáng, tạo ra các hiệu ứng như ánh sáng chiếu qua cửa sổ hoặc tán lá cây. Với Point Light, cookie phải là một Cubemap."
                    }
                },
                {
                    "id": 28,
                    "title": "Trang 28: Spot Lights",
                    "image": "images/game-dev/week4/slide_28.png",
                    "notes": "<b>Spot lights (Đèn chiếu)</b> chỉ tỏa sáng theo một hướng duy nhất, trong một phạm vi hình nón.\n\n- Chúng là loại đèn tốn kém nhất đối với GPU.\n- Rất phù hợp để làm đèn pin, đèn pha ô tô, hoặc đèn đường chiếu xuống.\n- Có thể được dùng để tạo hiệu ứng ánh sáng chiếu qua cửa sổ.",
                    "terms": {
                        "Spot Light": "Một nguồn sáng phát ra ánh sáng từ một điểm duy nhất, giới hạn trong một hình nón. Nó được định nghĩa bởi vị trí, hướng, góc và phạm vi."
                    }
                },
                {
                    "id": 29,
                    "title": "Trang 29: Directional Lights",
                    "image": "images/game-dev/week4/slide_29.png",
                    "notes": "<b>Directional lights (Đèn định hướng)</b> được đặt ở một khoảng cách vô tận (vị trí của nó trong scene không quan trọng, chỉ có góc xoay là quan trọng) và ảnh hưởng đến tất cả các bề mặt của đối tượng trong scene của bạn.\n\n- Đèn định hướng chủ yếu được sử dụng trong các cảnh ngoài trời để mô phỏng ánh sáng mặt trời hoặc ánh trăng.\n- Đây là loại đèn ít tốn kém nhất đối với GPU.",
                    "terms": {
                        "Directional Light": "Một nguồn sáng được đặt ở vị trí vô cùng xa. Tất cả các tia sáng từ nó đều song song với nhau. Rất lý tưởng để mô phỏng ánh sáng mặt trời."
                    }
                },
                {
                    "id": 30,
                    "title": "Trang 30: Area Lights",
                    "image": "images/game-dev/week4/slide_30.png",
                    "notes": "<b>Area lights (Đèn vùng)</b> chiếu sáng lên tất cả các đối tượng trong phạm vi của nó. Ánh sáng được phát ra từ một phía của một mặt phẳng hình chữ nhật.\n\nVì việc tính toán ánh sáng này khá tốn tài nguyên xử lý, đèn vùng không khả dụng tại thời điểm chạy (runtime) và chỉ có thể được 'nung' (baked) vào các lightmap.",
                    "terms": {
                        "Area Light": "Một nguồn sáng phát ra ánh sáng từ một bề mặt hình chữ nhật. Nó tạo ra các bóng đổ mềm và chân thực hơn so với các loại đèn điểm.",
                        "Lightmap Baking": "Quá trình tính toán trước các hiệu ứng ánh sáng và bóng đổ của các vật thể tĩnh trong một scene và lưu chúng vào một texture gọi là 'lightmap'. Điều này giúp giảm đáng kể gánh nặng tính toán cho GPU tại thời điểm chạy, cải thiện hiệu suất."
                    }
                },
                {
                    "id": 31,
                    "title": "Trang 31: Ánh sáng Môi trường (1/2)",
                    "image": "images/game-dev/week4/slide_31.png",
                    "notes": "Bạn có thể truy cập cài đặt ánh sáng môi trường qua menu <b>Window → Lighting</b>.\n\n- <b>Skybox:</b> Hình ảnh xuất hiện phía sau mọi thứ khác trong scene.\n- <b>Sun (Mặt trời):</b> Chỉ định một Directional Light sẽ hoạt động như mặt trời (chỉ dành cho các skybox thủ tục).\n- <b>Reflection Source (Nguồn phản chiếu):</b> Cho phép chỉ định sử dụng skybox cho các hiệu ứng phản chiếu (mặc định) hoặc chọn một cubemap thay thế.",
                    "terms": {}
                },
                {
                    "id": 32,
                    "title": "Trang 32: Ánh sáng Môi trường (2/2)",
                    "image": "images/game-dev/week4/slide_32.png",
                    "notes": "<b>Ambient Light (Ánh sáng xung quanh)</b> là một nguồn sáng không đến từ một điểm cụ thể nào, chiếu sáng tất cả các bề mặt trên màn hình. Có ba nguồn khả dĩ:\n- <b>Color:</b> Một màu phẳng cho ánh sáng.\n- <b>Gradient:</b> Các màu chuyển sắc cho bầu trời, đường chân trời, và mặt đất.\n- <b>Skybox:</b> Các màu từ skybox.\n\nViệc chỉ dựa vào ambient light thường không phải là một ý tưởng hay vì nó quá 'phẳng'. Bạn nên kết hợp với các loại đèn khác. Tuy nhiên, nó rất hữu ích để chiếu sáng đều các đối tượng nhằm tạo ra hiệu ứng ngày hoặc đêm.",
                    "terms": {
                        "Ambient Light": "Ánh sáng nền không có hướng cụ thể, chiếu sáng đồng đều toàn bộ scene. Nó giúp làm cho các vùng tối và bóng đổ không bị đen hoàn toàn, trông tự nhiên hơn."
                    }
                },
                {
                    "id": 33,
                    "title": "Trang 33: Component Ánh sáng (1/2)",
                    "image": "images/game-dev/week4/slide_33.png",
                    "notes": "Các thuộc tính chính của component Light:\n\n- <b>Type:</b> Loại ánh sáng (Spot, Directional, Point, Area).\n- <b>Baking:</b> Chế độ xử lý ánh sáng:\n  - <b>Realtime:</b> Ánh sáng được tính toán và cập nhật ở mỗi frame. Có thể thay đổi và tạo bóng đổ động.\n  - <b>Mixed:</b> Kết hợp giữa Realtime và Baked. Dùng cho các nguồn sáng cần chiếu sáng cả đối tượng động và tĩnh.\n  - <b>Baked:</b> Ánh sáng được tính toán trước và lưu vào lightmap. Chỉ ảnh hưởng đến các đối tượng tĩnh.",
                    "terms": {
                        "Baking": "Một quá trình tính toán trước các dữ liệu phức tạp (như ánh sáng, bóng đổ) trong Editor thay vì tại thời điểm chạy. Điều này giúp cải thiện đáng kể hiệu suất của game."
                    }
                },
                {
                    "id": 34,
                    "title": "Trang 34: Component Ánh sáng (2/2)",
                    "image": "images/game-dev/week4/slide_34.png",
                    "notes": "Các thuộc tính quan trọng khác của component Light:\n\n- <b>Range:</b> Khoảng cách tối đa mà ánh sáng phát ra (chỉ cho Point/Spot light).\n- <b>Spot Angle:</b> Góc của hình nón ánh sáng, tính bằng độ (chỉ cho Spot light).\n- <b>Color / Intensity:</b> Màu sắc / Cường độ (độ sáng) của ánh sáng.\n- <b>Bounce Intensity:</b> Độ sáng của ánh sáng sau khi nảy lên (dùng cho GI).\n- <b>Shadow Type:</b> Loại bóng đổ được tạo ra bởi nguồn sáng này.\n- <b>Cookie / Cookie Size:</b> Texture mặt nạ cho ánh sáng và kích thước của nó.\n- <b>Draw Halo / Flare:</b> Vẽ một vầng hào quang / lóe sáng tại vị trí của nguồn sáng.\n- <b>Render Mode:</b> Chế độ ưu tiên (Auto, Important, Not Important).\n- <b>Culling Mask:</b> Chọn lọc các layer sẽ bị ảnh hưởng bởi nguồn sáng.",
                    "terms": {
                        "Global Illumination (GI)": "(Chiếu sáng toàn cục) Một hệ thống mô phỏng cách ánh sáng được phản xạ gián tiếp từ các bề mặt, tạo ra các hiệu ứng chiếu sáng chân thực hơn."
                    }
                },
                {
                    "id": 35,
                    "title": "Trang 35: Cookies",
                    "image": "images/game-dev/week4/slide_35.png",
                    "notes": "<b>Cookie</b> là một hình ảnh có thể được dùng làm mặt nạ (mask) để quyết định độ sáng của ánh sáng ở các phần khác nhau, dựa trên kênh alpha của nó.\n\n- Nếu là Spot light hoặc Directional light, hình ảnh này phải là một texture 2D.\n- Nếu là Point light, nó phải là một Cubemap.\n\nKhi import một texture để dùng làm cookie, bạn cần thiết lập các thông số:\n- <b>Texture Type:</b> Cookie.\n- <b>Light Type:</b> Loại ánh sáng sẽ sử dụng cookie này.\n- <b>Alpha from Grayscale:</b> Để Unity chuyển đổi ảnh thang độ xám thành một alpha map.",
                    "terms": {
                        "Cookie (Light)": "Một texture được sử dụng để che chắn hoặc thay đổi hình dạng và màu sắc của ánh sáng, tạo ra các hiệu ứng như ánh sáng chiếu qua cửa sổ hoặc tán lá cây.",
                        "Cubemap": "Một tập hợp sáu texture hình vuông được ghép lại với nhau thành các mặt của một khối lập phương ảo. Thường được dùng để thể hiện sự phản chiếu hoặc skybox."
                    }
                },
                {
                    "id": 36,
                    "title": "Trang 36: Lightmapping (1/2)",
                    "image": "images/game-dev/week4/slide_36.png",
                    "notes": "<b>Lightmap</b> là một cấu trúc dữ liệu chứa thông tin về độ sáng đã được 'nung' (baked) của các bề mặt <b>tĩnh</b> trong scene.\n\nCó ba loại lightmapping chính:\n- <b>Non-directional:</b> Trường hợp mặc định, lưu thông tin về lượng ánh sáng mà bề mặt phát ra.\n- <b>Directional:</b> Lưu thêm thông tin về hướng của ánh sáng tới.\n- <b>Directional with Specular:</b> Lưu thêm thông tin cho ánh sáng gián tiếp có tính phản chiếu (specular).",
                    "terms": {
                        "Lightmap": "Một texture được tạo ra trong quá trình 'baking', chứa thông tin ánh sáng và bóng đổ cho các vật thể tĩnh trong một scene. Sử dụng lightmap giúp giảm tải tính toán cho GPU tại thời điểm chạy."
                    }
                },
                {
                    "id": 37,
                    "title": "Trang 37: Lightmapping (2/2)",
                    "image": "images/game-dev/week4/slide_37.png",
                    "notes": "Slide này minh họa kết quả của quá trình lightmap baking.\n\nCác texture hiển thị là các lightmap đã được tạo ra cho scene. Unity sẽ tự động 'trải' các UV của các đối tượng tĩnh và lưu thông tin ánh sáng, bóng đổ lên các texture này. Khi game chạy, thay vì tính toán ánh sáng lại từ đầu, engine sẽ chỉ cần đọc thông tin từ các lightmap này và áp dụng lên các bề mặt tương ứng, giúp tiết kiệm hiệu suất một cách đáng kể.",
                    "terms": {}
                },
                {
                    "id": 38,
                    "title": "Trang 38: Bóng đổ (Shadows)",
                    "image": "images/game-dev/week4/slide_38.png",
                    "notes": "Unity sử dụng kỹ thuật <b>shadow mapping</b> để tạo bóng đổ của các đối tượng trong scene. Bóng được tạo ra bằng cách render lại scene từ góc nhìn của nguồn sáng, tạo ra một 'bản đồ bóng' (shadow map) dưới dạng một texture lưu trữ thông tin về chiều sâu (depth) của mỗi bề mặt.\n\nChất lượng của shadow map phụ thuộc vào hai yếu tố:\n- <b>Độ phân giải (resolution):</b> Shadow map càng lớn, chất lượng bóng đổ càng tốt.\n- <b>Việc lọc (filtering):</b> Bóng đổ cứng (Hard shadows) lấy pixel gần nhất. Bóng đổ mềm (Soft shadows) lấy trung bình của nhiều pixel, tạo ra các bóng đổ trông mượt mà hơn nhưng tốn kém hơn để render.",
                    "terms": {
                        "Shadow Mapping": "Một kỹ thuật phổ biến để tạo bóng đổ trong đồ họa máy tính 3D. Nó hoạt động bằng cách render scene từ góc nhìn của nguồn sáng để xác định các khu vực bị che khuất."
                    }
                },
                {
                    "id": 39,
                    "title": "Trang 39: Bóng đổ Thời gian thực (1/2)",
                    "image": "images/game-dev/week4/slide_39.png",
                    "notes": "Bóng đổ thời gian thực (real-time shadows) rất tốn kém về mặt tính toán và tài nguyên, vì vậy nên được sử dụng một cách cẩn thận.\n\n- Bóng đổ mềm tốn nhiều tài nguyên để render hơn bóng đổ cứng.\n- Chi phí tính toán hoàn toàn nằm trên card đồ họa (GPU), vì vậy bóng đổ không ảnh hưởng nhiều đến CPU hay bộ nhớ.\n\nCài đặt chất lượng (<b>Edit → Project Settings → Quality</b>) chứa một mục dành cho Bóng đổ, ảnh hưởng đến toàn bộ dự án Unity.",
                    "terms": {
                        "Real-time Shadows": "Bóng đổ được tính toán và cập nhật ở mỗi khung hình. Chúng có thể thay đổi một cách linh động khi các đối tượng và nguồn sáng di chuyển, nhưng rất tốn tài nguyên GPU."
                    }
                },
                {
                    "id": 40,
                    "title": "Trang 40: Bóng đổ Thời gian thực (2/2)",
                    "image": "images/game-dev/week4/slide_40.png",
                    "notes": "Các cài đặt chất lượng cho bóng đổ:\n\n- <b>Shadows:</b> Loại bóng đổ sẽ được sử dụng (Cứng và Mềm, Chỉ Cứng, hoặc Tắt).\n- <b>Shadow resolution:</b> Độ phân giải của shadow map (Thấp, Trung bình, Cao, Rất cao).\n- <b>Shadow Projection:</b> Phương pháp chiếu bóng cho đèn định hướng.\n  - <b>Close Fit:</b> Render bóng có độ phân giải cao hơn nhưng có thể bị 'lung lay' nhẹ khi camera di chuyển.\n  - <b>Stable Fit:</b> Render bóng có độ phân giải thấp hơn nhưng sẽ không bị lung lay.\n- <b>Shadow Distance:</b> Khoảng cách tối đa từ camera mà bóng đổ sẽ được hiển thị.\n- <b>Shadow Cascades:</b> Số lượng các 'tầng' bóng đổ (0, 2, hoặc 4). Số tầng cao hơn cho chất lượng tốt hơn nhưng tốn nhiều hiệu suất hơn.",
                    "terms": {
                        "Shadow Cascades": "Một kỹ thuật để cải thiện chất lượng của shadow map cho các cảnh lớn, đặc biệt là với đèn định hướng. Nó chia viewing frustum của camera thành nhiều phần và render một shadow map riêng với độ phân giải khác nhau cho mỗi phần."
                    }
                },
                {
                    "id": 41,
                    "title": "Trang 41: Bóng đổ Thời gian thực - Đèn định hướng",
                    "image": "images/game-dev/week4/slide_41.png",
                    "notes": "Đối với một Đèn định hướng (Directional Light), bóng đổ có ba thuộc tính sau:\n\n- <b>Strength (Độ đậm):</b> Độ tối của bóng đổ. Giá trị từ 0 đến 1.\n- <b>Resolution (Độ phân giải):</b> Mức độ chi tiết của bóng đổ. Có thể được đặt theo Cài đặt Chất lượng chung, hoặc thiết lập riêng cho đèn này ở mức Thấp, Trung bình, Cao hoặc Rất cao.\n- <b>Bias:</b> Xác định bóng đổ gần với vật thể tạo ra nó như thế nào. Giá trị gần 0 có thể gây ra 'mụn bóng' (shadow acne), nhưng giá trị quá cao có thể làm bóng đổ bị 'lơ lửng' (peter panning).\n\nBóng đổ mềm có thêm hai thuộc tính là <b>Softness</b> và <b>Softness Fade</b> để quản lý sự chuyển tiếp từ vùng sáng sang vùng tối.",
                    "terms": {
                        "Shadow Acne": "Một lỗi đồ họa xuất hiện dưới dạng các sọc hoặc đốm không đều trên bề mặt của một vật thể khi nó tự đổ bóng lên chính nó.",
                        "Peter Panning": "Một lỗi đồ họa làm cho bóng đổ trông có vẻ bị tách rời hoặc 'lơ lửng' bên dưới vật thể tạo ra nó, thay vì được kết nối một cách chính xác."
                    }
                },
                {
                    "id": 42,
                    "title": "Trang 42: Shadow Cascades",
                    "image": "images/game-dev/week4/slide_42.png",
                    "notes": "<b>Shadow Cascades</b> là một quy trình bao gồm việc chia khu vực nhìn thấy thành các vùng ngày càng lớn, sử dụng cùng một kích thước shadow map cho mỗi vùng. Kết quả là các vật thể ở gần người xem sẽ nhận được nhiều pixel của shadow map hơn các vật thể ở xa.\n\n- <b>Không có cascades (giá trị 0):</b> Shadow texture bao phủ toàn bộ khu vực nhìn thấy, dẫn đến chất lượng bóng đổ thấp ở gần.\n- <b>Với 2 cascades:</b> Khoảng cách bóng đổ được chia thành một phần nhỏ ở gần và một phần lớn ở xa. Đổi lại một chút hiệu suất, chúng ta có được độ phân giải bóng đổ tốt hơn ở gần.",
                    "terms": {}
                },
                {
                    "id": 43,
                    "title": "Trang 43: Tính năng mới trong Unity 5.4",
                    "image": "images/game-dev/week4/slide_43.png",
                    "notes": "Unity 5.4 giới thiệu các <b>Hiệu ứng Hình ảnh Điện ảnh (Cinematic Image Effects)</b>, có thể được tìm thấy trên Asset Store.\n\nCác hiệu ứng này cho phép bạn thêm vào game các tính năng đồ họa cao cấp như:\n- <b>Antialiasing (Khử răng cưa):</b> Làm mượt các cạnh bị răng cưa.\n- <b>Camera effects:</b> Các hiệu ứng camera khác nhau.\n- <b>Reflectivity and glowing effects:</b> Các hiệu ứng phản chiếu và phát sáng.\n- <b>Lens aberration and blurriness:</b> Hiệu ứng quang sai ống kính và làm mờ.",
                    "terms": {
                        "Antialiasing (Khử răng cưa)": "Một kỹ thuật đồ họa máy tính dùng để làm mịn các cạnh lởm chởm, 'răng cưa' trên các đường chéo và đường cong.",
                        "Image Effect / Post-processing": "Các hiệu ứng đồ họa được áp dụng lên toàn bộ màn hình sau khi scene đã được render xong. Chúng hoạt động giống như các bộ lọc trong Photoshop."
                    }
                },
                {
                    "id": 44,
                    "title": "Trang 44: Chuyển tiếp - Câu hỏi & Demo Lab",
                    "image": "images/game-dev/week4/slide_44.png",
                    "notes": "Kết thúc phần lý thuyết về Ánh sáng và Bóng đổ.\n\nPhần cuối cùng sẽ là các câu hỏi kiểm tra và xem trước nội dung buổi thực hành (Lab).",
                    "terms": {}
                },
                {
                    "id": 45,
                    "title": "Trang 45: Bài kiểm tra Tiến độ",
                    "image": "images/game-dev/week4/slide_45.png",
                    "notes": "Thông báo về Bài kiểm tra Tiến độ 1:\n- <b>Thời gian:</b> Thứ Ba, ngày 8 tháng 11, từ 1h đến 2h chiều.\n- <b>Địa điểm:</b> Phòng LTB03.\n\nNội dung bài kiểm tra:\n- Gồm 20 câu hỏi trắc nghiệm.\n- Bạn có 30 phút để làm bài.\n- Phải được thực hiện trong điều kiện thi cử.\n- Sẽ có nhắc nhở khi còn 5 phút.\n- Trị giá 15% tổng điểm cuối kỳ.\n\n<b>Nhắc nhở:</b> Hãy tự mang theo bút chì và tẩy!",
                    "terms": {}
                },
                {
                    "id": 46,
                    "title": "Trang 46: Xem trước UROP & Buổi thực hành",
                    "image": "images/game-dev/week4/slide_46.png",
                    "notes": "<b>Lab:</b> Bạn sẽ hoàn thành bài tập Space Shooter.\n\n<b>UROP (Chương trình Cơ hội Nghiên cứu cho sinh viên Đại học):</b>\n- Vị trí thực tập về Game Engine trên Web: Trí tuệ nhân tạo cho Game tổng quát: Chơi và Thu thập dữ liệu trên Web.",
                    "terms": {
                        "UROP (Undergraduate Research Opportunities Programme)": "Một chương trình cho phép sinh viên đại học tham gia vào các dự án nghiên cứu thực tế cùng với các giảng viên và nhà nghiên cứu."
                    }
                }
            ]
        },
        {
            "title": "Tuần 5: Terrains",
            "slides": [
                {
                    "id": 1,
                    "title": "Trang 1: Bìa - Terrains",
                    "image": "images/game-dev/week5/slide_1.png",
                    "notes": "Bài giảng 5: Địa hình (Terrains).\n\nTuần này chúng ta sẽ học về cách tạo và chỉnh sửa các cảnh quan rộng lớn trong Unity bằng hệ thống Terrain.",
                    "terms": {}
                },
                {
                    "id": 2,
                    "title": "Trang 2: Đề cương bài giảng",
                    "image": "images/game-dev/week5/slide_2.png",
                    "notes": "Nội dung chính của bài giảng Tuần 5 bao gồm:\n\n1. <b>Terrains (Địa hình).</b>\n2. <b>Lab Session 5 (Buổi thực hành 5).</b>",
                    "terms": {}
                },
                {
                    "id": 3,
                    "title": "Trang 3: Chuyển tiếp - Terrains",
                    "image": "images/game-dev/week5/slide_3.png",
                    "notes": "Chuẩn bị vào phần đầu tiên: Tìm hiểu về hệ thống tạo địa hình của Unity.",
                    "terms": {}
                },
                {
                    "id": 4,
                    "title": "Trang 4: Giới thiệu về Terrains",
                    "image": "images/game-dev/week5/slide_4.png",
                    "notes": "Hầu hết các video game đều sử dụng địa hình (terrains). Địa hình có thể là một khu vực có thể được khám phá chủ động (ví dụ: game bắn súng góc nhìn thứ nhất) hoặc là một phần của hậu cảnh để tạo ra ảo giác về một thế giới mở (ví dụ: game đua xe).\n\nĐịa hình có thể được tạo ra tự động trong lúc chơi để tạo ra các thế giới thực sự mở. Ngoài ra, một công dụng phổ biến khác của các dãy núi là để giới hạn thế giới mà người chơi có thể tiếp cận.",
                    "terms": {
                        "Terrain": "Một hệ thống trong Unity cho phép bạn tạo ra các cảnh quan rộng lớn. Bạn có thể điêu khắc địa hình, vẽ texture, và thêm cây cối, cỏ."
                    }
                },
                {
                    "id": 5,
                    "title": "Trang 5: Tạo địa hình (Terrain generation)",
                    "image": "images/game-dev/week5/slide_5.png",
                    "notes": "Một cách phổ biến để tạo địa hình là xây dựng một mesh (sử dụng các tam giác) từ một <b>heightmap</b> (bản đồ độ cao) và áp dụng một texture lên mesh đó.\n\nMột heightmap là một hình ảnh 2D ở thang độ xám:\n- Mỗi pixel tương ứng với một đỉnh (vertex).\n- Giá trị màu sắc của pixel quyết định chiều cao của nó (trắng là cao nhất, đen là thấp nhất).\n\nHeightmap có thể được tạo ra bằng các công cụ đặc biệt hoặc đơn giản bằng một trình chỉnh sửa ảnh như Photoshop hay Paint.NET.",
                    "terms": {
                        "Heightmap": "Một hình ảnh 2D thang độ xám được sử dụng để lưu trữ thông tin về độ cao của một bề mặt. Các giá trị sáng hơn đại diện cho các khu vực cao hơn, và các giá trị tối hơn đại diện cho các khu vực thấp hơn."
                    }
                },
                {
                    "id": 6,
                    "title": "Trang 6: Tạo và Chỉnh sửa Terrains",
                    "image": "images/game-dev/week5/slide_6.png",
                    "notes": "Trong Unity, địa hình có thể được thêm vào như các đối tượng game từ menu <b>Create → 3D Object → Terrain</b>.\n\nThao tác này sẽ tạo ra một mặt phẳng lớn, hoàn toàn phẳng, và bề mặt có thể được chỉnh sửa bằng các Công cụ Độ cao (Height Tools) có sẵn trong component Terrain (Script).\n\nTừ trái sang phải, các công cụ này là:\n- <b>Raise/Lower Terrain:</b> Nâng/Hạ địa hình.\n- <b>Paint Height:</b> Tô độ cao.\n- <b>Smooth Height:</b> Làm mịn độ cao.\n- <b>Paint Texture:</b> Tô họa tiết.\n- <b>Place Trees:</b> Đặt cây.\n- <b>Paint Details:</b> Tô chi tiết (cỏ, đá nhỏ).\n- <b>Terrain Settings:</b> Cài đặt địa hình.",
                    "terms": {}
                },
                {
                    "id": 7,
                    "title": "Trang 7: Công cụ Độ cao (Height Tools)",
                    "image": "images/game-dev/week5/slide_7.png",
                    "notes": "Các công cụ Độ cao (ba công cụ đầu tiên) được dùng để 'tô' các thay đổi về độ cao lên địa hình, tương tự như hiệu ứng của các công cụ airbrush trong các trình chỉnh sửa ảnh.\n\n- <b>Raise/Lower Terrain:</b> Nâng địa hình. Nếu giữ phím `Shift`, nó sẽ hạ địa hình.\n- <b>Paint Height:</b> Công cụ này tô địa hình đến một giá trị `Height` (độ cao mục tiêu) cụ thể. Các điểm cao hơn sẽ bị hạ xuống và các điểm thấp hơn sẽ được nâng lên. Giữ phím `Shift` cho phép lấy mẫu độ cao tại một điểm.\n- <b>Smooth Height:</b> Làm mịn các khu vực lân cận, làm mềm cảnh quan và giảm sự xuất hiện của các thay đổi đột ngột.",
                    "terms": {}
                },
                {
                    "id": 8,
                    "title": "Trang 8: Textures (1/2)",
                    "image": "images/game-dev/week5/slide_8.png",
                    "notes": "Các texture có thể được thêm vào bề mặt của một địa hình.\n\n- Vì địa hình là những đối tượng rất lớn, thông thường người ta sẽ sử dụng một texture có thể lặp lại (tileable) và lát nó trên bề mặt.\n- Một texture sẽ đóng vai trò là hình ảnh nền trên toàn bộ cảnh quan, nhưng bạn cũng có thể 'tô' các vùng có texture khác nhau để mô phỏng các bề mặt đất khác nhau như cỏ, sa mạc và tuyết.\n- Các texture được tô có thể được áp dụng với độ trong suốt thay đổi để bạn có thể tạo ra sự chuyển tiếp dần dần giữa một vùng quê đầy cỏ và một bãi biển đầy cát.",
                    "terms": {
                        "Tileable Texture": "Một hình ảnh đã được thiết kế sao cho khi được xếp cạnh nhau, các đường nối giữa chúng không thể nhìn thấy được, tạo ra một bề mặt liền mạch."
                    }
                },
                {
                    "id": 9,
                    "title": "Trang 9: Textures (2/2)",
                    "image": "images/game-dev/week5/slide_9.png",
                    "notes": "Texture đầu tiên được thêm vào sẽ làm nền, tô toàn bộ địa hình. Các texture còn lại sẽ có sẵn để tô bằng các công cụ cọ vẽ.\n\nCác thuộc tính có sẵn là <b>Brush Size</b> (Kích thước cọ) và <b>Opacity</b> (Độ mờ), hoạt động tương tự như các công cụ khác. Có một cài đặt thứ ba gọi là <b>Target Strength</b> (Cường độ mục tiêu). Cài đặt này thiết lập giá trị độ mờ tối đa mà cọ vẽ sẽ đạt được ngay cả khi nó đi qua cùng một điểm nhiều lần. Điều này rất hữu ích để tạo ra các mảng vá trong một địa hình duy nhất để phá vỡ sự đơn điệu của một khu vực đồng nhất lớn.",
                    "terms": {}
                },
                {
                    "id": 10,
                    "title": "Trang 10: Cây cối (1/3)",
                    "image": "images/game-dev/week5/slide_10.png",
                    "notes": "Địa hình Unity có thể được trang trí bằng cây cối. Các mảng cây có thể được tô lên địa hình giống như cách tô heightmap và texture, nhưng cây cối là các đối tượng 3D rắn mọc lên từ bề mặt.\n\nUnity sử dụng các tối ưu hóa (ví dụ: <b>billboarding</b> cho cây ở xa) để duy trì hiệu suất render tốt, vì vậy bạn có thể có những khu rừng rậm rạp với hàng ngàn cây mà vẫn giữ được tốc độ khung hình chấp nhận được.\n\nBan đầu, sẽ không có cây nào có sẵn. Nhấp vào nút <b>Edit Trees</b> cho phép bạn thêm cây vào địa hình.",
                    "terms": {
                        "Billboarding": "Một kỹ thuật đồ họa trong đó các sprite (hình ảnh 2D) luôn được xoay để đối mặt với camera. Trong Unity Terrain, các cây ở xa được thay thế bằng billboard để giảm đáng kể chi phí render."
                    }
                },
                {
                    "id": 11,
                    "title": "Trang 11: Cây cối (2/3)",
                    "image": "images/game-dev/week5/slide_11.png",
                    "notes": "Các thuộc tính <b>Brush Size</b> (Kích thước cọ) và <b>Tree Density</b> (Mật độ cây) được dùng để tô cây. <b>Color Variation</b> (Biến thể màu sắc) thêm một chút nhiễu vào màu sắc của các cây được trồng.\n\nChiều cao và chiều rộng của cây cũng có thể được xác định, cũng như yếu tố nhiễu.\n\nNút <b>Mass Place Trees</b> là một cách rất hữu ích để tạo ra một lớp phủ cây tổng thể mà không cần tô vẽ trên toàn bộ cảnh quan.",
                    "terms": {}
                },
                {
                    "id": 12,
                    "title": "Trang 12: Cây cối (3/3)",
                    "image": "images/game-dev/week5/slide_12.png",
                    "notes": "<b>Thêm Collider cho cây:</b> Bạn có thể thêm một Capsule Collider vào một tree asset mới bằng cách khởi tạo prefab của nó trong scene, thêm Capsule Collider và lưu lại prefab cho cây đã sửa đổi.\n\n<b>Làm cây uốn cong trong gió:</b> Khi có một <b>Wind Zone</b>, có thể làm cho cây uốn cong theo gió. Cần phải thiết lập riêng cho việc này trong <b>Edit Trees → Edit tree</b>. Đặt giá trị `bend` thành 1 sẽ làm cho cây uốn cong theo gió.\n\nUnity có công cụ <b>Tree Creator</b> riêng (Assets → Import Package → Tree Creator) để tạo cây dưới dạng một đối tượng game (3D Object → Tree).",
                    "terms": {
                        "Tree Creator": "Một công cụ tích hợp trong Unity cho phép bạn tạo ra các mô hình cây 3D tùy chỉnh một cách thủ tục, bằng cách xác định các thuộc tính cho thân, cành và lá."
                    }
                },
                {
                    "id": 13,
                    "title": "Trang 13: Cỏ và các chi tiết khác (1/3)",
                    "image": "images/game-dev/week5/slide_13.png",
                    "notes": "Nút <b>Paint Details</b> trên thanh công cụ cho phép tô cỏ/chi tiết. Bạn phải nhấp vào nút <b>Edit Details</b> để kích hoạt các tùy chọn này.\n\n<b>Add Grass Texture:</b> Điều này cho phép chỉ định một texture cho cỏ. Texture chỉ đơn giản là một hình ảnh nhỏ với kênh alpha được đặt thành 0 cho các vùng trống (lưu ý rằng 'cỏ' khá chung chung: bạn có thể tạo hoa hoặc các đối tượng khác với các texture khác nhau).\n\nCác giá trị <b>Min Width, Min Height, Max Width</b> và <b>Max Height</b> chỉ định giới hạn trên và dưới của kích thước của các cụm cỏ được tạo ra.",
                    "terms": {}
                },
                {
                    "id": 14,
                    "title": "Trang 14: Cỏ và các chi tiết khác (2/3)",
                    "image": "images/game-dev/week5/slide_14.png",
                    "notes": "Giá trị <b>Noise Spread</b> kiểm soát kích thước gần đúng của các mảng vá xen kẽ, với các giá trị cao hơn cho thấy sự biến đổi nhiều hơn trong một khu vực nhất định.\n\nCác cài đặt <b>Healthy/Dry Color</b> hiển thị 'sức khỏe' của các cụm cỏ bằng màu sắc của chúng.\n\nNếu tùy chọn <b>Billboard</b> được bật, các hình ảnh cỏ sẽ xoay để chúng luôn đối mặt với camera.",
                    "terms": {}
                },
                {
                    "id": 15,
                    "title": "Trang 15: Cỏ và các chi tiết khác (3/3)",
                    "image": "images/game-dev/week5/slide_15.png",
                    "notes": "<b>Add Detail Mesh:</b> Tùy chọn này cho phép bạn rải các bản sao của một mesh xung quanh địa hình.\n\nThuộc tính <b>Detail</b> được sử dụng để chọn một prefab từ dự án của bạn, nó sẽ được thay đổi tỷ lệ theo các giá trị <b>Random Width</b> và <b>Random Height</b> cho các thể hiện riêng lẻ.\n\nCác giá trị <b>Noise Spread</b> và <b>Healthy/Dry Color</b> hoạt động tương tự như đối với cỏ.\n\n<b>Render Mode</b> có thể được đặt thành:\n- <b>Grass:</b> Các thể hiện sẽ được làm phẳng thành hình ảnh 2D - giống như texture cỏ.\n- <b>Vertex Lit:</b> Các chi tiết sẽ được render dưới dạng các đối tượng 3D rắn, được chiếu sáng bằng vertex.",
                    "terms": {
                        "Vertex Lit": "Một chế độ render trong đó việc tính toán ánh sáng được thực hiện trên mỗi đỉnh (vertex) của một mesh. Đây là một phương pháp render nhanh nhưng cho chất lượng thấp hơn so với render trên mỗi pixel (Pixel Lit)."
                    }
                },
                {
                    "id": 16,
                    "title": "Trang 16: Wind Zones",
                    "image": "images/game-dev/week5/slide_16.png",
                    "notes": "Bạn có thể tạo hiệu ứng gió trên địa hình của mình bằng cách thêm một hoặc nhiều đối tượng với component <b>Wind Zone</b>.\n\n- <b>Mode</b> có thể được đặt thành <b>Directional</b> (ảnh hưởng đến toàn bộ địa hình) hoặc <b>Spherical</b> (thổi ra ngoài trong một hình cầu được xác định bởi thuộc tính Radius).\n- Thuộc tính <b>Wind Main</b> quyết định cường độ tổng thể của gió, nhưng có thể được thêm một chút biến thể ngẫu nhiên bằng cách sử dụng <b>Wind Turbulence</b>.\n- Sức mạnh của các cơn gió giật và khoảng thời gian giữa chúng có thể được kiểm soát bằng <b>Wind Pulse Magnitude</b> và <b>Wind Pulse Frequency</b>.",
                    "terms": {
                        "Wind Zone": "Một component trong Unity mô phỏng hiệu ứng của gió. Nó có thể ảnh hưởng đến các đối tượng Terrain (cây, cỏ) và các hệ thống hạt (Particle Systems)."
                    }
                },
                {
                    "id": 17,
                    "title": "Trang 17: Cài đặt Địa hình (1/4)",
                    "image": "images/game-dev/week5/slide_17.png",
                    "notes": "Các cài đặt cơ bản của địa hình:\n\n- <b>Show:</b> Bật/tắt việc hiển thị địa hình.\n- <b>Pixel Error:</b> Các giá trị cao hơn cho độ chính xác thấp hơn (quan hệ giữa độ cao/texture và địa hình) nhưng chi phí render thấp hơn.\n- <b>Base Map Distance:</b> Khoảng cách tối đa mà tại đó các texture địa hình sẽ được hiển thị ở độ phân giải đầy đủ. Vượt qua khoảng cách này, một hình ảnh ghép có độ phân giải thấp hơn sẽ được sử dụng để tăng hiệu quả.\n- <b>Cast Shadows:</b> Bật/tắt việc địa hình có tạo ra bóng đổ hay không.\n- <b>Material:</b> Vật liệu được sử dụng để render địa hình.\n- <b>Reflection Probes:</b> Cách các reflection probe được sử dụng trên địa hình.\n- <b>Thickness:</b> Độ dày mà khối va chạm của địa hình nên mở rộng dọc theo trục Y âm (để ngăn các đối tượng di chuyển tốc độ cao xuyên qua địa hình).",
                    "terms": {}
                },
                {
                    "id": 18,
                    "title": "Trang 18: Cài đặt Địa hình (2/4)",
                    "image": "images/game-dev/week5/slide_18.png",
                    "notes": "Cài đặt cho cây và các đối tượng chi tiết:\n\n- <b>Draw:</b> Bật/tắt việc vẽ cây, cỏ và các chi tiết.\n- <b>Detail Distance:</b> Khoảng cách mà vượt qua đó các chi tiết sẽ bị 'cull' (không được vẽ).\n- <b>Detail Density:</b> Số lượng các đối tượng chi tiết/cỏ trong một đơn vị diện tích nhất định.\n- <b>Tree Distance:</b> Khoảng cách mà vượt qua đó cây sẽ bị 'cull'.\n- <b>Billboard Start:</b> Khoảng cách mà tại đó các đối tượng cây 3D sẽ được thay thế bằng các hình ảnh billboard.\n- <b>Fade length:</b> Khoảng cách mà trên đó cây sẽ chuyển tiếp giữa đối tượng 3D và billboard.\n- <b>Max Mesh Trees:</b> Số lượng cây có thể nhìn thấy tối đa dưới dạng các mesh 3D rắn.",
                    "terms": {}
                },
                {
                    "id": 19,
                    "title": "Trang 19: Cài đặt Địa hình (3/4)",
                    "image": "images/game-dev/week5/slide_19.png",
                    "notes": "Cài đặt Gió (Wind Settings) trên địa hình:\n\n- <b>Speed:</b> Tốc độ của gió khi nó thổi qua cỏ.\n- <b>Size:</b> Kích thước của các gợn sóng trên các khu vực cỏ khi gió thổi qua chúng.\n- <b>Bending:</b> Mức độ mà các đối tượng cỏ bị uốn cong bởi gió.\n- <b>Grass Tint:</b> Tông màu tổng thể được áp dụng cho các đối tượng cỏ.",
                    "terms": {}
                },
                {
                    "id": 20,
                    "title": "Trang 20: Cài đặt Địa hình (4/4)",
                    "image": "images/game-dev/week5/slide_20.png",
                    "notes": "Cài đặt Độ phân giải (Resolution):\n<b>Lưu ý:</b> Việc sửa đổi độ phân giải sẽ xóa heightmap!\n\n- <b>Terrain Width/Length:</b> Kích thước của đối tượng địa hình theo trục X/Z.\n- <b>Terrain Height:</b> Sự khác biệt theo tọa độ Y giữa giá trị heightmap thấp nhất và cao nhất có thể.\n- <b>Heightmap Resolution:</b> Độ phân giải pixel của heightmap.\n- <b>Detail Resolution:</b> Độ phân giải của bản đồ cho các mảng vá chi tiết/cỏ riêng biệt.\n- <b>Control Texture Resolution:</b> Độ phân giải của 'splatmap' kiểm soát sự pha trộn của các texture địa hình khác nhau.",
                    "terms": {
                        "Splatmap": "Một texture được sử dụng trên địa hình để kiểm soát cách các texture khác nhau (cỏ, đất, đá...) được pha trộn với nhau. Mỗi kênh màu (Đỏ, Xanh lá, Xanh dương, Alpha) của splatmap có thể tương ứng với một loại texture bề mặt khác nhau."
                    }
                },
                {
                    "id": 21,
                    "title": "Trang 21: Terrain Collider",
                    "image": "images/game-dev/week5/slide_21.png",
                    "notes": "<b>Terrain Collider</b> lấy một Terrain và xây dựng Collider của nó dựa trên địa hình đó. Component này được tự động thêm vào khi bạn tạo một đối tượng Terrain.\n\nCác thuộc tính chính:\n- <b>Material:</b> Physic Material được sử dụng cho bề mặt địa hình để chỉ định ma sát và độ nảy của nó.\n- <b>Terrain Data:</b> Dữ liệu địa hình mà collider sẽ lấy hình dạng từ đó.\n- <b>Create Tree Colliders:</b> Khi được chọn, các collider cho cây sẽ được tạo ra.",
                    "terms": {}
                },
                {
                    "id": 22,
                    "title": "Trang 22: Chuyển tiếp - Buổi thực hành 5",
                    "image": "images/game-dev/week5/slide_22.png",
                    "notes": "Kết thúc phần lý thuyết về Terrains.\n\nPhần tiếp theo sẽ là xem trước nội dung buổi thực hành (Lab).",
                    "terms": {}
                },
                {
                    "id": 23,
                    "title": "Trang 23: Xem trước Buổi thực hành",
                    "image": "images/game-dev/week5/slide_23.png",
                    "notes": "Trong buổi thực hành tuần này, bạn sẽ tạo ra một địa hình với tất cả các tính năng của nó, bao gồm cả âm thanh và ánh sáng.\n\nBài giảng tiếp theo: <b>GUIs, Menus and Data, Particle Systems.</b>",
                    "terms": {}
                }
            ]
        },
        {
            "title": "Tuần 6: GUIs, Menus, Particle Systems",
            "slides": [
                {
                    "id": 1,
                    "title": "Trang 1: Bìa - GUIs, Menus, Particle Systems",
                    "image": "images/game-dev/week6/slide_1.png",
                    "notes": "Bài giảng 6: Giao diện người dùng (GUI), Menu, và Hệ thống hạt.\n\nTuần này chúng ta sẽ khám phá cách xây dựng các yếu tố giao diện và tạo ra các hiệu ứng hình ảnh ấn tượng trong Unity.",
                    "terms": {}
                },
                {
                    "id": 2,
                    "title": "Trang 2: Đề cương bài giảng",
                    "image": "images/game-dev/week6/slide_2.png",
                    "notes": "Nội dung chính của bài giảng Tuần 6 bao gồm:\n\n1. <b>Hệ thống Giao diện người dùng của Unity (The Unity UI System).</b>\n2. <b>Menu và Tải các Scene (Menus and Loading Scenes).</b>\n3. <b>Hệ thống hạt (Particles).</b>\n4. <b>Câu hỏi ôn tập và Xem trước buổi thực hành.</b>",
                    "terms": {}
                },
                {
                    "id": 3,
                    "title": "Trang 3: Chuyển tiếp - Hệ thống UI Unity",
                    "image": "images/game-dev/week6/slide_3.png",
                    "notes": "Chuẩn bị vào phần đầu tiên: Tìm hiểu về hệ thống UI mới của Unity.",
                    "terms": {}
                },
                {
                    "id": 4,
                    "title": "Trang 4: Giao diện Người dùng Đồ họa",
                    "image": "images/game-dev/week6/slide_4.png",
                    "notes": "<b>Giao diện Người dùng Đồ họa (Graphical User Interface - GUI)</b> trong game chịu trách nhiệm trình bày lượng thông tin phù hợp và có liên quan để tạo điều kiện cho người chơi ra quyết định. Nó có thể được trình bày dưới dạng các menu hoặc dưới dạng một <b>Heads-Up Display (HUD)</b>.\n\nMột thiết kế tốt của hệ thống GUI là rất cần thiết cho sự thành công và khả năng chơi được của một game. HUD thường được sử dụng để hiển thị đồng thời nhiều mẩu thông tin bao gồm máu của nhân vật chính, vật phẩm, và chỉ báo về tiến trình của game.\n\nCả GUI (và đặc biệt là HUD) đều có thể ảnh hưởng quan trọng đến sự <b>đắm chìm (immersion)</b> mà người chơi trải nghiệm.",
                    "terms": {
                        "GUI (Graphical User Interface)": "Giao diện người dùng đồ họa. Trong game, đây là tất cả các yếu tố hình ảnh mà người chơi có thể tương tác hoặc xem thông tin, chẳng hạn như menu, nút bấm, thanh máu...",
                        "HUD (Heads-Up Display)": "Một phần của GUI được hiển thị liên tục trên màn hình trong quá trình chơi game, cung cấp các thông tin quan trọng theo thời gian thực (ví dụ: máu, đạn, bản đồ nhỏ).",
                        "Immersion (Sự đắm chìm)": "Cảm giác của người chơi như thể họ thực sự đang ở bên trong thế giới của trò chơi."
                    }
                },
                {
                    "id": 5,
                    "title": "Trang 5: Canvas (1/2)",
                    "image": "images/game-dev/week6/slide_5.png",
                    "notes": "<b>Canvas</b> là khu vực chứa tất cả các yếu tố UI. Trong Unity, nó được đưa vào scene như một game object, với một component Canvas trên đó. Tất cả các yếu tố UI là các game object con của Canvas này.\n\n<b>Thứ tự vẽ của các yếu tố:</b> Các yếu tố UI trong Canvas được vẽ theo cùng thứ tự chúng xuất hiện trong cửa sổ Hierarchy. Nếu hai yếu tố UI chồng chéo lên nhau, cái sau sẽ xuất hiện trên cái trước.\n\nMột tham số quan trọng của canvas là <b>chế độ render (render mode)</b>, có thể được đặt thành:\n- <b>Screen Space - Overlay:</b> Các yếu tố UI được render trên cùng của màn hình.\n- <b>Screen Space - Camera:</b> Các yếu tố UI được render ở một khoảng cách nhất định so với camera.\n- <b>World Space:</b> Canvas hoạt động như bất kỳ đối tượng nào khác trong scene (hữu ích cho các UI là một phần của thế giới game).",
                    "terms": {
                        "Canvas": "Thành phần gốc cho tất cả các yếu tố UI trong Unity. Mọi thứ bạn thấy trong UI phải nằm bên trong một Canvas.",
                        "Hierarchy": "Một cửa sổ trong Unity Editor hiển thị danh sách tất cả các Game Object trong scene hiện tại dưới dạng một cấu trúc cây phân cấp."
                    }
                },
                {
                    "id": 6,
                    "title": "Trang 6: Canvas (2/2)",
                    "image": "images/game-dev/week6/slide_6.png",
                    "notes": "Các tham số khác của component Canvas là:\n\n- <b>Pixel Perfect:</b> Các yếu tố UI được điều chỉnh đến pixel gần nhất.\n- <b>Render Camera:</b> Camera render các yếu tố UI trong chế độ render 'Screen Space - Camera'.\n- <b>Plane Distance:</b> Khoảng cách giữa Canvas và camera trong chế độ render 'Screen Space - Camera'.\n- <b>Event Camera:</b> Xác định camera nào sẽ nhận sự kiện của người chơi nhấp vào các yếu tố UI trong chế độ render 'World Space'.\n- <b>Sorting Layer</b> và <b>Order in Layer:</b> Kiểm soát thứ tự render của canvas khi so sánh với các renderer khác trên scene.",
                    "terms": {}
                },
                {
                    "id": 7,
                    "title": "Trang 7: Sự kiện & Kích hoạt UI (1/2)",
                    "image": "images/game-dev/week6/slide_7.png",
                    "notes": "Sự tương tác của một yếu tố UI được điều khiển bởi các <b>Sự kiện (Events)</b>. Bất cứ khi nào một Canvas được tạo ra, một game object <b>EventSystem</b> sẽ tự động được thêm vào scene.\n\nThuộc tính <b>First Selected</b> cho phép chọn một yếu tố UI sẽ được chọn (không phải nhấp!) khi scene bắt đầu. Điều này hữu ích cho các hệ thống UI không dựa trên con trỏ (ví dụ: tay cầm game).\n\nBạn có thể thêm một component <b>Event Trigger</b> vào bất kỳ game object nào để kích hoạt một sự kiện khi người dùng tương tác với nó. Hầu hết các component UI đều phản hồi với ít nhất một sự kiện theo mặc định.",
                    "terms": {
                        "EventSystem": "Một game object trong Unity chịu trách nhiệm xử lý các sự kiện đầu vào (nhấp chuột, chạm, bàn phím) và gửi chúng đến các yếu tố UI tương ứng.",
                        "Event Trigger": "Một component cho phép bạn lắng nghe các sự kiện cụ thể trên một đối tượng (ví dụ: PointerEnter, Click, Drag) và gọi các hàm tương ứng để đáp lại."
                    }
                },
                {
                    "id": 8,
                    "title": "Trang 8: Sự kiện & Kích hoạt UI (2/2)",
                    "image": "images/game-dev/week6/slide_8.png",
                    "notes": "Để bắt một sự kiện cụ thể (ví dụ: On Click), một danh sách các trình xử lý sự kiện (event handlers) có thể được liên kết với mỗi yếu tố UI. Đối với mỗi hàm, bạn có thể chỉ định:\n\n- <b>Execution mode (Chế độ thực thi):</b> Off (tắt), Runtime Only (chỉ khi game chạy), hoặc Editor and Runtime (cả trong trình soạn thảo và khi chạy).\n- <b>Object (Đối tượng):</b> Đối tượng sẽ bị thao túng.\n- <b>Function (Hàm):</b> Hàm sẽ được gọi khi sự kiện được kích hoạt. Hàm cần phải là một `public void` với 0 hoặc 1 tham số.\n- <b>Parameters (Tham số):</b> Một tham số tùy chọn có thể là `int`, `float`, `string`, `bool`, hoặc một `Object`.",
                    "terms": {}
                },
                {
                    "id": 9,
                    "title": "Trang 9: UI Rect Transform (1/3)",
                    "image": "images/game-dev/week6/slide_9.png",
                    "notes": "<b>UI Rect Transform</b> là một component transform đặc biệt dành cho các yếu tố UI. Nó được dùng để chỉ định kích thước, vị trí và góc xoay của tất cả các yếu tố UI.\n\n<b>Scaling vs. Resizing (Co giãn vs. Thay đổi kích thước):</b> Khuyến khích không nên 'scale' các yếu tố UI, mà thay vào đó hãy 'resize' chúng, vì việc này không ảnh hưởng đến kích thước font chữ, đường viền của các ảnh 'sliced', v.v.\n\nMột yếu tố UI có thể được <b>neo (anchored)</b> vào đối tượng cha của nó. Điều này cho phép yếu tố đó tự động định vị lại và thay đổi kích thước dựa trên Rect Transform của đối tượng cha.",
                    "terms": {
                        "Rect Transform": "Component Transform dành riêng cho các yếu tố UI. Nó bao gồm các khái niệm về neo (anchors) và điểm xoay (pivot) để cho phép bố cục linh hoạt và thích ứng với các kích thước màn hình khác nhau.",
                        "Anchors (Điểm neo)": "Các điểm tham chiếu trên đối tượng cha mà một yếu tố UI sử dụng để xác định vị trí và kích thước của nó. Neo giúp UI co giãn một cách hợp lý khi kích thước của Canvas cha thay đổi."
                    }
                },
                {
                    "id": 10,
                    "title": "Trang 10: UI Rect Transform (2/3)",
                    "image": "images/game-dev/week6/slide_10.png",
                    "notes": "Các thuộc tính của Rect Transform:\n\n- <b>Pos (X, Y, Z):</b> Vị trí của điểm xoay (pivot) của hình chữ nhật so với các điểm neo (anchors).\n- <b>Width/Height:</b> Chiều rộng và chiều cao của hình chữ nhật.\n- <b>Anchors Min/Max:</b> Các điểm neo cho góc dưới bên trái và góc trên bên phải của hình chữ nhật, được xác định dưới dạng một phần của kích thước của hình chữ nhật cha.\n- <b>Pivot:</b> Vị trí của điểm xoay mà hình chữ nhật sẽ quay quanh, được xác định dưới dạng một phần của kích thước của chính hình chữ nhật đó.\n- <b>Rotation / Scale:</b> Góc xoay và hệ số co giãn được áp dụng cho đối tượng.",
                    "terms": {
                        "Pivot": "Một điểm trên chính Rect Transform (được xác định bằng tọa độ chuẩn hóa từ 0 đến 1) mà đối tượng sẽ xoay và co giãn quanh đó. Nó cũng là điểm tham chiếu cho vị trí 'Pos'."
                    }
                },
                {
                    "id": 11,
                    "title": "Trang 11: UI Rect Transform (3/3)",
                    "image": "images/game-dev/week6/slide_11.png",
                    "notes": "Unity cung cấp một vài cài đặt neo có sẵn (anchor presets) tương ứng với các thiết lập được sử dụng nhiều nhất. Chúng có thể được truy cập bằng cách nhấp vào nút được tô sáng trong hình ảnh.\n\nBằng cách nhấn các phím <b>Shift</b> và <b>Alt</b>, bạn sẽ có thể thiết lập tương ứng điểm xoay (pivot) và vị trí của yếu tố UI.",
                    "terms": {}
                },
                {
                    "id": 12,
                    "title": "Trang 12: Component Trực quan - UI Text",
                    "image": "images/game-dev/week6/slide_12.png",
                    "notes": "Thành phần <b>Text</b> hiển thị một đoạn văn bản không tương tác cho người dùng. Nó có thể được dùng để cung cấp chú thích hoặc nhãn cho các thành phần GUI khác hoặc để hiển thị hướng dẫn.\n\nBạn có thể chỉ định các cài đặt của văn bản như font chữ, màu sắc, kích thước, căn lề, v.v.",
                    "terms": {
                        "UI Text": "Một component UI cơ bản dùng để hiển thị văn bản trên màn hình. (Lưu ý: Trong các phiên bản Unity mới hơn, component này đã được thay thế bằng TextMeshPro cho chất lượng và tính năng vượt trội)."
                    }
                },
                {
                    "id": 13,
                    "title": "Trang 13: Component Trực quan - UI Image",
                    "image": "images/game-dev/week6/slide_13.png",
                    "notes": "Thành phần <b>Image</b> hiển thị một hình ảnh không tương tác. Nó có thể được dùng để trang trí, làm icon, v.v., và hình ảnh cũng có thể được thay đổi từ script. Hình ảnh phải được import dưới dạng một <b>Sprite</b>.\n\nLoại hình ảnh (Image Type) có thể được đặt thành:\n- <b>Simple:</b> Hình ảnh co giãn để vừa với hình chữ nhật, trừ khi `Preserve Aspect` được bật.\n- <b>Sliced:</b> Hình ảnh được xử lý như một sprite 'nine-slice' với các đường viền.\n- <b>Tiled:</b> Hình ảnh được giữ ở kích thước gốc nhưng được lặp lại nhiều lần để lấp đầy hình chữ nhật.\n- <b>Filled:</b> Hình ảnh được hiển thị dần dần từ trống đến đầy.",
                    "terms": {
                        "UI Image": "Một component UI hiển thị một hình ảnh 2D (Sprite) trên Canvas.",
                        "Sprite": "Thuật ngữ của Unity cho một đối tượng đồ họa 2D. Các tệp hình ảnh (PNG, JPG...) phải được import vào Unity với Texture Type là 'Sprite (2D and UI)' để có thể sử dụng với các component UI.",
                        "Sliced Image (9-slicing)": "Một kỹ thuật cho phép một hình ảnh 2D được co giãn một cách thông minh, giữ cho các góc không bị méo và các cạnh chỉ co giãn theo một chiều. Rất hữu ích cho việc tạo các nút bấm và khung cửa sổ có thể thay đổi kích thước."
                    }
                },
                {
                    "id": 14,
                    "title": "Trang 14: Component Tương tác - UI Button",
                    "image": "images/game-dev/week6/slide_14.png",
                    "notes": "Thành phần <b>Button</b> phản hồi với một cú nhấp chuột từ người dùng và được dùng để bắt đầu hoặc xác nhận một hành động. Game object UI Button đi kèm với các component <b>Image</b> và <b>Button</b>.\n\nCác thuộc tính chính:\n- <b>Interactable:</b> Bật/tắt việc nút có chấp nhận tương tác từ người dùng hay không.\n- <b>Transition:</b> Xác định cách nút thay đổi diện mạo (màu sắc, sprite, animation) khi được nhấp, thả ra, hoặc khi chuột di chuyển qua nó.\n- <b>Navigation:</b> Cho phép chỉ định cách di chuyển giữa các yếu tố UI bằng các phím mũi tên.\n- <b>OnClick():</b> Danh sách các hàm sẽ được gọi khi nút được nhấp.",
                    "terms": {
                        "UI Button": "Một component UI tương tác tiêu chuẩn, cho phép người dùng kích hoạt một sự kiện bằng cách nhấp vào nó.",
                        "OnClick()": "Một sự kiện (UnityEvent) trên component Button, cho phép bạn gán một hoặc nhiều hàm sẽ được thực thi khi người dùng nhấp vào nút."
                    }
                },
                {
                    "id": 15,
                    "title": "Trang 15: Component Tương tác - UI Slider",
                    "image": "images/game-dev/week6/slide_15.png",
                    "notes": "Thành phần <b>Slider</b> cho phép người dùng chọn một giá trị số từ một phạm vi được xác định trước bằng cách kéo chuột. Nó có các cài đặt tương tự như Nút, cộng thêm:\n\n- <b>Direction:</b> Hướng của thanh trượt (Trái sang Phải, Phải sang Trái, v.v.).\n- <b>Min and Max Values:</b> Các giá trị tối thiểu và tối đa cho thanh trượt.\n- <b>Whole numbers:</b> Tránh các giá trị có dấu phẩy thập phân.\n- <b>Value:</b> Giá trị hiện tại và mặc định của thanh trượt.",
                    "terms": {
                        "UI Slider": "Một component UI tương tác cho phép người dùng chọn một giá trị trong một phạm vi bằng cách kéo một tay cầm (handle) dọc theo một thanh (track)."
                    }
                },
                {
                    "id": 16,
                    "title": "Trang 16: Ví dụ - Thanh máu (1/3)",
                    "image": "images/game-dev/week6/slide_16.png",
                    "notes": "Ví dụ này bao gồm một <b>UI Image (Trái tim)</b> và một <b>UI Slider (Thanh máu)</b>, chứa một vùng nền (background) và một vùng lấp đầy (fill area).\n\nComponent Slider được cấu hình với các giá trị Min là 0, Max là 100, và Value hiện tại là 100. Vùng `Fill Rect` được gán vào để Slider có thể điều khiển độ rộng của nó, tạo ra hiệu ứng thanh máu đầy/vơi.",
                    "terms": {}
                },
                [
                    {
                        "id": 17,
                        "title": "Trang 17: Ví dụ - Thanh máu (2/3)",
                        "image": "images/game-dev/week6/slide_17.png",
                        "notes": "Cấu hình chi tiết cho các hình ảnh của thanh máu:\n\n- <b>Background Image:</b> Hình ảnh nền của thanh trượt. Image Type được đặt là `Sliced` để nó có thể co giãn một cách chính xác mà không làm méo các góc.\n\n- <b>Fill Image:</b> Hình ảnh sẽ lấp đầy thanh trượt. Image Type cũng được đặt là `Sliced`.",
                        "terms": {}
                    },
                    {
                        "id": 18,
                        "title": "Trang 18: Ví dụ - Thanh máu (3/3)",
                        "image": "images/game-dev/week6/slide_18.png",
                        "notes": "Việc thay đổi giá trị máu và thanh trượt từ một script rất đơn giản:\n\n- Đoạn mã `PlayerHealth.cs` này quản lý máu của người chơi.\n- Nó có một tham chiếu `public Slider healthSlider` mà bạn có thể kéo thả UI Slider vào trong Inspector.\n- Trong hàm `Awake()`, máu hiện tại được thiết lập bằng máu khởi đầu.\n- Khi hàm `TakeDamage(int amount)` được gọi, máu hiện tại sẽ giảm đi, và sau đó giá trị `value` của `healthSlider` sẽ được cập nhật để phản ánh sự thay đổi đó, làm cho thanh máu trên màn hình ngắn lại.",
                        "terms": {}
                    },
                    {
                        "id": 19,
                        "title": "Trang 19: Chuyển tiếp - Menu và Tải Scene",
                        "image": "images/game-dev/week6/slide_19.png",
                        "notes": "Kết thúc phần giới thiệu các component UI cơ bản.\n\nPhần tiếp theo sẽ tập trung vào cách tạo các menu và quản lý việc chuyển đổi giữa các màn chơi (scenes).",
                        "terms": {}
                    },
                    {
                        "id": 20,
                        "title": "Trang 20: Hiệu ứng Mờ dần (1/3)",
                        "image": "images/game-dev/week6/slide_20.png",
                        "notes": "Chúng ta sẽ xem một ví dụ về cách làm mờ dần một texture. Đầu tiên, chúng ta sẽ tạo một script để quản lý hiệu ứng này. Chúng ta có thể gán nó vào bất kỳ game object nào trong scene (ví dụ: game manager, camera, v.v.).\n\n- <b>fadeOutTexture:</b> Texture sẽ che phủ màn hình.\n- <b>fadeSpeed:</b> Tốc độ mờ dần.\n- <b>alpha:</b> Giá trị alpha của texture (từ 0 đến 1).\n- <b>drawDepth:</b> Thứ tự trong hệ thống phân cấp vẽ (ưu tiên cao nhất).\n- <b>fadeDir:</b> Hướng mờ (-1 là mờ dần, 1 là hiện dần).",
                        "terms": {}
                    },
                    {
                        "id": 21,
                        "title": "Trang 21: Hiệu ứng Mờ dần (2/3)",
                        "image": "images/game-dev/week6/slide_21.png",
                        "notes": "Hàm `OnGUI()` được sử dụng để thực hiện hiệu ứng mờ dần. Đây là một hàm sự kiện đặc biệt được gọi ở mỗi frame để vẽ các yếu tố GUI cũ (Immediate Mode GUI).\n\n- Giá trị `alpha` được sửa đổi dần dần, sử dụng `Time.deltaTime` để tính bằng giây.\n- Màu sắc của GUI được đặt, giữ nguyên màu của texture và chỉ thay đổi kênh alpha.\n- Texture che phủ được vẽ lên toàn bộ màn hình.\n\nMột texture màu đen sẽ hoạt động rất tốt cho hiệu ứng mờ dần này.",
                        "terms": {
                            "OnGUI()": "Một hàm sự kiện của MonoBehaviour được Unity gọi nhiều lần trong mỗi frame để vẽ và xử lý các sự kiện của hệ thống GUI cũ (còn gọi là Immediate Mode GUI - IMGUI)."
                        }
                    },
                    {
                        "id": 22,
                        "title": "Trang 22: Hiệu ứng Mờ dần (3/3)",
                        "image": "images/game-dev/week6/slide_22.png",
                        "notes": "Để bắt đầu hiệu ứng mờ dần, chúng ta có thể gọi một hàm bắt đầu một coroutine. Coroutine này sẽ bắt đầu quá trình mờ dần (`BeginFade(1)`), chờ cho đến khi quá trình mờ dần kết thúc, và sau đó tải scene tiếp theo bằng `SceneManager.LoadScene()`.\n\nTrước khi có thể tải một scene, bạn phải thêm nó vào danh sách các scene được sử dụng trong game. Sử dụng <b>File → Build Settings</b> trong Unity và thêm các scene bạn cần vào danh sách.\n\nKhi một scene mới được tải, tất cả các game object từ scene hiện tại sẽ bị phá hủy.",
                        "terms": {
                            "SceneManager.LoadScene()": "Hàm static chính trong Unity để tải một Scene. Bạn có thể tải scene bằng tên hoặc bằng chỉ số (build index) của nó trong Build Settings."
                        }
                    },
                    {
                        "id": 23,
                        "title": "Trang 23: Tạo một Menu đơn giản (1/3)",
                        "image": "images/game-dev/week6/slide_23.png",
                        "notes": "Một menu để chọn các màn chơi (scenes) có thể được đặt trong một <b>scene độc lập</b>. Đây là một ví dụ về một menu với hai màn chơi để tải.\n\nĐối tượng Canvas có một component script (`LoadOnClick.cs`) với mã nguồn sau. Nó chứa một hàm public `LoadScene(int levelIdx)` nhận vào một chỉ số màn chơi và gọi `SceneManager.LoadScene()`.",
                        "terms": {}
                    },
                    {
                        "id": 24,
                        "title": "Trang 24: Tạo một Menu đơn giản (2/3)",
                        "image": "images/game-dev/week6/slide_24.png",
                        "notes": "Mỗi nút trong menu có một component <b>Button (Script)</b>, chứa một hàm public để gọi khi nút này được nhấp.\n\nVì `LoadOnClick` có một hàm public `LoadScene` với một tham số, hàm này sẽ xuất hiện trong các phương thức có sẵn để gọi trong sự kiện OnClick() của Button.\n\nMỗi nút sẽ truyền một giá trị khác nhau cho tham số, tùy thuộc vào màn chơi cần tải. Ví dụ, nút 'Level01Button' truyền vào số 1, nút 'Level02Button' truyền vào số 2.",
                        "terms": {}
                    }
                ],
                {
                    "id": 25,
                    "title": "Trang 25: Tạo một Menu đơn giản (3/3)",
                    "image": "images/game-dev/week6/slide_25.png",
                    "notes": "Tham số được truyền vào hàm (`levelIdx`) tương ứng với thứ tự mà các scene được tải trong cài đặt build (<b>File → Build Settings</b>). Mỗi scene trong danh sách 'Scenes In Build' đều có một chỉ số (index) bắt đầu từ 0.\n\nĐể thêm một màn hình tải (loading screen), chúng ta có thể thêm một hình ảnh với nền đen và một dòng chữ cho biết scene đang được tải. Đặt nó làm một biến public trong cùng script, chúng ta có thể chỉ cần kích hoạt nó (`SetActive(true)`) khi sự kiện được ghi nhận, ngay trước khi tải scene mới.",
                    "terms": {
                        "Build Settings": "Một cửa sổ trong Unity Editor nơi bạn quản lý các scene sẽ được đưa vào bản build cuối cùng của game. Thứ tự của các scene trong danh sách này rất quan trọng vì nó quyết định chỉ số (index) của mỗi scene."
                    }
                },
                {
                    "id": 26,
                    "title": "Trang 26: sceneLoaded và delegates",
                    "image": "images/game-dev/week6/slide_26.png",
                    "notes": "Có thể thêm một <b>delegate</b> vào sự kiện `SceneManager.sceneLoaded` để phát hiện khi nào một scene đã được tải xong. Một delegate chỉ đơn giản là một hàm ghi lại một sự kiện được kích hoạt bởi Unity.\n\nTrong ví dụ này, hàm `mySceneLoaded` được đăng ký với sự kiện `sceneLoaded` trong `Awake()`. Khi một scene bất kỳ được tải xong, hàm `mySceneLoaded` sẽ được gọi. Nó kiểm tra xem chỉ số của scene vừa được tải có phải là 2 không, và nếu đúng, nó sẽ thay đổi `AudioClip` và phát nhạc mới.",
                    "terms": {
                        "Delegate": "Trong C#, đây là một kiểu dữ liệu tham chiếu đến một hoặc nhiều phương thức. Nó cho phép bạn truyền các phương thức như các tham số. Trong Unity, delegates thường được sử dụng để tạo ra các hệ thống sự kiện (event systems).",
                        "SceneManager.sceneLoaded": "Một sự kiện (event) được kích hoạt mỗi khi một scene được tải xong. Bạn có thể 'đăng ký' các hàm của mình vào sự kiện này để thực thi code ngay sau khi scene mới sẵn sàng."
                    }
                },
                {
                    "id": 27,
                    "title": "Trang 27: Tải chồng (Loading Additively)",
                    "image": "images/game-dev/week6/slide_27.png",
                    "notes": "Có thể thêm tất cả các đối tượng từ một scene vào scene hiện tại bằng cách sử dụng một chế độ tải khác: `LoadSceneMode.Additive`.\n\nLệnh gọi này tải một màn chơi một cách 'chồng' lên. Không giống như `LoadSceneMode.Single` (mặc định), nó <b>không</b> phá hủy các đối tượng trong scene hiện tại. Các đối tượng từ màn chơi mới được thêm vào scene hiện tại. Điều này hữu ích để tạo ra các thế giới ảo liên tục, nơi nội dung mới được tải vào khi bạn đi qua môi trường.",
                    "terms": {
                        "LoadSceneMode.Additive": "Một chế độ tải scene, trong đó scene mới được tải và thêm vào scene hiện tại mà không xóa bỏ các đối tượng đang có. Rất hữu ích cho việc streaming thế giới hoặc quản lý các scene UI."
                    }
                },
                {
                    "id": 28,
                    "title": "Trang 28: TimeScale - Tạm dừng game",
                    "image": "images/game-dev/week6/slide_28.png",
                    "notes": "Một cách để tạm dừng game trong Unity là thông qua việc sửa đổi biến `Time.timeScale`.\n\n`timeScale` là tỷ lệ mà thời gian đang trôi qua. Nó cũng có thể được sử dụng cho các hiệu ứng chuyển động chậm (slow motion).\n\n- Khi `timeScale` là <b>1.0</b>: thời gian trôi qua nhanh như thời gian thực.\n- Khi `timeScale` là <b>0.5</b>: thời gian trôi qua chậm hơn 2 lần so với thời gian thực.\n- Khi `timeScale` là <b>0</b>: game về cơ bản là <b>bị tạm dừng</b>.\n\nLưu ý: Các hàm `FixedUpdate()` sẽ không được gọi khi `timeScale` được đặt thành 0.",
                    "terms": {
                        "Time.timeScale": "Một thuộc tính static cho phép bạn làm chậm, tăng tốc hoặc tạm dừng hoàn toàn thời gian trong game. Nó ảnh hưởng đến `Time.deltaTime` và các cập nhật vật lý."
                    }
                },
                {
                    "id": 29,
                    "title": "Trang 29: Chuyển tiếp - Hệ thống hạt",
                    "image": "images/game-dev/week6/slide_29.png",
                    "notes": "Kết thúc phần Menu và Tải Scene.\n\nPhần tiếp theo sẽ giới thiệu về một công cụ mạnh mẽ để tạo ra các hiệu ứng hình ảnh: Hệ thống hạt (Particle Systems).",
                    "terms": {}
                },
                {
                    "id": 30,
                    "title": "Trang 30: Billboarding (1/2)",
                    "image": "images/game-dev/week6/slide_30.png",
                    "notes": "<b>Billboarding</b> là một kỹ thuật trong đó các texture 2D được vẽ lên các hình chữ nhật 3D (quads) được đặt trong scene. Thông thường, các quads này được xoay về phía camera sao cho chúng luôn đối mặt với người xem. Điều này cho phép tạo ra ảo giác về một mô hình mặc dù với chi phí giảm đi nhiều. Một công dụng phổ biến là cây cối trong hậu cảnh hoặc mây trên trời.\n\nCác loại billboard khác nhau:\n- <b>Spherical:</b> Xoay hoàn toàn về phía camera.\n- <b>Cylindrical:</b> Chỉ xoay quanh một trục (thường là trục Up).\n- <b>Non-rotating:</b> Hai quad tạo thành góc 90 độ với nhau.",
                    "terms": {
                        "Billboarding": "Một kỹ thuật đồ họa trong đó các sprite (hình ảnh 2D) luôn được xoay để đối mặt với camera. Rất hữu ích để tạo ra các hiệu ứng như khói, lửa, hoặc các đối tượng ở xa như cây cối mà không tốn nhiều tài nguyên render 3D."
                    }
                },
                {
                    "id": 31,
                    "title": "Trang 31: Billboarding (2/2)",
                    "image": "images/game-dev/week6/slide_31.png",
                    "notes": "Một số texture hoạt động tốt hơn cho billboarding so với những cái khác:\n- Với cây cối, thân cây nên tròn vì điều này ngăn người chơi nhận thấy sự xoay.\n- Các texture có nền trong suốt sẽ tốt hơn.\n\nVới billboarding, người ta có thể vẽ nhiều đối tượng hơn so với khả năng có thể. Trong game của bạn, bạn có thể thử kết hợp billboarding với các mô hình để đảm bảo trải nghiệm gameplay nhất quán.",
                    "terms": {}
                },
                {
                    "id": 32,
                    "title": "Trang 32: Hệ thống hạt (1/2)",
                    "image": "images/game-dev/week6/slide_32.png",
                    "notes": "Các sprite (trong game 2D) và mesh (trong 3D) là những cách lý tưởng để mô tả các vật thể 'rắn' trong game. Tuy nhiên, có những thực thể trong game ở dạng lỏng và vô hình, và do đó khó miêu tả bằng mesh hoặc sprite. <b>Hệ thống hạt (Particle Systems)</b> là một phương pháp đồ họa để nắm bắt hành vi của các thực thể này, chẳng hạn như chất lỏng chuyển động, khói, mây, lửa và các phép thuật.\n\nMột hệ thống hạt được cấu tạo bởi một bộ sưu tập các billboard hoặc hạt, trong đó mỗi hạt:\n- Được xoay về phía camera.\n- Có một vị trí ngẫu nhiên ban đầu.\n- Bắt đầu vòng đời của nó khi được tạo ra hoặc phát ra.\n- Có một 'vòng đời' (lifetime).\n- Có một vector vận tốc (velocity).",
                    "terms": {
                        "Particle System": "Một component trong Unity dùng để mô phỏng một số lượng lớn các hạt nhỏ và điều khiển chuyển động của chúng để tạo ra các hiệu ứng hình ảnh như lửa, khói, mưa, phép thuật, và các vụ nổ."
                    }
                },
                {
                    "id": 33,
                    "title": "Trang 33: Hệ thống hạt (2/2)",
                    "image": "images/game-dev/week6/slide_33.png",
                    "notes": "<b>Tốc độ phát thải (emission rate)</b> của hệ thống cho biết gần đúng có bao nhiêu hạt được phát ra <b>mỗi giây</b>. Sự lựa chọn tốc độ phát thải và vòng đời trung bình của hạt quyết định số lượng hạt ở <b>trạng thái ổn định</b> (tức là, nơi phát thải và hạt chết đi xảy ra ở cùng một tốc độ).\n\nCác hạt thường được làm mờ dần khi chúng được tạo ra (faded in) và khi bị phá hủy (faded out). Trong suốt vòng đời của mình, chúng có thể trải qua nhiều thay đổi khác nhau (như vận tốc, màu sắc, kích thước, góc xoay) và bị ảnh hưởng bởi các lực như gió hoặc trọng lực.",
                    "terms": {}
                },
                {
                    "id": 34,
                    "title": "Trang 34: Thay đổi Thuộc tính theo Thời gian",
                    "image": "images/game-dev/week6/slide_34.png",
                    "notes": "Nhiều thuộc tính số của các hạt hoặc thậm chí của toàn bộ hệ thống có thể được thay đổi theo thời gian. Unity cung cấp nhiều phương pháp khác nhau để chỉ định cách sự thay đổi sẽ xảy ra:\n\n- <b>Constant:</b> Giá trị của thuộc tính được cố định trong suốt vòng đời của nó.\n- <b>Curve:</b> Giá trị được chỉ định bởi một đường cong/đồ thị.\n- <b>Random between two constants:</b> Hai giá trị hằng số xác định giới hạn trên và dưới cho giá trị.\n- <b>Random between two curves:</b> Hai đường cong xác định giới hạn trên và dưới cho giá trị tại một thời điểm nhất định.\n\nĐối với các thuộc tính màu sắc, có hai tùy chọn riêng biệt:\n- <b>Gradient:</b> Giá trị màu được lấy từ một dải màu chuyển sắc.\n- <b>Random between two gradients:</b> Hai dải màu xác định giới hạn trên và dưới cho giá trị màu.",
                    "terms": {
                        "Curve Editor": "Một công cụ trực quan trong Unity cho phép bạn chỉnh sửa một đường cong để xác định cách một giá trị thay đổi theo thời gian. Rất hữu ích trong Particle Systems và Animations.",
                        "Gradient": "Một dải màu chuyển tiếp mượt mà từ màu này sang màu khác. Trong Particle Systems, nó thường được dùng để thay đổi màu của hạt theo thời gian sống của nó."
                    }
                },
                {
                    "id": 35,
                    "title": "Trang 35: Component Hệ thống hạt",
                    "image": "images/game-dev/week6/slide_35.png",
                    "notes": "Slide này hiển thị giao diện của component Particle System trong Inspector. Nó bao gồm:\n\n- <b>Các cài đặt toàn cục (Global Settings):</b> Ở trên cùng, xác định các hành vi cơ bản của toàn bộ hệ thống (thời lượng, có lặp lại không, v.v.).\n- <b>Các Modules:</b> Một danh sách các module có thể bật/tắt để thêm các hành vi phức tạp hơn (phát thải, hình dạng, vận tốc theo thời gian, va chạm...).\n- <b>Renderer Module:</b> Ở dưới cùng, quyết định cách các hạt sẽ được vẽ lên màn hình, bao gồm cả Material và Shader sẽ được sử dụng.",
                    "terms": {}
                },
                {
                    "id": 36,
                    "title": "Trang 36: Cài đặt Toàn cục",
                    "image": "images/game-dev/week6/slide_36.png",
                    "notes": "Các cài đặt toàn cục của Particle System:\n\n- <b>Duration:</b> Khoảng thời gian hệ thống sẽ chạy.\n- <b>Looping:</b> Bật/tắt việc hệ thống có bắt đầu lại sau khi kết thúc hay không.\n- <b>Start Delay:</b> Độ trễ (tính bằng giây) trước khi hệ thống bắt đầu phát ra hạt.\n- <b>Start Lifetime:</b> Vòng đời ban đầu của các hạt.\n- <b>Start Speed / Size / Rotation / Colour:</b> Tốc độ / Kích thước / Góc xoay / Màu sắc ban đầu của mỗi hạt.\n- <b>Gravity Multiplier:</b> Hệ số nhân áp dụng cho trọng lực toàn cục (0: không có trọng lực).\n- <b>Simulation Space:</b> Quyết định các hạt sẽ được mô phỏng trong không gian cục bộ (di chuyển cùng đối tượng cha) hay không gian thế giới.",
                    "terms": {}
                },
                {
                    "id": 37,
                    "title": "Trang 37: Modules (1/12) - Emission",
                    "image": "images/game-dev/week6/slide_37.png",
                    "notes": "<b>Emission Module (Module Phát thải):</b>\n\nModule này điều chỉnh việc phát ra các hạt từ hệ thống. Nó có thể được đặt thành số lượng hạt mỗi giây (Rate over Time) hoặc mỗi đơn vị khoảng cách (Rate over Distance).\n\n<b>Bursts (Phát xạ đột ngột)</b> được sử dụng để thêm các đợt phát ra thêm các hạt tại các thời điểm cụ thể.",
                    "terms": {}
                },
                {
                    "id": 38,
                    "title": "Trang 38: Modules (2/12) - Shape",
                    "image": "images/game-dev/week6/slide_38.png",
                    "notes": "<b>Shape Module (Module Hình dạng):</b>\n\nCho biết hình dạng của khối phát thải và nơi các hạt được phóng ra từ bên trong nó. Hình dạng có thể là:\n- <b>Cone (Hình nón)</b>\n- <b>Sphere (Hình cầu)</b>\n- <b>Hemisphere (Hình bán cầu)</b>\n- <b>Box (Hình hộp)</b>\n- <b>Mesh (Lưới)</b>\n- Và các hình dạng khác.",
                    "terms": {}
                },
                {
                    "id": 39,
                    "title": "Trang 39: Modules (3/12) - Velocity over Lifetime",
                    "image": "images/game-dev/week6/slide_39.png",
                    "notes": "<b>Velocity over Lifetime Module (Module Vận tốc theo Vòng đời):</b>\n\nGia tốc có thể được áp dụng để thay đổi vận tốc của các hạt trong suốt vòng đời của chúng. Vì tất cả các thay đổi đều diễn ra theo thời gian, có thể chỉ định cách sự thay đổi này sẽ xảy ra thông qua một đường cong (curve).",
                    "terms": {}
                },
                {
                    "id": 40,
                    "title": "Trang 40: Modules (4/12) - Các module khác",
                    "image": "images/game-dev/week6/slide_40.png",
                    "notes": "<b>Các module '... Over Lifetime':</b>\n- <b>Limit Velocity:</b> Kiểm soát cách tốc độ của hạt bị giảm theo thời gian.\n- <b>Force:</b> Các hạt có thể được tăng tốc bởi các lực (gió, lực hút...) được chỉ định trong module này.\n- <b>Color:</b> Chỉ định cách màu sắc và độ trong suốt của hạt thay đổi theo thời gian.\n- <b>Size / Rotation:</b> Cho phép các hạt thay đổi kích thước hoặc xoay khi chúng di chuyển.\n\n<b>Các module '... By Speed':</b>\n- <b>Color By Speed:</b> Thay đổi màu của hạt dựa trên tốc độ của nó.\n- <b>Size By Speed:</b> Thay đổi kích thước của hạt dựa trên tốc độ của nó.\n- <b>Rotation By Speed:</b> Thay đổi góc xoay của hạt dựa trên tốc độ của nó.",
                    "terms": {}
                },
                {
                    "id": 41,
                    "title": "Trang 41: Modules (5/12) - Collision",
                    "image": "images/game-dev/week6/slide_41.png",
                    "notes": "<b>Collision Module (Module Va chạm):</b>\n\nModule này kiểm soát cách các hạt va chạm với các vật thể rắn trong scene. Va chạm có thể được đặt ở hai chế độ khác nhau (World hoặc Planes).\n\n- <b>Dampen:</b> Phần trăm tốc độ của hạt bị mất sau một vụ va chạm.\n- <b>Bounce:</b> Phần trăm tốc độ của hạt nảy lại sau một vụ va chạm.\n- <b>Lifetime Loss:</b> Phần trăm tổng vòng đời của hạt bị mất nếu nó va chạm.\n- <b>Min Kill Speed:</b> Các hạt di chuyển dưới tốc độ này sau một vụ va chạm sẽ bị loại bỏ.\n- <b>Send Collision Messages:</b> Nếu được bật, các va chạm của hạt có thể được phát hiện từ script bằng hàm `OnParticleCollision`.",
                    "terms": {}
                },
                {
                    "id": 42,
                    "title": "Trang 42: Modules (6/12) - Collision (World Mode)",
                    "image": "images/game-dev/week6/slide_42.png",
                    "notes": "<b>Collision Module - Chế độ World:</b>\n\nTrong chế độ va chạm 'World', các hạt sẽ va chạm với <b>bất kỳ</b> collider nào trong scene. Chi phí xử lý cho tùy chọn này là cao, mặc dù nó thực tế hơn.\n\nHai cài đặt khác có sẵn trong chế độ này:\n- <b>Collides With:</b> Các hạt sẽ chỉ va chạm với các đối tượng trên các layer được chọn.\n- <b>Collision Quality:</b> Điều này ảnh hưởng đến mức độ nghiêm ngặt của các va chạm (ở các mức chất lượng thấp hơn, các hạt đôi khi có thể đi xuyên qua các collider).",
                    "terms": {}
                },
                {
                    "id": 43,
                    "title": "Trang 43: Modules (7/12) - Collision (Plane Mode)",
                    "image": "images/game-dev/week6/slide_43.png",
                    "notes": "<b>Collision Module - Chế độ Plane:</b>\n\nTrong chế độ va chạm 'Plane', một danh sách các transform (thường là các GameObjects trống) có thể được thêm vào, dưới dạng một tập hợp các mặt phẳng mà các hạt sẽ va chạm. Các mặt phẳng này mở rộng vô hạn trong mặt phẳng XZ cục bộ của đối tượng với trục Y dương chỉ ra vector pháp tuyến của mặt phẳng (mặc dù chúng có thể được xoay).",
                    "terms": {}
                },
                {
                    "id": 44,
                    "title": "Trang 44: Modules (8/12) - Triggers",
                    "image": "images/game-dev/week6/slide_44.png",
                    "notes": "<b>Triggers Module:</b>\n\nCho phép bạn định nghĩa một collider (tức là một khối lập phương) hoạt động như một trigger cho Particle System. Các hiệu ứng có thể được xác định cho các hạt khi chúng ở <b>bên trong (inside)</b>, <b>bên ngoài (outside)</b>, <b>đi vào (enter)</b> và/hoặc <b>đi ra (exit)</b> khỏi trigger.\n\nCác tùy chọn là:\n- <b>Ignore:</b> không có gì xảy ra.\n- <b>Kill:</b> giết chết hạt.\n- <b>Callback:</b> gọi một hàm tùy chỉnh (qua `OnParticleTrigger`).",
                    "terms": {}
                },
                {
                    "id": 45,
                    "title": "Trang 45: Modules (9/12) - Sub-emitters",
                    "image": "images/game-dev/week6/slide_45.png",
                    "notes": "<b>Sub Emitters (Bộ phát phụ)</b> là các hệ thống hạt bổ sung được tạo ra tại vị trí của một hạt ở các giai đoạn nhất định trong vòng đời của nó. Các giai đoạn của vòng đời của hạt liên quan đến các hệ thống thứ cấp này là <b>Sinh ra (Birth)</b>, <b>Va chạm (Collision)</b> và <b>Chết (Death)</b>.\n\nHai bộ phát phụ có thể được thêm vào cho mỗi giai đoạn bằng cách sử dụng các mũi tên '+' ở bên phải của inspector.",
                    "terms": {
                        "Sub Emitter": "Một Particle System được kích hoạt bởi một hạt từ một Particle System khác. Rất hữu ích để tạo ra các hiệu ứng phức tạp, nhiều tầng lớp (ví dụ: một quả pháo hoa nổ ra các tia lửa nhỏ hơn)."
                    }
                },
                {
                    "id": 46,
                    "title": "Trang 46: Modules (10/12) - Renderer",
                    "image": "images/game-dev/week6/slide_46.png",
                    "notes": "<b>Renderer Module:</b>\n\nCài đặt của module này xác định cách hình ảnh hoặc mesh của một hạt được biến đổi, tô bóng và bị vẽ đè bởi các hạt khác.\n\n<b>Chế độ Render (Render Mode)</b> xác định cách hình ảnh được render được tạo ra từ hình ảnh đồ họa:\n- <b>Billboard:</b> Hạt luôn đối mặt với camera.\n- <b>Stretched Billboard:</b> Đối mặt với camera nhưng có áp dụng co giãn.\n- <b>Horizontal Billboard:</b> Mặt phẳng hạt song song với mặt phẳng 'sàn' XZ.\n- <b>Vertical Billboard:</b> Hạt thẳng đứng trên trục Y của thế giới nhưng quay mặt về phía camera.\n- <b>Mesh:</b> Hạt được render từ một mesh 3D thay vì một texture.",
                    "terms": {}
                },
                {
                    "id": 47,
                    "title": "Trang 47: Modules (11/12) - Renderer Properties",
                    "image": "images/game-dev/week6/slide_47.png",
                    "notes": "Các thuộc tính phổ biến của Renderer:\n\n- <b>Material:</b> Material được sử dụng để render hạt.\n- <b>Sort Mode:</b> Thứ tự mà các hạt được vẽ (và do đó bị đè lên nhau).\n- <b>Sorting Fudge:</b> Độ lệch của thứ tự sắp xếp hạt.\n- <b>Cast Shadows / Receive Shadows:</b> Hạt có tạo bóng hoặc nhận bóng hay không.\n- <b>Max Particle Size:</b> Kích thước hạt lớn nhất (bất kể các cài đặt khác), được biểu thị dưới dạng một phần của kích thước viewport.",
                    "terms": {}
                },
                {
                    "id": 48,
                    "title": "Trang 48: Modules (12/12) - Renderer Properties",
                    "image": "images/game-dev/week6/slide_48.png",
                    "notes": "Các thuộc tính dành riêng cho từng chế độ render:\n\n<b>Chế độ Stretched Billboard:</b>\n- <b>Camera Scale:</b> Độ co giãn được áp dụng tỷ lệ với chuyển động của camera.\n- <b>Speed Scale:</b> Độ co giãn được áp dụng tỷ lệ với tốc độ của hạt.\n- <b>Length Scale:</b> Độ co giãn được áp dụng tỷ lệ với chiều dài của hạt.\n\n<b>Chế độ Billboard:</b>\n- <b>Normal Direction:</b> Độ lệch của các pháp tuyến chiếu sáng được sử dụng cho đồ họa hạt.\n\n<b>Chế độ Mesh:</b>\n- <b>Mesh:</b> Một hoặc nhiều mesh được sử dụng để render các hạt.",
                    "terms": {}
                },
                {
                    "id": 49,
                    "title": "Trang 49: Chuyển tiếp - Câu hỏi & Demo Lab",
                    "image": "images/game-dev/week6/slide_49.png",
                    "notes": "Kết thúc phần lý thuyết về Hệ thống hạt.\n\nPhần cuối cùng sẽ là các câu hỏi kiểm tra và xem trước nội dung buổi thực hành (Lab).",
                    "terms": {}
                },
                {
                    "id": 50,
                    "title": "Trang 50: Xem trước Buổi thực hành",
                    "image": "images/game-dev/week6/slide_50.png",
                    "notes": "Chúng ta sẽ hoàn thành bài tập về địa hình, thêm vào một menu, các hiệu ứng mờ dần (fade-in/out), và các hệ thống hạt.\n\nBài giảng tiếp theo: <b>Persistence and animations.</b>",
                    "terms": {}
                }
            ]
        },
        {
            "title": "Tuần 7: Persistence and Animations",
            "slides": [
                {
                    "id": 1,
                    "title": "Trang 1: Bìa - Persistence and Animations",
                    "image": "images/game-dev/week7/slide_1.png",
                    "notes": "Bài giảng 7: Tính bền bỉ (Lưu trữ dữ liệu) và Animations.\n\nTuần này chúng ta sẽ tìm hiểu cách lưu và tải dữ liệu game, cũng như các kỹ thuật tạo và điều khiển chuyển động cho nhân vật và đối tượng.",
                    "terms": {}
                },
                {
                    "id": 2,
                    "title": "Trang 2: Đề cương bài giảng",
                    "image": "images/game-dev/week7/slide_2.png",
                    "notes": "Nội dung chính của bài giảng Tuần 7 bao gồm:\n\n1. <b>Tính bền bỉ: Tải và Lưu Dữ liệu.</b>\n2. <b>Máy trạng thái hữu hạn, Animations và Animators.</b>\n3. <b>Pha trộn Animations (Blending Animations).</b>\n4. <b>Điều khiển Animation bằng Script.</b>\n5. <b>Câu hỏi ôn tập và Xem trước buổi thực hành.</b>",
                    "terms": {}
                },
                {
                    "id": 3,
                    "title": "Trang 3: Chuyển tiếp - Tải và Lưu Dữ liệu",
                    "image": "images/game-dev/week7/slide_3.png",
                    "notes": "Chuẩn bị vào phần đầu tiên: Các kỹ thuật để lưu trữ dữ liệu game giữa các lần chơi và giữa các màn chơi.",
                    "terms": {}
                },
                {
                    "id": 4,
                    "title": "Trang 4: Giữa các Scene - Player Preferences",
                    "image": "images/game-dev/week7/slide_4.png",
                    "notes": "Cách dễ nhất (và <b>sai lầm!</b>) để lưu và tải dữ liệu giữa các scene là sử dụng <b>PlayerPrefs</b>. Về cơ bản, PlayerPrefs là một hash map cho phép lưu trữ và truy xuất các giá trị bất kỳ lúc nào, và nó không bị phá hủy hoặc xóa khi đóng một scene.\n\nPlayerPrefs cung cấp các phương thức như `GetFloat`, `SetInt`, `GetString`, `HasKey`, `DeleteAll`, v.v.\n\nHàm `Save()` ghi tất cả các thay đổi vào đĩa (không nên gọi trong khi gameplay vì lý do hiệu suất).",
                    "terms": {
                        "PlayerPrefs": "Một lớp trong Unity cung cấp một cách đơn giản để lưu và truy xuất các dữ liệu nhỏ (như cài đặt người dùng, điểm cao) giữa các phiên chơi game. Dữ liệu được lưu dưới dạng văn bản thuần túy và không an toàn."
                    }
                },
                {
                    "id": 5,
                    "title": "Trang 5: Giữ đối tượng giữa các Scene (1/2)",
                    "image": "images/game-dev/week7/slide_5.png",
                    "notes": "PlayerPrefs <b>không phải</b> là một cách an toàn để lưu thông tin giữa các scene vì nó là văn bản thuần túy! PlayerPrefs chỉ nên được dùng để lưu... tùy chọn của người chơi! (Dữ liệu không quan trọng cho game).\n\nMột cách tốt hơn, bạn có thể lưu dữ liệu trong một đối tượng, và sử dụng `DontDestroyOnLoad` để tránh việc phá hủy một đối tượng khi chuyển từ scene này sang scene khác.\n\n`DontDestroyOnLoad` làm cho đối tượng mục tiêu không bị phá hủy tự động khi tải một scene mới.",
                    "terms": {
                        "DontDestroyOnLoad()": "Một hàm static của Unity dùng để đánh dấu một đối tượng không bị phá hủy khi một scene mới được tải. Rất hữu ích để tạo ra các đối tượng quản lý (manager objects) tồn tại xuyên suốt game."
                    }
                },
                {
                    "id": 6,
                    "title": "Trang 6: Giữ đối tượng giữa các Scene (2/2)",
                    "image": "images/game-dev/week7/slide_6.png",
                    "notes": "Chúng ta có thể tạo một script `GameControl` và gắn nó vào một đối tượng mà chúng ta muốn bảo tồn. Script này sử dụng một mẫu thiết kế gọi là <b>Singleton</b>.\n\nTrong hàm `Awake()`, nó kiểm tra xem đã có một `control` (thể hiện của GameControl) tồn tại hay chưa. Nếu chưa, nó sẽ tự đặt mình làm `control` duy nhất và gọi `DontDestroyOnLoad`. Nếu đã có một `control` khác tồn tại (khi bạn tải lại scene chứa nó), nó sẽ tự hủy để đảm bảo chỉ có một `GameControl` duy nhất trong toàn bộ game.",
                    "terms": {
                        "Singleton Pattern": "Một mẫu thiết kế phần mềm đảm bảo rằng một lớp chỉ có một thể hiện (instance) duy nhất và cung cấp một điểm truy cập toàn cục đến thể hiện đó. Rất phổ biến để tạo các đối tượng quản lý như GameManager, AudioManager."
                    }
                },
                {
                    "id": 7,
                    "title": "Trang 7: Tính bền bỉ - Lưu vào một File (1/3)",
                    "image": "images/game-dev/week7/slide_7.png",
                    "notes": "Làm thế nào bạn có thể lưu dữ liệu giữa các lần thực thi game? Một cách hay để làm điều đó là thông qua <b>Serialization</b>. Serialization là \"quá trình chuyển đổi một đối tượng thành một luồng byte để lưu trữ đối tượng đó hoặc truyền nó vào bộ nhớ, cơ sở dữ liệu hoặc một tệp\".\n\nTrong Unity, bạn có thể chỉ ra rằng một đối tượng có thể được serialize đơn giản bằng cách thêm `[Serializable]` vào trước định nghĩa class. Sau đó, bạn có thể tạo một class chứa tất cả thông tin trạng thái game mà bạn muốn lưu vào một tệp.",
                    "terms": {
                        "Serialization": "Quá trình chuyển đổi trạng thái của một đối tượng thành một định dạng (ví dụ: chuỗi, luồng byte) có thể được lưu trữ (vào tệp, bộ nhớ) hoặc truyền đi và sau đó được tái tạo lại. Đây là nền tảng của việc lưu và tải game."
                    }
                },
                {
                    "id": 8,
                    "title": "Trang 8: Tính bền bỉ - Lưu vào một File (2/3)",
                    "image": "images/game-dev/week7/slide_8.png",
                    "notes": "Slide này trình bày một kịch bản `GameControl` hoàn chỉnh hơn.\n\n- Một class `PlayerData` được định nghĩa với thuộc tính `[Serializable]` để chứa dữ liệu cần lưu (ví dụ: `health`).\n- Mẫu Singleton `GameControl` được sử dụng để đảm bảo chỉ có một instance duy nhất.\n- Các hàm `Save()` và `Load()` (chưa có nội dung) được tạo ra để xử lý logic lưu và tải dữ liệu.",
                    "terms": {
                        "BinaryFormatter": "Một lớp trong .NET dùng để serialize và deserialize một đối tượng (hoặc một đồ thị các đối tượng được kết nối) ở định dạng nhị phân. Dữ liệu nhị phân nhỏ gọn và khó đọc hơn so với văn bản, nhưng không được coi là an toàn."
                    }
                },
                {
                    "id": 9,
                    "title": "Trang 9: Tính bền bỉ - Lưu vào một File (3/3)",
                    "image": "images/game-dev/week7/slide_9.png",
                    "notes": "Đây là nội dung cho các hàm `Save()` và `Load()`:\n\n- <b>Hàm Save():</b>\n  1. Tạo đường dẫn tệp đầy đủ bằng cách sử dụng `Application.persistentDataPath`.\n  2. Tạo một `BinaryFormatter`.\n  3. Mở (hoặc tạo) một file bằng `FileStream`.\n  4. Tạo một instance của `PlayerData` và sao chép dữ liệu game hiện tại vào đó.\n  5. Dùng `bf.Serialize()` để ghi đối tượng `PlayerData` vào file.\n  6. Đóng file lại.\n\n- <b>Hàm Load():</b>\n  1. Kiểm tra xem file lưu có tồn tại không.\n  2. Nếu có, mở file và dùng `bf.Deserialize()` để đọc dữ liệu từ file và ép kiểu nó trở lại thành `PlayerData`.\n  3. Cập nhật trạng thái game hiện tại từ dữ liệu đã tải.",
                    "terms": {
                        "Application.persistentDataPath": "Một thuộc tính static trong Unity trả về một đường dẫn đến một thư mục nơi bạn có thể lưu trữ dữ liệu cần được giữ lại giữa các lần chạy game. Đường dẫn này khác nhau tùy theo hệ điều hành."
                    }
                },
                {
                    "id": 10,
                    "title": "Trang 10: Chuyển tiếp - Máy trạng thái hữu hạn & Animations",
                    "image": "images/game-dev/week7/slide_10.png",
                    "notes": "Kết thúc phần Tải và Lưu Dữ liệu.\n\nPhần tiếp theo sẽ giới thiệu về một mô hình lý thuyết quan trọng (Máy trạng thái hữu hạn) và cách nó được áp dụng trong hệ thống Animation của Unity.",
                    "terms": {}
                },
                {
                    "id": 11,
                    "title": "Trang 11: Máy trạng thái hữu hạn (1/2)",
                    "image": "images/game-dev/week7/slide_11.png",
                    "notes": "<b>Máy trạng thái hữu hạn (Finite State Machines - FSMs)</b> là một mô hình toán học được hình thành như một cỗ máy trừu tượng có thể ở trong một trong một số lượng hữu hạn các <b>trạng thái (states)</b>.\n\nCỗ máy chỉ ở trong một trạng thái tại một thời điểm; trạng thái đó được gọi là trạng thái hiện tại. Nó có thể thay đổi từ trạng thái này sang trạng thái khác khi được khởi xướng bởi một sự kiện hoặc điều kiện kích hoạt; điều này được gọi là một <b>sự chuyển đổi (transition)</b>.",
                    "terms": {
                        "Finite State Machine (FSM)": "Một mô hình tính toán bao gồm một tập hợp các trạng thái, một trạng thái bắt đầu, các điều kiện đầu vào, và một hàm chuyển đổi xác định trạng thái tiếp theo. Rất phổ biến trong lập trình game để quản lý AI, animation, và logic game."
                    }
                },
                {
                    "id": 12,
                    "title": "Trang 12: Máy trạng thái hữu hạn (2/2)",
                    "image": "images/game-dev/week7/slide_12.png",
                    "notes": "Các ưu và nhược điểm chính của FSMs:\n\n- <b>Ưu điểm:</b> Đơn giản để triển khai, dễ hình dung.\n- <b>Nhược điểm:</b> Mở rộng kém để xử lý logic phức tạp, không được thiết kế để đối phó với sự đồng thời (concurrency).\n\nChúng ta sẽ sử dụng FSMs cho hai khía cạnh khác nhau trong môn học này: hệ thống animation của Unity (bài giảng này) và Trí tuệ nhân tạo (bài giảng 9).",
                    "terms": {}
                },
                {
                    "id": 13,
                    "title": "Trang 13: Mecanim",
                    "image": "images/game-dev/week7/slide_13.png",
                    "notes": "<b>Mecanim</b> là Hệ thống Animation của Unity, cho phép thiết lập animation trên các nhân vật hình người, chuyển đổi giữa các animation, áp dụng animation từ mô hình nhân vật này sang mô hình khác, v.v.\n\nQuy trình làm việc trong Mecanim có thể được chia thành ba giai đoạn chính:\n1. <b>Chuẩn bị và nhập Asset:</b> Được thực hiện bởi các họa sĩ hoặc animator, với các công cụ của bên thứ ba như 3Ds Max hoặc Maya.\n2. <b>Thiết lập nhân vật:</b> Có thể là hình người (humanoid) hoặc chung (generic - sinh vật, đạo cụ hoạt hình, động vật bốn chân, v.v.).\n3. <b>Làm cho nhân vật sống động:</b> Thiết lập các clip animation, máy trạng thái, và scripting.",
                    "terms": {
                        "Mecanim": "Tên của hệ thống animation mạnh mẽ và linh hoạt của Unity. Nó bao gồm các công cụ để tạo và quản lý các animation clip, blend tree, và các máy trạng thái phức tạp (Animator Controllers).",
                        "Animation Clip": "Một asset animation trong Unity chứa dữ liệu về cách một hoặc nhiều thuộc tính của một đối tượng thay đổi theo thời gian (ví dụ: vị trí, góc xoay, màu sắc).",
                        "Humanoid Rig": "Một cấu trúc xương được tiêu chuẩn hóa trong Mecanim cho các nhân vật hình người. Sử dụng rig này cho phép bạn dễ dàng tái sử dụng các animation trên các mô hình nhân vật khác nhau."
                    }
                },
                {
                    "id": 14,
                    "title": "Trang 14: Animation Clips",
                    "image": "images/game-dev/week7/slide_14.png",
                    "notes": "<b>Animation Clips</b> có thể được tạo từ Project View hoặc từ cửa sổ Animation.\n\nCửa sổ Animation cho phép bạn tạo ra các animation bằng cách thay đổi các thuộc tính của một đối tượng theo thời gian và đặt các 'keyframe'.\n\nAnimation Clips luôn là một phần của một <b>Animator</b>. Hình ảnh bên dưới cho thấy một animation clip trông như thế nào khi nó được tạo ra, với các thuộc tính như độ dài, có lặp lại không...",
                    "terms": {
                        "Animation Window": "Một cửa sổ trong Unity Editor cho phép bạn tạo và chỉnh sửa các Animation Clip trực tiếp bằng cách ghi lại các thay đổi thuộc tính của một Game Object theo thời gian."
                    }
                },
                {
                    "id": 15,
                    "title": "Trang 15: The Animation View",
                    "image": "images/game-dev/week7/slide_15.png",
                    "notes": "Cửa sổ Animation hiển thị dòng thời gian (timeline) và các keyframe của animation cho đối tượng game hiện đang được chọn.\n\n- Bên trái, cửa sổ này hiển thị danh sách các thuộc tính được làm hoạt hình.\n- Bằng cách di chuyển vạch đỏ, bạn có thể xem các giá trị này.\n- Nếu chế độ ghi âm được nhấn, việc giới thiệu các giá trị mới sẽ tạo ra các keyframe mới tại thời điểm mà vạch đỏ được đặt.\n- Chế độ xem dòng thời gian có hai chế độ: 'Dope Sheet' và 'Curves'.",
                    "terms": {
                        "Keyframe": "Một điểm đánh dấu trên dòng thời gian animation, ghi lại giá trị của một thuộc tính tại một thời điểm cụ thể. Animation được tạo ra bằng cách nội suy các giá trị giữa các keyframe.",
                        "Dope Sheet": "Một chế độ xem trong Animation Window, hiển thị các keyframe dưới dạng các điểm kim cương trên một dòng thời gian ngang, giúp dễ dàng điều chỉnh thời gian của các sự kiện.",
                        "Curves View": "Một chế độ xem trong Animation Window, hiển thị sự thay đổi của các giá trị thuộc tính theo thời gian dưới dạng các đồ thị đường cong, cho phép kiểm soát chi tiết hơn về tốc độ và gia tốc của animation."
                    }
                },
                {
                    "id": 16,
                    "title": "Trang 16: The Animation Setup",
                    "image": "images/game-dev/week7/slide_16.png",
                    "notes": "Sơ đồ này tóm tắt cách các thành phần animation liên kết với nhau:\n\n1. <b>Animation Clip</b> (ví dụ: 'Cube Bouncing'): Chứa dữ liệu chuyển động (các keyframe).\n2. <b>Animator Controller</b> (ví dụ: 'Cube Animation Controller'): Một máy trạng thái (FSM) quản lý các animation clip và các chuyển đổi (transitions) giữa chúng. Animation Clip được kéo vào cửa sổ Animator để tạo ra một 'trạng thái' (state).\n3. <b>Animator Component:</b> Được gắn vào Game Object (ví dụ: 'Cube'). Nó lấy một Animator Controller làm đầu vào và sử dụng nó để điều khiển các animation trên đối tượng đó.",
                    "terms": {
                        "Animator Controller": "Một asset trong Unity cho phép bạn sắp xếp và quản lý một tập hợp các animation clip và các chuyển đổi giữa chúng cho một nhân vật hoặc đối tượng. Về cơ bản, nó là một máy trạng thái hữu hạn cho các animation.",
                        "Animator Component": "Component được gắn vào một Game Object để gán một Animator Controller cho nó, từ đó làm cho đối tượng đó có thể được diễn hoạt."
                    }
                },
                {
                    "id": 17,
                    "title": "Trang 17: Component Animator",
                    "image": "images/game-dev/week7/slide_17.png",
                    "notes": "Component <b>Animator</b> cho phép diễn hoạt các thuộc tính của các đối tượng game trong Unity (thay đổi một số giá trị của chúng theo thời gian).\n\n- <b>Controller:</b> Tham chiếu đến một asset Animator Controller.\n- <b>Avatar:</b> Một asset được Unity tạo ra khi một mô hình 3D hình người (humanoid) được nhập vào. Nó liên kết mô hình sẽ được diễn hoạt với animator.",
                    "terms": {
                        "Avatar (in Mecanim)": "Một asset trung gian dùng để ánh xạ (map) một cấu trúc xương cụ thể của một mô hình với cấu trúc xương Humanoid chuẩn của Unity. Avatar là thứ cho phép các animation có thể được tái sử dụng trên các nhân vật khác nhau."
                    }
                },
                {
                    "id": 18,
                    "title": "Trang 18: Component Animator (Tiếp theo)",
                    "image": "images/game-dev/week7/slide_18.png",
                    "notes": "Các thuộc tính quan trọng khác của component Animator:\n\n- <b>Apply Root Motion:</b> Xác định xem animation có thể ảnh hưởng đến Transform của đối tượng được diễn hoạt hay không, hay điều này nên được kiểm soát từ script. Nên bật nếu animation di chuyển mô hình, và tắt nếu animation xảy ra tại chỗ.\n- <b>Update Mode:</b> Xác định xem animation nên được thực thi đồng bộ với engine vật lý (`Animate Physics`), với thời gian không bị co giãn (`Unscaled Time`), hay bình thường.\n- <b>Culling Mode:</b> Cho biết animation có nên được phát khi chúng không được render hay không. `Always Animate` sẽ luôn phát animation. `Based On Renderers` chỉ diễn hoạt nhân vật nếu nó đang được render (tiết kiệm hiệu suất).",
                    "terms": {
                        "Root Motion": "Chuyển động của toàn bộ nhân vật được điều khiển bởi chính animation clip, thay vì bằng script. Ví dụ, một animation bước đi sẽ thực sự đẩy nhân vật về phía trước trong thế giới game."
                    }
                },
                {
                    "id": 19,
                    "title": "Trang 19: Animator Controller",
                    "image": "images/game-dev/week7/slide_19.png",
                    "notes": "<b>Animator Controllers</b> chứa một hoặc nhiều máy trạng thái (state machines) xác định các animation nào đang được phát và cách chúng hòa trộn (blends) với nhau.\n\nCửa sổ Animator Controller chứa các layer animation, các tham số animation và máy trạng thái.",
                    "terms": {
                        "Animator Controller Window": "Một cửa sổ đồ họa trong Unity nơi bạn xây dựng và chỉnh sửa Animator Controller. Bạn có thể tạo các trạng thái, định nghĩa các tham số, và thiết lập các chuyển đổi giữa chúng bằng cách kéo thả và nối các đường dẫn."
                    }
                },
                {
                    "id": 20,
                    "title": "Trang 20: Các Trạng thái Animation (1/2)",
                    "image": "images/game-dev/week7/slide_20.png",
                    "notes": "<b>Animation States</b> là các khối xây dựng của máy trạng thái. Chúng chứa animation (hoặc blend tree) sẽ được phát khi máy trạng thái ở trong trạng thái đó.\n\nCác trạng thái animation được kiểm soát bởi các tham số (parameters) nhận giá trị của chúng từ script. Sự thay đổi trong các tham số này được dùng để kích hoạt các chuyển đổi (transitions) sang các trạng thái khác nhau.\n\nCó ba trạng thái đặc biệt:\n- <b>Entry (màu xanh lá):</b> Điểm bắt đầu của máy trạng thái.\n- <b>Default State (màu cam):</b> Trạng thái mà máy sẽ ở trong khi được kích hoạt lần đầu tiên.\n- <b>Any State (màu xanh dương):</b> Một trạng thái đặc biệt, luôn hiện diện, được dùng để biểu diễn các chuyển đổi phải xảy ra từ bất kỳ trạng thái nào.",
                    "terms": {
                        "Animation State": "Một nút trong Animator Controller đại diện cho một animation clip hoặc một blend tree. Một nhân vật luôn ở trong một trạng thái tại một thời điểm.",
                        "Parameters (Animator)": "Các biến (Float, Int, Bool, Trigger) mà bạn định nghĩa trong Animator Controller để kiểm soát các chuyển đổi giữa các trạng thái. Giá trị của chúng được thiết lập từ script."
                    }
                },
                {
                    "id": 21,
                    "title": "Trang 21: Các Trạng thái Animation (2/2)",
                    "image": "images/game-dev/week7/slide_21.png",
                    "notes": "Nếu bạn nhấp vào một trạng thái animation, bạn có thể thấy các thuộc tính của nó trong bảng Inspector:\n\n- <b>Name</b> và <b>Tag</b> có thể được chỉ định cho trạng thái cụ thể này.\n- <b>Speed:</b> Tốc độ mà animation được phát. 1 là tốc độ bình thường.\n- <b>Motion:</b> Animation clip hoặc blend tree cho trạng thái.\n- <b>Foot IK:</b> Inverse Kinematics cho bàn chân, để loại bỏ, nếu được chọn, bất kỳ sự trượt chân nào trong animation.\n- <b>Mirror:</b> Lật animation từ trái sang phải.",
                    "terms": {
                        "Foot IK (Inverse Kinematics)": "Một tính năng của Mecanim cho phép hệ thống tự động điều chỉnh chân và bàn chân của nhân vật để chúng đặt đúng trên các bề mặt không bằng phẳng, giúp animation trông tự nhiên hơn."
                    }
                },
                {
                    "id": 22,
                    "title": "Trang 22: Máy trạng thái con (Sub-State Machines)",
                    "image": "images/game-dev/week7/slide_22.png",
                    "notes": "Thông thường một nhân vật có những hành động phức tạp bao gồm một số giai đoạn. Thay vì xử lý toàn bộ hành động bằng một trạng thái duy nhất, sẽ hợp lý hơn nếu xác định các giai đoạn riêng biệt và sử dụng một trạng thái riêng cho mỗi giai đoạn.\n\nCó thể thu gọn một nhóm các trạng thái thành một mục có tên duy nhất trong sơ đồ máy trạng thái. Các nhóm trạng thái được thu gọn này được gọi là <b>máy trạng thái con (sub-state machines)</b>.",
                    "terms": {
                        "Sub-State Machine": "Một máy trạng thái được lồng vào bên trong một máy trạng thái khác. Chúng rất hữu ích để tổ chức và đơn giản hóa các Animator Controller phức tạp bằng cách nhóm các trạng thái có liên quan lại với nhau (ví dụ: một sub-state machine cho tất cả các hành động chiến đấu)."
                    }
                },
                {
                    "id": 23,
                    "title": "Trang 23: Chuyển đổi Animation (1/2)",
                    "image": "images/game-dev/week7/slide_23.png",
                    "notes": "<b>Animation Transitions</b> định nghĩa những gì xảy ra khi bạn chuyển từ một Animation State này sang một cái khác. Chỉ có thể có một transition hoạt động tại bất kỳ thời điểm nào trong một máy trạng thái.\n\nĐối với mỗi transition, có hai nút kiểm tra:\n- <b>Solo:</b> Nếu được chọn, nó sẽ vô hiệu hóa tất cả các animation khác từ trạng thái gốc, ngoại trừ những cái cũng được đánh dấu là Solo.\n- <b>Mute:</b> Vô hiệu hóa animation một cách hiệu quả.\n\nHai nút kiểm tra này chỉ nên được sử dụng để gỡ lỗi (debug).",
                    "terms": {
                        "Animation Transition": "Một liên kết giữa hai trạng thái trong Animator Controller, định nghĩa cách hệ thống hòa trộn (blend) từ animation này sang animation khác. Các transition được điều khiển bởi các điều kiện (Conditions) dựa trên các tham số (Parameters)."
                    }
                },
                {
                    "id": 24,
                    "title": "Trang 24: Chuyển đổi Animation (2/2)",
                    "image": "images/game-dev/week7/slide_24.png",
                    "notes": "Có ba phần chính trong bảng điều khiển Animation Transition:\n\n- <b>Has Exit Time:</b> Nếu được đánh dấu, transition sẽ xảy ra khi animation của trạng thái trước đó kết thúc. <b>Exit Time</b> và các cài đặt khác có thể được sử dụng để tinh chỉnh transition này.\n- <b>Conditions (Điều kiện):</b> Quyết định khi nào transition được kích hoạt, cho phép dựa vào các giá trị tham số (những cái được kiểm soát thông qua script).\n- <b>A Preview window:</b> Cửa sổ xem trước cho thấy transition trông như thế nào trên mô hình.",
                    "terms": {
                        "Has Exit Time": "Một cài đặt trên một transition. Nếu bật, transition sẽ chỉ có thể xảy ra sau khi animation của trạng thái hiện tại đã phát được một khoảng thời gian nhất định (được xác định bởi 'Exit Time'). Nếu tắt, transition có thể xảy ra bất cứ lúc nào miễn là các điều kiện (Conditions) của nó được đáp ứng."
                    }
                },
                {
                    "id": 25,
                    "title": "Trang 25: Animation Parameters",
                    "image": "images/game-dev/week7/slide_25.png",
                    "notes": "<b>Animation Parameters</b> là các biến được định nghĩa bên trong hệ thống animation và có thể được truy cập cũng như gán giá trị từ các script. Các tham số có thể thuộc 4 loại khác nhau:\n\n- <b>Integer, Float, Bool:</b> Các kiểu dữ liệu số và boolean thông thường.\n- <b>Trigger:</b> Một tham số boolean được controller tự động reset lại sau khi nó được sử dụng bởi một transition.\n\nCác tham số có thể được gán giá trị từ một script bằng cách sử dụng các hàm trong lớp Animator như `SetTrigger`, `SetFloat`, `SetInt` và `SetBool`.",
                    "terms": {
                        "Trigger (Parameter)": "Một loại tham số không có trạng thái, giống như một sự kiện. Khi được kích hoạt từ script (`SetTrigger`), nó sẽ gây ra một transition và ngay lập tức tự reset. Rất hữu ích cho các hành động xảy ra một lần như tấn công hoặc nhảy."
                    }
                },
                {
                    "id": 26,
                    "title": "Trang 26: Chuyển tiếp - Blending Animations",
                    "image": "images/game-dev/week7/slide_26.png",
                    "notes": "Kết thúc phần giới thiệu về các trạng thái và chuyển đổi cơ bản.\n\nPhần tiếp theo sẽ tập trung vào một kỹ thuật mạnh mẽ để tạo ra các chuyển động phức tạp và mượt mà hơn: Blending Animations (Pha trộn Animations).",
                    "terms": {}
                },
                {
                    "id": 27,
                    "title": "Trang 27: Blend Trees",
                    "image": "images/game-dev/week7/slide_27.png",
                    "notes": "<b>Blend trees</b> được dùng để pha trộn giữa hai hoặc nhiều chuyển động tương tự nhau. Các ví dụ điển hình là pha trộn giữa các animation đi bộ và chạy theo tốc độ của nhân vật, hoặc một nhân vật nghiêng sang trái hoặc phải khi anh ta rẽ trong lúc chạy.\n\nSự khác biệt giữa transitions và blend trees:\n- <b>Transitions:</b> Dùng để chuyển đổi mượt mà từ một Animation State này sang một cái khác.\n- <b>Blend Trees:</b> Dùng để cho phép nhiều animation được pha trộn mượt mà bằng cách kết hợp các phần của chúng ở các mức độ khác nhau. Mức độ đóng góp của mỗi chuyển động vào hiệu ứng cuối cùng được kiểm soát bằng một tham số pha trộn.",
                    "terms": {
                        "Blend Tree": "Một loại trạng thái đặc biệt trong Animator Controller cho phép bạn pha trộn nhiều animation clip với nhau dựa trên giá trị của một hoặc nhiều tham số. Rất hữu ích để tạo ra các chuyển động liền mạch như đi bộ/chạy ở các tốc độ khác nhau hoặc nghiêng người khi rẽ."
                    }
                },
                {
                    "id": 28,
                    "title": "Trang 28: Blend Trees - 1D",
                    "image": "images/game-dev/week7/slide_28.png",
                    "notes": "<b>Blend Tree 1 chiều (1-Dimensional)</b> pha trộn giữa các chuyển động bằng cách sử dụng <b>một</b> tham số. Trong ví dụ này, blend tree pha trộn giữa các animation Chạy (Run), Chạy Phải (RunRight) / Chạy Trái (RunLeft) bằng cách sử dụng tham số `Direction`.\n\nDanh sách các chuyển động chứa các animation khác nhau để pha trộn. Mỗi animation có một `animation clip`, một `threshold` (ngưỡng - giá trị của tham số được sử dụng để bắt đầu/kết thúc việc pha trộn), và một `speed`.",
                    "terms": {
                        "1D Blend Tree": "Một loại Blend Tree sử dụng một tham số duy nhất để pha trộn giữa hai hoặc nhiều animation. Thường được dùng để kiểm soát tốc độ (ví dụ: chuyển từ Đứng yên -> Đi bộ -> Chạy)."
                    }
                },
                {
                    "id": 29,
                    "title": "Trang 29: Blend Trees - 2D (1/2)",
                    "image": "images/game-dev/week7/slide_29.png",
                    "notes": "<b>Blend Tree 2 chiều (2-Dimensional)</b> pha trộn giữa các chuyển động bằng cách sử dụng <b>hai</b> tham số.\n\nTrong ví dụ này, blend tree pha trộn giữa năm animation: Đứng yên (Idle), Đi tới (Walk Forward), Đi lùi (Walk Backwards), Đi ngang sang trái (Walk Strafe Left) và Đi ngang sang phải (Walk Strafe Right).\n\nNó sử dụng các tham số `VelocityX` và `VelocityZ` để pha trộn giữa các animation này.",
                    "terms": {
                        "2D Blend Tree": "Một loại Blend Tree sử dụng hai tham số để pha trộn giữa nhiều animation được sắp xếp trên một mặt phẳng 2D. Rất hữu ích cho việc tạo ra các chuyển động đa hướng (ví dụ: đi bộ/chạy theo mọi hướng)."
                    }
                },
                {
                    "id": 30,
                    "title": "Trang 30: Blend Trees - 2D (2/2)",
                    "image": "images/game-dev/week7/slide_30.png",
                    "notes": "Sơ đồ Pha trộn 2D (2D Blending Diagram) hiển thị mỗi chuyển động được miêu tả bằng một chấm màu xanh. Chấm màu đỏ cho biết các giá trị của hai tham số hiện tại.\n\n- Các vòng tròn xung quanh các chuyển động gần đó cho biết sức ảnh hưởng (trọng số) của những chuyển động đó tại các giá trị tham số hiện tại.\n- Vùng màu xanh xung quanh chuyển động được chọn cho biết sức ảnh hưởng (trọng số) của chuyển động đó cho mỗi điểm trong không gian pha trộn.",
                    "terms": {}
                },
                {
                    "id": 31,
                    "title": "Trang 31: Humanoid Avatars",
                    "image": "images/game-dev/week7/slide_31.png",
                    "notes": "<b>Avatars</b> là các hệ thống định nghĩa cho biết hệ thống animation cách diễn hoạt các transform của một mô hình. Bạn có thể cấu hình avatar bằng cách nhấp vào mesh của mô hình và đi đến tab 'Rig'.\n\nNếu bạn nhấp vào 'Configure Avatar', bạn có thể cấu hình avatar cho humanoid của mình. Điều này cho phép:\n- <b>Mapping:</b> Ánh xạ giữa các xương và các transform.\n- <b>Muscles:</b> Phạm vi chuyển động của các xương của avatar.",
                    "terms": {
                        "Avatar (in Mecanim)": "Một asset trung gian dùng để ánh xạ (map) một cấu trúc xương cụ thể của một mô hình với cấu trúc xương Humanoid chuẩn của Unity. Avatar là thứ cho phép các animation có thể được tái sử dụng trên các nhân vật khác nhau."
                    }
                },
                {
                    "id": 32,
                    "title": "Trang 32: Animator Controller Layers (1/2)",
                    "image": "images/game-dev/week7/slide_32.png",
                    "notes": "<b>Animator Layers</b> được sử dụng để quản lý các máy trạng thái phức tạp, nhằm diễn hoạt các bộ phận cụ thể của cơ thể. Ví dụ, bạn có thể có một layer cơ sở chăm sóc cho việc di chuyển của avatar, và một layer thứ hai chăm sóc cho việc bắn súng.\n\nMỗi layer có thể đang phát một animation khác nhau cùng một lúc; cả hai được pha trộn tùy thuộc vào cách các layer được cấu hình.\n\nTheo mặc định, tất cả các controller đều có một <b>Base Layer</b> nơi bạn có thể đặt các trạng thái và transition của mình.",
                    "terms": {
                        "Animator Layer": "Cho phép bạn quản lý các animation cho các bộ phận cơ thể khác nhau một cách độc lập. Ví dụ, một layer có thể điều khiển chân (đi bộ/chạy) trong khi một layer khác điều khiển phần thân trên (bắn súng, vung kiếm)."
                    }
                },
                {
                    "id": 33,
                    "title": "Trang 33: Animator Controller Layers (2/2)",
                    "image": "images/game-dev/week7/slide_33.png",
                    "notes": "Có thể chỉ định một số tham số cho mỗi layer:\n\n- <b>Name:</b> Tên của layer.\n- <b>Weight (Trọng số):</b> Mức độ layer ảnh hưởng đến animation cuối cùng. 0 có nghĩa là layer sẽ không ảnh hưởng, trong khi giá trị 1 sẽ chiếm toàn bộ ưu tiên.\n- <b>Mask:</b> Một Avatar Mask được dùng để cô lập các bộ phận cơ thể cho animation.\n- <b>Blending (Pha trộn):</b> Hai loại khác nhau:\n  - <b>Override:</b> Animation của layer này ghi đè lên animation của layer bên dưới.\n  - <b>Additive:</b> Animation được cộng thêm vào animation của layer bên dưới, được gia trọng bởi tham số `Weight`.",
                    "terms": {
                        "Avatar Mask": "Một asset cho phép bạn chỉ định các bộ phận cơ thể (đầu, tay, chân...) sẽ bị ảnh hưởng bởi một layer animation. Rất hữu ích để tạo các animation chỉ ảnh hưởng đến phần thân trên (ví dụ: vẫy tay trong khi đang đi bộ)."
                    }
                },
                {
                    "id": 34,
                    "title": "Trang 34: Avatar/Body Masks",
                    "image": "images/game-dev/week7/slide_34.png",
                    "notes": "Các bộ phận cơ thể cụ thể có thể được bật hoặc tắt một cách chọn lọc trong một animation bằng cách sử dụng một thứ gọi là <b>Body Mask</b>.\n\nBạn có thể nhấp vào phần avatar để chuyển đổi giữa việc bao gồm (màu xanh) hoặc loại trừ (màu đỏ). Ví dụ, nếu chỉ có cánh tay trái của một layer ghi đè có màu xanh, thì chỉ các xương và transform của cánh tay trái sẽ bị sửa đổi bởi animation của layer này. Phần còn lại của cơ thể sẽ được quyết định bởi animation trong base layer.",
                    "terms": {}
                },
                {
                    "id": 35,
                    "title": "Trang 35: The Animator Controller (Tổng quan)",
                    "image": "images/game-dev/week7/slide_35.png",
                    "notes": "Sơ đồ này tóm tắt lại toàn bộ quy trình làm việc với Animator:\n\n1. <b>Animation Clips:</b> Các asset chứa dữ liệu chuyển động, thường được nhập cùng với mô hình 3D.\n2. <b>Animator Controller:</b> Asset chứa máy trạng thái. Các Animation Clip được kéo vào đây để tạo thành các trạng thái (ví dụ: `Jumping`, `Grounded`, `Die`).\n3. <b>Avatar:</b> Asset định nghĩa cấu trúc xương của mô hình, giúp Mecanim hiểu cách áp dụng animation.\n4. <b>Animator Component:</b> Được gắn vào Game Object trong Scene. Nó kết nối Animator Controller và Avatar với mô hình để thực hiện diễn hoạt.",
                    "terms": {}
                },
                {
                    "id": 36,
                    "title": "Trang 36: Chuyển tiếp - Animation Scripting",
                    "image": "images/game-dev/week7/slide_36.png",
                    "notes": "Kết thúc phần giới thiệu về Blend Trees và các thành phần của Animator.\n\nPhần tiếp theo sẽ tập trung vào cách điều khiển Animator Controller từ script.",
                    "terms": {}
                },
                {
                    "id": 37,
                    "title": "Trang 37: Ví dụ về Animation Scripting (1/2)",
                    "image": "images/game-dev/week7/slide_37.png",
                    "notes": "Đây là một ví dụ về một Animator Controller đơn giản với ba trạng thái: `Idle` (Đứng yên), `Run` (Chạy), `Jump` (Nhảy), và bốn tham số.\n\nCác transition được thiết lập như sau:\n- <b>Idle → Run:</b> Khi `Float Speed > 0.1`.\n- <b>Run → Idle:</b> Khi `Float Speed < 0.1`.\n- <b>Run → Jump:</b> Khi `Trigger Jump` được kích hoạt (`true`).\n- <b>Jump → Run:</b> Khi animation `Jump` đã kết thúc (Exit Time tại 0.90).",
                    "terms": {}
                },
                {
                    "id": 38,
                    "title": "Trang 38: Ví dụ về Animation Scripting (2/2)",
                    "image": "images/game-dev/week7/slide_38.png",
                    "notes": "Đoạn mã này minh họa cách điều khiển Animator Controller ở trên từ script:\n\n- <b>Dòng 2-6:</b> Sử dụng `Animator.StringToHash()` để chuyển đổi tên của các tham số thành một giá trị 'hash' (số nguyên). Việc thay đổi tham số thông qua hash sẽ hiệu quả hơn so với việc dùng chuỗi trực tiếp.\n- <b>Dòng 10:</b> Lấy tham chiếu đến component Animator trong `Start()`.\n- <b>Dòng 15-21:</b> Trong `Update()`, kiểm tra xem trạng thái hiện tại có phải là 'Run' hay không. Nếu đúng và người dùng nhấn 'Fire1', kích hoạt trigger 'Jump'.\n- <b>Dòng 26-29:</b> Lấy giá trị từ các trục 'Horizontal' và 'Vertical' của Input, sau đó sử dụng chúng để thiết lập giá trị cho tham số 'Speed' và 'Direction' của animator.",
                    "terms": {
                        "Animator.StringToHash()": "Một hàm tối ưu hóa hiệu suất, chuyển đổi một tên chuỗi (của trạng thái hoặc tham số) thành một ID số nguyên. Việc sử dụng các hàm Set/Get với ID số nguyên sẽ nhanh hơn đáng kể so với việc sử dụng tên chuỗi ở mỗi frame."
                    }
                },
                {
                    "id": 39,
                    "title": "Trang 39: Lớp Animator",
                    "image": "images/game-dev/week7/slide_39.png",
                    "notes": "Các hàm hữu ích của lớp Animator:\n\n- <b>Animator.StringToHash:</b> Tạo ra một id tham số từ một chuỗi.\n- <b>GetBool, GetFloat, GetInteger:</b> Lấy giá trị của các tham số.\n- <b>SetBool, SetFloat, SetInteger, SetTrigger:</b> Thiết lập giá trị của các tham số.\n- <b>ResetTrigger:</b> Reset một tham số trigger.\n- <b>SetLayerWeight:</b> Thiết lập trọng số hiện tại của layer.\n- <b>GetCurrentAnimatorStateInfo:</b> Lấy thông tin về trạng thái hiện tại trên một layer Animator Controller được chỉ định.\n- <b>GetAnimatorTransitionInfo:</b> Lấy thông tin về transition hiện tại trên một layer.",
                    "terms": {}
                },
                {
                    "id": 40,
                    "title": "Trang 40: Các Struct AnimatorStateInfo và AnimatorTransitionInfo",
                    "image": "images/game-dev/week7/slide_40.png",
                    "notes": "<b>AnimatorStateInfo:</b> Chứa thông tin về trạng thái hiện tại hoặc trạng thái tiếp theo.\n- <b>length:</b> Thời lượng hiện tại của trạng thái.\n- <b>loop:</b> Trạng thái có đang lặp lại không.\n- <b>nameHash:</b> Tên hash của trạng thái.\n- <b>normalizedTime:</b> Thời gian đã được chuẩn hóa của trạng thái (phần nguyên là số lần lặp, phần thập phân là tiến trình trong lần lặp hiện tại).\n\n<b>AnimatorTransitionInfo:</b> Chứa thông tin về transition hiện tại.\n- <b>fullPathHash:</b> Tên hash duy nhất của transition.\n- <b>normalizedTime:</b> Thời gian đã được chuẩn hóa của transition.",
                    "terms": {
                        "normalizedTime": "Một giá trị float cho biết tiến trình của một animation state hoặc transition. Giá trị 0.0 có nghĩa là bắt đầu, 0.5 là giữa, và 1.0 là kết thúc."
                    }
                },
                {
                    "id": 41,
                    "title": "Trang 41: Chuyển tiếp - Câu hỏi & Demo Lab",
                    "image": "images/game-dev/week7/slide_41.png",
                    "notes": "Kết thúc phần lý thuyết về Animation Scripting.\n\nPhần cuối cùng sẽ là các câu hỏi kiểm tra và xem trước nội dung buổi thực hành (Lab).",
                    "terms": {}
                },
                {
                    "id": 42,
                    "title": "Trang 42: Xem trước Buổi thực hành",
                    "image": "images/game-dev/week7/slide_42.png",
                    "notes": "Chúng ta sẽ bắt đầu buổi lab thứ 4: Animations và AI.\n\nBài giảng tiếp theo: <b>Steering Behaviours and Navigation.</b>",
                    "terms": {}
                }
            ]
        },
        {
            "title": "Tuần 8: Steering and Navigation",
            "slides": [
                {
                    "id": 1,
                    "title": "Trang 1: Bìa - Steering and Navigation",
                    "image": "images/game-dev/week8/slide_1.png",
                    "notes": "Bài giảng 8: Các Hành vi Lèo lái và Điều hướng.\n\nTuần này, chúng ta sẽ khám phá các thuật toán giúp các nhân vật tự trị (autonomous characters) di chuyển một cách thông minh và chân thực trong thế giới game.",
                    "terms": {}
                },
                {
                    "id": 2,
                    "title": "Trang 2: Đề cương bài giảng",
                    "image": "images/game-dev/week8/slide_2.png",
                    "notes": "Nội dung chính của bài giảng Tuần 8 bao gồm:\n\n1. <b>Các Hành vi Lèo lái cho các Nhân vật Tự trị.</b>\n2. <b>Tìm đường (Pathfinding).</b>\n3. <b>Lưới Điều hướng (Navigation Meshes) trong Unity.</b>\n4. <b>Câu hỏi ôn tập và Xem trước buổi thực hành.</b>",
                    "terms": {}
                },
                {
                    "id": 3,
                    "title": "Trang 3: Chuyển tiếp - Steering Behaviours",
                    "image": "images/game-dev/week8/slide_3.png",
                    "notes": "Chuẩn bị vào phần đầu tiên: Các Hành vi Lèo lái (Steering Behaviours) cho các nhân vật tự trị.",
                    "terms": {}
                },
                {
                    "id": 4,
                    "title": "Trang 4: Giới thiệu Steering Behaviours",
                    "image": "images/game-dev/week8/slide_4.png",
                    "notes": "<b>Các hành vi lèo lái (Steering behaviours)</b> nhằm mục đích giúp các nhân vật tự trị di chuyển một cách chân thực, bằng cách sử dụng các lực đơn giản được kết hợp để tạo ra sự điều hướng ngẫu hứng, giống như thật xung quanh môi trường của nhân vật.\n\nChúng không dựa trên các chiến lược phức tạp liên quan đến việc lập kế hoạch đường đi hoặc các tính toán toàn cục, mà thay vào đó sử dụng thông tin cục bộ, chẳng hạn như lực của các 'hàng xóm'. Điều này làm cho chúng đơn giản để hiểu và triển khai, nhưng vẫn có thể tạo ra các mẫu chuyển động rất phức tạp.",
                    "terms": {
                        "Steering Behaviours": "Một tập hợp các thuật toán AI giúp các tác tử (agents) di chuyển một cách tự nhiên trong môi trường của chúng. Thay vì tính toán một đường đi hoàn chỉnh, chúng hoạt động dựa trên các lực đơn giản (như tìm kiếm, trốn chạy, lang thang) để tạo ra chuyển động linh hoạt.",
                        "Autonomous Characters (Agents)": "Các nhân vật trong game (thường là NPC) có khả năng tự đưa ra quyết định và hành động mà không cần sự điều khiển trực tiếp từ người chơi."
                    }
                },
                {
                    "id": 5,
                    "title": "Trang 5: Hướng (Orientation)",
                    "image": "images/game-dev/week8/slide_5.png",
                    "notes": "Kịch bản: nhân vật trong hình ảnh muốn thay đổi hướng của mình để đối mặt với mục tiêu.\n\nĐể làm được điều này, chúng ta cần tính toán vector `d` từ nhân vật đến mục tiêu. Sau đó, chuẩn hóa vector `d` để có được vector đơn vị `đu` chỉ hướng tới mục tiêu.\n\nHướng mới (tính bằng radian) có thể được tính bằng hàm `arc tangent` hoặc bằng `arc cosine` của tích vô hướng giữa vector `Up` của nhân vật và vector `đu`.",
                    "terms": {
                        "Orientation": "Hướng mà một đối tượng đang đối mặt trong không gian. Trong không gian 2D, nó có thể được biểu diễn bằng một góc duy nhất. Trong 3D, nó thường được biểu diễn bằng góc Euler hoặc Quaternion."
                    }
                },
                {
                    "id": 6,
                    "title": "Trang 6: Chuyển động và Hướng",
                    "image": "images/game-dev/week8/slide_6.png",
                    "notes": "Chuyển động có thể được thực hiện bằng cách thêm một vector vận tốc `v` vào vị trí hiện tại `c`.\n\nThông thường, sự thay đổi này được nhân với một hệ số thời gian. Giả sử `Δt` là thời gian giữa hai lần gọi liên tiếp đến một hàm cập nhật (ví dụ: `Time.deltaTime`), vị trí mới có thể được xác định bằng công thức `c(t+1) = c(t) + (v * Δt)`.\n\nTrong code, chúng ta có thể cập nhật vị trí và hướng của một tác tử bằng cách lấy vận tốc mong muốn từ hành vi (`behaviour.Move(target)`) và cộng nó vào vị trí hiện tại, nhân với `Time.deltaTime`.",
                    "terms": {}
                },
                {
                    "id": 7,
                    "title": "Trang 7: Các loại Steering Behaviours",
                    "image": "images/game-dev/week8/slide_7.png",
                    "notes": "Một số hành vi lèo lái phổ biến:\n\n- <b>Seek (Tìm kiếm):</b> Lèo lái nhân vật về phía một vị trí được chỉ định.\n- <b>Flee (Trốn chạy):</b> Ngược lại của Seek.\n- <b>Arrival (Đến nơi):</b> Giống như Seek, nhưng giảm tốc khi đến gần mục tiêu.\n- <b>Wander (Lang thang):</b> Một hành vi lèo lái ngẫu nhiên 'thú vị'.\n- <b>Pursuit (Truy đuổi):</b> Giống như Seek nhưng mục tiêu là một đối tượng đang di chuyển.\n- <b>Evade (Né tránh):</b> Tương tự như Pursuit, nhưng sử dụng Flee để lèo lái ra xa khỏi vị trí tương lai được dự đoán của mục tiêu.\n\nCác khái niệm khác:\n- <b>Flocking (Bầy đàn).</b>\n- <b>Obstacle/Wall Prediction and Avoidance (Dự đoán và Tránh chướng ngại vật/tường).</b>",
                    "terms": {
                        "Seek": "Một hành vi lèo lái cơ bản tính toán một lực hướng thẳng đến một mục tiêu. Nhân vật sẽ cố gắng di chuyển đến mục tiêu nhanh nhất có thể.",
                        "Flee": "Ngược lại của Seek. Tính toán một lực hướng thẳng ra xa khỏi một mục tiêu.",
                        "Arrival": "Một phiên bản cải tiến của Seek. Khi nhân vật đến gần mục tiêu, nó sẽ giảm tốc một cách mượt mà và dừng lại chính xác tại mục tiêu mà không bị 'vọt lố'."
                    }
                },
                {
                    "id": 8,
                    "title": "Trang 8: Seek (1/2)",
                    "image": "images/game-dev/week8/slide_8.png",
                    "notes": "<b>Seek</b> (hay truy đuổi một mục tiêu tĩnh) hoạt động để lèo lái nhân vật về phía một vị trí được chỉ định trong không gian toàn cục. Hành vi này điều chỉnh nhân vật sao cho vận tốc của nó được căn chỉnh xuyên tâm về phía mục tiêu.\n\nLưu ý rằng điều này khác với một lực hấp dẫn (như trọng lực) sẽ tạo ra một đường đi quỹ đạo <i>xung quanh</i> điểm mục tiêu.",
                    "terms": {}
                },
                {
                    "id": 9,
                    "title": "Trang 9: Seek (2/2)",
                    "image": "images/game-dev/week8/slide_9.png",
                    "notes": "Hàm `seek()` tính toán một 'lực lèo lái' (steering force) để hướng về phía mục tiêu:\n1. <b>Tính Vận tốc Mong muốn (Desired Velocity):</b> Đây là vector chỉ từ vị trí hiện tại đến vị trí mục tiêu.\n2. <b>Chuẩn hóa và Điều chỉnh tốc độ:</b> Chuẩn hóa vector vận tốc mong muốn (để nó chỉ còn là hướng) và sau đó nhân với tốc độ tối đa (`speed`).\n3. <b>Tính Lực lèo lái (Steering Force):</b> Lực lèo lái là sự khác biệt giữa vận tốc mong muốn và vận tốc hiện tại (`currentVelocity`).\n\nTrong `FixedUpdate()`, lực lèo lái này được thêm vào vận tốc hiện tại (có tính đến khối lượng) và sau đó vận tốc mới được áp dụng cho Rigidbody của đối tượng.",
                    "terms": {}
                },
                {
                    "id": 10,
                    "title": "Trang 10: Flee",
                    "image": "images/game-dev/week8/slide_10.png",
                    "notes": "Hành vi <b>Flee (Trốn chạy)</b> là phiên bản đảo ngược của Seek. Nó hoạt động theo logic tương tự, nhưng Vận tốc Mong muốn (Desired Velocity) được tính toán theo hướng ngược lại:\n\n`desiredVelocity = rigidbody.position - target.position;`\n\nKết quả là lực lèo lái sẽ đẩy nhân vật ra xa khỏi mục tiêu.",
                    "terms": {}
                },
                {
                    "id": 11,
                    "title": "Trang 11: Arrival (1/2)",
                    "image": "images/game-dev/week8/slide_11.png",
                    "notes": "Hành vi <b>Arrival (Đến nơi)</b> giống hệt với Seek, nhưng thay vì di chuyển đến mục tiêu với tốc độ tối đa, nhân vật sẽ giảm tốc khi đến gần mục tiêu.\n\n- Vận tốc được giảm tuyến tính về 0 khi ở bên trong 'vùng giảm tốc' (slowing area).\n- Điều này đạt được bằng cách thêm một thành phần lèo lái mới (arrival).",
                    "terms": {}
                },
                {
                    "id": 12,
                    "title": "Trang 12: Arrival (2/2)",
                    "image": "images/game-dev/week8/slide_12.png",
                    "notes": "Hàm `arrival()` sửa đổi hành vi Seek bằng cách tính toán một `reducedSpeed` (tốc độ đã giảm).\n\n- Nó xác định một `rampedSpeed` dựa trên khoảng cách đến mục tiêu: càng gần, tốc độ càng chậm.\n- `reducedSpeed` sẽ là giá trị nhỏ hơn giữa `speed` (tốc độ tối đa) và `rampedSpeed`.\n- Vận tốc Mong muốn sau đó được tính toán bằng cách sử dụng `reducedSpeed` này thay vì tốc độ tối đa.",
                    "terms": {}
                },
                {
                    "id": 13,
                    "title": "Trang 13: Wander (1/2)",
                    "image": "images/game-dev/week8/slide_13.png",
                    "notes": "Hành vi <b>Wander (Lang thang)</b> là một loại lèo lái ngẫu nhiên.\n\nCách tiếp cận tốt hơn là giữ lại một 'lực lèo lái lang thang' và thay đổi nó một cách ngẫu nhiên sau mỗi khoảng thời gian.\n\n- Một vòng tròn tưởng tượng được đặt phía trước tác tử (agent).\n- Lực lèo lái là một vector trỏ đến một điểm trên vòng tròn đó.\n- Điểm này được di chuyển một chút và ngẫu nhiên sau mỗi N frame.\n- Bán kính của vòng tròn quyết định 'sức mạnh' lang thang tối đa.",
                    "terms": {
                        "Wander": "Một hành vi lèo lái tạo ra chuyển động ngẫu nhiên nhưng có vẻ tự nhiên. Thay vì chọn một hướng ngẫu nhiên ở mỗi frame, nó tạo ra một lực lèo lái thay đổi từ từ theo thời gian, tạo ra các đường đi cong và mượt mà."
                    }
                },
                {
                    "id": 14,
                    "title": "Trang 14: Wander (2/2)",
                    "image": "images/game-dev/week8/slide_14.png",
                    "notes": "Hàm `wander()` thực hiện logic lang thang:\n\n- Nó tích lũy thời gian (`acumTime`). Sau mỗi `wanderTime` giây, nó sẽ tạo ra một góc xoay ngẫu nhiên `r`.\n- Lực lèo lái lang thang (`wanderSeering`) được xoay đi một góc `r`.\n- Một 'thành phần lang thang' được tính toán bằng cách nhân `wanderSeering` với bán kính vòng tròn.\n- Vận tốc Mong muốn được tính bằng cách cộng thành phần lang thang vào vận tốc hiện tại, sau đó chuẩn hóa và nhân với tốc độ.",
                    "terms": {}
                },
                {
                    "id": 15,
                    "title": "Trang 15: Pursuit (1/2)",
                    "image": "images/game-dev/week8/slide_15.png",
                    "notes": "Hành vi <b>Pursuit (Truy đuổi)</b> tương đương với hành vi Seek, nhưng mục tiêu đang di chuyển.\n\nCách tiếp cận tốt hơn là <b>dự đoán</b> mục tiêu sẽ ở đâu trong tương lai và Seek đến vị trí dự đoán đó.\n\n- Một bộ dự đoán dựa trên vận tốc tuyến tính giả định rằng mục tiêu sẽ không rẽ.\n- Seek đến một vị trí được dự đoán trước `T` frame.\n- `T` nên giảm khi tác tử đến gần mục tiêu hơn.",
                    "terms": {
                        "Pursuit": "Một hành vi lèo lái thông minh hơn Seek, được sử dụng để đánh chặn một mục tiêu đang di chuyển. Nó hoạt động bằng cách dự đoán vị trí tương lai của mục tiêu và Seek đến điểm đó.",
                        "Evade": "Ngược lại của Pursuit. Nó dự đoán vị trí tương lai của một kẻ săn đuổi và Flee khỏi điểm đó."
                    }
                },
                {
                    "id": 16,
                    "title": "Trang 16: Pursuit (2/2)",
                    "image": "images/game-dev/week8/slide_16.png",
                    "notes": "Hàm `pursuit()` thực hiện logic truy đuổi:\n\n- Tính toán `T`, thời gian dự đoán, phụ thuộc vào khoảng cách đến mục tiêu.\n- Tính toán `advance`, là quãng đường mục tiêu sẽ di chuyển trong thời gian `T`.\n- `predictedTarget` là vị trí tương lai của mục tiêu (`target.position + advance`).\n- Phần còn lại của hàm tính toán Vận tốc Mong muốn và Lực lèo lái để Seek đến `predictedTarget` đó.",
                    "terms": {}
                },
                {
                    "id": 17,
                    "title": "Trang 17: Evade",
                    "image": "images/game-dev/week8/slide_17.png",
                    "notes": "Hành vi <b>Evade (Né tránh)</b> tương đương với hành vi Flee, nhưng mục tiêu cần trốn chạy đang di chuyển (hoặc có thể xem là Pursuit nhưng trốn chạy thay vì tìm kiếm).\n\nLogic của nó là dự đoán vị trí tương lai của mục tiêu và sau đó Flee khỏi vị trí dự đoán đó. Không cần phải giảm thời gian dự đoán `T` theo khoảng cách.",
                    "terms": {}
                },
                {
                    "id": 18,
                    "title": "Trang 18: Chuyển tiếp - Pathfinding",
                    "image": "images/game-dev/week8/slide_18.png",
                    "notes": "Kết thúc phần giới thiệu về các Hành vi Lèo lái (Steering Behaviours).\n\nPhần tiếp theo sẽ tập trung vào một kỹ thuật AI cơ bản khác: Tìm đường (Pathfinding).",
                    "terms": {}
                },
                {
                    "id": 19,
                    "title": "Trang 19: Giới thiệu Pathfinding",
                    "image": "images/game-dev/week8/slide_19.png",
                    "notes": "Một trong những lĩnh vực cơ bản nhất của Trí tuệ nhân tạo (AI) trong game là <b>tìm đường (path-finding)</b>, một khả năng trung tâm cho hầu hết các tương tác của NPC và game thủ.\n\nĐầu tiên, chúng ta cần xây dựng một đồ thị (graph) mà chúng ta có thể tìm kiếm:\n- <b>Nodes (Nút):</b> Biểu diễn các điểm trong không gian 2D hoặc 3D.\n- Các nút có các hàng xóm (các nút liền kề).\n- Các nút lân cận có thể có khoảng cách khác nhau.\n- Các nút có thể được xây dựng thủ công hoặc tự động.",
                    "terms": {
                        "Pathfinding": "Quá trình tìm kiếm đường đi ngắn nhất hoặc tốt nhất giữa hai điểm trong một không gian. Đây là một vấn đề phổ biến trong AI của game, giúp các NPC di chuyển một cách thông minh từ điểm A đến điểm B.",
                        "Graph (Đồ thị)": "Trong khoa học máy tính, đây là một cấu trúc dữ liệu bao gồm một tập hợp các đỉnh (vertices) hoặc nút (nodes) và một tập hợp các cạnh (edges) nối các cặp đỉnh này. Rất hữu ích để biểu diễn các mạng lưới, bản đồ."
                    }
                },
                {
                    "id": 20,
                    "title": "Trang 20: Pathfinding - Các loại lưới",
                    "image": "images/game-dev/week8/slide_20.png",
                    "notes": "Trong các lưới hình chữ nhật có kết nối 8 chiều, không phải tất cả các tâm ô đều cách đều nhau. Khoảng cách đi thẳng là 1, trong khi khoảng cách đi chéo là √2.\n\nChúng ta cũng có thể sử dụng các lưới lục giác (hexagonal grids), có thể dẫn đến chuyển động trông tự nhiên hơn. Tuy nhiên, chúng cũng tốn kém vì tất cả các khu vực 'không thú vị' đều được bao phủ như nhau.\n\nThay vào đó, chúng ta có thể sử dụng các lưới tùy ý (arbitrary grids):\n- Đặt các nút ở các vị trí cụ thể (ví dụ: trung tâm của một cánh cửa, hành lang).\n- Chỉ cần lưu trữ các điểm ưa thích (ít dữ liệu hơn).\n- Có thể kết hợp các chiến thuật (ví dụ: các điểm để ẩn nấp...).",
                    "terms": {}
                },
                {
                    "id": 21,
                    "title": "Trang 21: Pathfinding - Minh họa",
                    "image": "images/game-dev/week8/slide_21.png",
                    "notes": "Slide này minh họa các cách khác nhau để biểu diễn thế giới game dưới dạng một đồ thị cho việc tìm đường:\n\n- <b>Lưới ô vuông (Rectangular Grid):</b> Cách tiếp cận đơn giản nhất.\n- <b>Lưới lục giác (Hexagonal Grid):</b> Cho phép chuyển động tự nhiên hơn.\n- <b>Lưới đa giác (Polygon Grid):</b> Phân chia không gian thành các đa giác lồi, thường được dùng trong các thuật toán Navigation Mesh.\n- <b>Đồ thị điểm ưa thích (Points of Interest Graph):</b> Chỉ đặt các nút tại các vị trí quan trọng như cửa ra vào, ngã rẽ.",
                    "terms": {}
                },
                {
                    "id": 22,
                    "title": "Trang 22: Pathfinding - Thuật toán",
                    "image": "images/game-dev/week8/slide_22.png",
                    "notes": "Một khi đã có lưới, chúng ta cần tính toán cách đi từ A đến B bằng một thuật toán lập kế hoạch đường đi (path planning).\n\n- Cần điểm gốc (A) và mục tiêu (B).\n- Chúng ta thường quan tâm đến con đường hợp lệ ngắn nhất / nhanh nhất.\n\nNếu màn chơi là tĩnh (và mạng lưới tìm đường nhỏ), có thể sử dụng một <b>bảng tra cứu (lookup table)</b> các khoảng cách ngắn nhất đã được tính toán trước.\n\nBảng này có thể được tạo ra bằng <b>thuật toán Dijkstra</b>.",
                    "terms": {
                        "Dijkstra's Algorithm": "Một thuật toán tìm đường đi ngắn nhất từ một nút gốc đến tất cả các nút khác trong một đồ thị có trọng số cạnh không âm."
                    }
                },
                {
                    "id": 23,
                    "title": "Trang 23: Thuật toán Dijkstra",
                    "image": "images/game-dev/week8/slide_23.png",
                    "notes": "Thuật toán của Dijkstra là một thuật toán tìm đường cổ điển rất hiệu quả (thời gian chạy đa thức). Nó tìm đường đi ngắn nhất từ một nút đến mọi nút khác trong mạng lưới. Nó là một biến thể của tìm kiếm theo chiều rộng (breadth first search).\n\nThuật toán của Dijkstra sử dụng một <b>hàng đợi ưu tiên (priority queue)</b>: một danh sách chứa các mục với một mức độ ưu tiên liên quan. Danh sách luôn được sắp xếp sao cho các mục có độ ưu tiên cao nhất nằm ở trên cùng.\n\nThật không may, không có hàng đợi ưu tiên tích hợp sẵn trong C#.",
                    "terms": {
                        "Priority Queue": "Một cấu trúc dữ liệu trừu tượng tương tự như một hàng đợi thông thường, nhưng mỗi phần tử có thêm một 'ưu tiên'. Các phần tử có độ ưu tiên cao hơn sẽ được phục vụ trước các phần tử có độ ưu tiên thấp hơn."
                    }
                },
                {
                    "id": 24,
                    "title": "Trang 24: Thuật toán Dijkstra (Tiếp theo)",
                    "image": "images/game-dev/week8/slide_24.png",
                    "notes": "Cả Dijkstra (và A*) đều tìm kiếm trên một đồ thị `G = (N, E)`. Do đó, chúng ta cần biểu diễn thế giới của mình dưới dạng một đồ thị có trọng số, không định hướng. Với mục đích này, chúng ta tạo ra các lớp:\n\n- <b>E (Edge - Cạnh):</b> một cạnh từ một nút này đến một nút khác, với một chi phí (cost) cho trước.\n- <b>N (Node - Nút):</b> một nút với các thuộc tính cần thiết cho các thuật toán tìm đường.\n\nLớp `E` được định nghĩa với một tham chiếu đến nút đích (`node`) và một chi phí (`cost`) để đi qua cạnh đó.",
                    "terms": {
                        "Weighted Graph (Đồ thị có trọng số)": "Một đồ thị trong đó mỗi cạnh được gán một 'trọng số' hoặc 'chi phí'. Chiều dài của một đường đi trong đồ thị có trọng số là tổng các trọng số của các cạnh trên đường đi đó."
                    }
                },
                {
                    "id": 25,
                    "title": "Trang 25: Dijkstra - Lớp Node",
                    "image": "images/game-dev/week8/slide_25.png",
                    "notes": "Chúng ta định nghĩa lớp Node (`N`) với các thuộc tính cần thiết cho các thuật toán tìm đường:\n\n- <b>`parent` (N):</b> Nút cha trong đường đi tìm được.\n- <b>`g` (double):</b> Chi phí (cost) thực tế để đi từ nút bắt đầu đến nút này.\n- <b>`h` (double):</b> Chi phí ước tính (heuristic) từ nút này đến nút đích. (Chỉ dùng cho A*).\n- <b>`visited` (bool):</b> Đánh dấu nút đã được thăm hay chưa.\n- <b>`adj` (List<E>):</b> Danh sách các cạnh kề với nút này.",
                    "terms": {
                        "g cost": "Trong các thuật toán tìm đường như A*, đây là chi phí di chuyển thực tế đã biết từ nút bắt đầu đến nút hiện tại.",
                        "h cost (heuristic)": "Chi phí ước tính hoặc 'đoán' để đi từ nút hiện tại đến nút đích. Chất lượng của heuristic ảnh hưởng lớn đến hiệu suất của thuật toán A*."
                    }
                },
                {
                    "id": 26,
                    "title": "Trang 26: Dijkstra - Thuật toán",
                    "image": "images/game-dev/week8/slide_26.png",
                    "notes": "Đây là mã giả cho thuật toán Dijkstra:\n\n1. Khởi tạo một hàng đợi ưu tiên `pq` và thêm nút bắt đầu (`start`) vào.\n2. Lặp chừng nào `pq` còn chưa rỗng:\n   a. Lấy nút có chi phí `g` thấp nhất ra khỏi `pq`.\n   b. Nếu đó là nút đích, dừng lại.\n   c. Duyệt qua tất cả các hàng xóm (`next.node`) của nút hiện tại.\n   d. Nếu một hàng xóm chưa được thăm, tính toán chi phí mới, đặt cha cho nó và thêm nó vào `pq`.\n   e. Nếu hàng xóm đã được thăm nhưng chúng ta tìm thấy một con đường tốt hơn đến nó, cập nhật lại chi phí và cha của nó.\n3. Trích xuất đường đi từ nút đích ngược về nút bắt đầu.",
                    "terms": {}
                },
                {
                    "id": 27,
                    "title": "Trang 27: Dijkstra - Trích xuất đường đi",
                    "image": "images/game-dev/week8/slide_27.png",
                    "notes": "Đường đi có thể được trích xuất một cách dễ dàng bằng cách lần theo chuỗi các nút cha (`parent`) từ nút đích (`target`) ngược về nút bắt đầu (`start`).\n\nSau đó, chúng ta đảo ngược (reverse) tuyến đường để trả về đường đi từ đầu đến cuối.",
                    "terms": {}
                },
                {
                    "id": 28,
                    "title": "Trang 28: Dijkstra - Ví dụ (1/2)",
                    "image": "images/game-dev/week8/slide_28.png",
                    "notes": "Bài tập: sử dụng đồ thị được hiển thị bên dưới, hãy tính toán khoảng cách ngắn nhất từ G đến D bằng thuật toán của Dijkstra.",
                    "terms": {}
                },
                {
                    "id": 29,
                    "title": "Trang 29: Dijkstra - Ví dụ (2/2)",
                    "image": "images/game-dev/week8/slide_29.png",
                    "notes": "Slide này minh họa từng bước chạy của thuật toán Dijkstra trên đồ thị ví dụ.\n\n- `queue`: Chứa các nút chưa được xử lý, sắp xếp theo chi phí tăng dần.\n- `Xy15`: Ký hiệu cho biết đường đi nhanh nhất đến X (từ gốc) là thông qua Y, và chi phí liên quan là 15.\n\nThuật toán Dijkstra là hoàn chỉnh và luôn tìm thấy đường đi ngắn nhất. Nó cũng hiệu quả. Tuy nhiên, chúng ta có thể cải thiện Dijkstra như thế nào?",
                    "terms": {}
                },
                {
                    "id": 30,
                    "title": "Trang 30: Giới thiệu A*",
                    "image": "images/game-dev/week8/slide_30.png",
                    "notes": "Dijkstra sử dụng khoảng cách đã đi được cho đến nay và sử dụng một hàng đợi ưu tiên để xem xét các nút trong đồ thị có khoảng cách nhỏ nhất từ điểm bắt đầu.\n\nChúng ta mong đợi sẽ hoạt động tốt hơn nếu chúng ta cũng có thể đoán được một nút gần với mục tiêu đến mức nào.\n\n<b>A* (A-Star)</b> sử dụng một <b>heuristic</b> để ước tính sự hữu ích của một nút đối với mục tiêu. Điều này cho phép thuật toán khám phá đồ thị theo hướng của các khu vực hứa hẹn hơn.\n\n- Heuristic phải <b>admissible (chấp nhận được)</b>, tức là không bao giờ ước tính quá cao khoảng cách thực tế từ A đến B.\n- Heuristic càng gần với khoảng cách thực tế, A* hoạt động càng tốt.",
                    "terms": {
                        "A* (A-Star)": "Một thuật toán tìm đường kết hợp các tính năng của thuật toán Dijkstra (ưu tiên các con đường có chi phí thấp) với một heuristic. Nó tìm đường đi ngắn nhất bằng cách cân bằng giữa chi phí đã đi (`g`) và chi phí ước tính còn lại (`h`).",
                        "Heuristic": "Trong khoa học máy tính, đây là một kỹ thuật được thiết kế để giải quyết một vấn đề nhanh hơn khi các phương pháp cổ điển quá chậm, hoặc để tìm một giải pháp gần đúng khi các phương pháp cổ điển không thể tìm ra bất kỳ giải pháp nào. Về cơ bản, nó là một 'phỏng đoán có học'."
                    }
                },
                {
                    "id": 31,
                    "title": "Trang 31: Thuật toán A*",
                    "image": "images/game-dev/week8/slide_31.png",
                    "notes": "Đây là mã giả cho thuật toán A*. Nó rất giống với Dijkstra, nhưng có một vài khác biệt chính:\n\n- Nó sử dụng hai danh sách: `open` (tương tự như hàng đợi ưu tiên) và `closed` (chứa các nút đã được xử lý).\n- Khi một nút được thêm vào danh sách `open`, chi phí `h` (heuristic) của nó được tính toán.\n- Khi quyết định nút nào sẽ được xử lý tiếp theo, A* chọn nút trong danh sách `open` có tổng chi phí `g + h` thấp nhất.\n- Các nút đã được xử lý sẽ được chuyển từ `open` sang `closed`.",
                    "terms": {
                        "Open List": "Trong thuật toán A*, đây là danh sách các nút đã được phát hiện nhưng chưa được đánh giá. Thuật toán sẽ chọn nút có chi phí `f = g + h` thấp nhất từ danh sách này để xử lý tiếp theo.",
                        "Closed List": "Trong thuật toán A*, đây là danh sách các nút đã được đánh giá. Thuật toán sẽ không bao giờ xem xét lại các nút trong danh sách này."
                    }
                },
                {
                    "id": 32,
                    "title": "Trang 32: Thuật toán A* (Tiếp theo)",
                    "image": "images/game-dev/week8/slide_32.png",
                    "notes": "Mã giả tiếp tục:\n\n- Khi duyệt qua các hàng xóm của một nút, nếu một hàng xóm đã có trong danh sách `open` hoặc `closed`, chúng ta sẽ loại bỏ nó khỏi các danh sách đó trước khi thêm lại (nếu tìm thấy đường đi tốt hơn). Điều này là để cập nhật lại vị trí của nó trong hàng đợi ưu tiên.\n- Cuối cùng, hàm `ExtractPath` được gọi để truy ngược đường đi từ nút đích.",
                    "terms": {}
                },
                {
                    "id": 33,
                    "title": "Trang 33: Heuristics",
                    "image": "images/game-dev/week8/slide_33.png",
                    "notes": "Một số loại heuristic phổ biến:\n\n- <b>Manhattan Distance:</b> Khoảng cách được tính bằng cách chỉ di chuyển theo các hướng ngang và dọc (giống như đi trên các đường phố của Manhattan). Công thức: `|x1 - x2| + |y1 - y2|`.\n- <b>Euclidean Distance:</b> Khoảng cách đường chim bay, là khoảng cách thực tế giữa hai điểm. Công thức: `sqrt((x1 - x2)² + (y1 - y2)²)`. \n- <b>Chebyshev Distance:</b> Khoảng cách được tính trên một lưới cho phép di chuyển 8 hướng (ngang, dọc, chéo) với cùng một chi phí. Công thức: `max(|x1 - x2|, |y1 - y2|)`.\n\nNếu chúng ta đặt heuristic `h = 0`, thuật toán A* sẽ hoạt động giống hệt như Dijkstra.",
                    "terms": {
                        "Manhattan Distance": "Một cách đo khoảng cách giữa hai điểm trong một lưới. Nó là tổng của các chênh lệch tuyệt đối của các tọa độ của chúng. Rất hữu ích làm heuristic cho các game chỉ cho phép di chuyển 4 hướng.",
                        "Euclidean Distance": "Khoảng cách đường thẳng thông thường giữa hai điểm trong không gian. Đây là heuristic phổ biến và chính xác nhất cho các game cho phép di chuyển tự do.",
                        "Chebyshev Distance": "Khoảng cách giữa hai điểm trong một lưới cho phép di chuyển 8 hướng với chi phí bằng nhau. Nó được định nghĩa là số bước di chuyển tối thiểu cần thiết để đi từ điểm này đến điểm kia."
                    }
                },
                {
                    "id": 34,
                    "title": "Trang 34: Heuristics (Tiếp theo)",
                    "image": "images/game-dev/week8/slide_34.png",
                    "notes": "Các heuristic chấp nhận được (Admissible heuristics):\n\n- Lưới hình chữ nhật, kết nối 4 chiều: Euclidean, Manhattan hoặc Chebyshev.\n- Lưới hình chữ nhật, kết nối 8 chiều: Euclidean hoặc Chebyshev (Đường chéo).\n\nTrong một số trường hợp, chúng ta có thể sử dụng một heuristic chính xác đã được tính toán trước.",
                    "terms": {}
                },
                {
                    "id": 35,
                    "title": "Trang 35: A* - Hàm Heuristic",
                    "image": "images/game-dev/week8/slide_35.png",
                    "notes": "Các hàm heuristic của chúng ta được định nghĩa như sau:\n\n- <b>GetHValue:</b> Một hàm `switch` để chọn loại heuristic sẽ được sử dụng (đường thẳng hoặc Manhattan).\n- <b>EuclideanDistance:</b> Triển khai công thức khoảng cách Euclid.\n- <b>ManhattanDistance:</b> Triển khai công thức khoảng cách Manhattan.",
                    "terms": {}
                },
                {
                    "id": 36,
                    "title": "Trang 36: Một số sự thật về A*",
                    "image": "images/game-dev/week8/slide_36.png",
                    "notes": "Một số sự thật quan trọng về thuật toán A*:\n\n- Nếu `h(n) = 0`, A* trở thành thuật toán Dijkstra.\n- Nếu `h(n)` không bao giờ lớn hơn khoảng cách thực tế (admissible), A* được đảm bảo sẽ tìm thấy đường đi ngắn nhất.\n- Nếu `h(n)` chính xác bằng khoảng cách thực tế, A* sẽ chỉ đi theo con đường tốt nhất và không bao giờ mở rộng các nút không cần thiết.\n- Nếu `h(n)` đôi khi lớn hơn chi phí thực tế, A* không được đảm bảo sẽ tìm thấy đường đi ngắn nhất.\n- Nếu `h(n)` rất cao so với `g(n)`, A* sẽ biến thành thuật toán Best-First-Search.",
                    "terms": {}
                },
                {
                    "id": 37,
                    "title": "Trang 37: Đi theo đường (Path Following)",
                    "image": "images/game-dev/week8/slide_37.png",
                    "notes": "Một khi đã tìm thấy một đường đi tối ưu từ A đến B, tác tử (agent) phải đi theo nó. Có một số phức tạp:\n- Các tác tử khác hoặc các đối tượng di chuyển có thể chiếm các nút trong đồ thị.\n- Màn chơi có thể hoàn toàn động.\n- Sương mù chiến tranh (Fog of War).\n\nCác giải pháp:\n- Tính toán lại (một phần) của đường đi.\n- Sử dụng các nút lớn có thể bị chiếm bởi nhiều tác tử.\n- Chuyển hướng đến nút có sẵn gần nhất.",
                    "terms": {
                        "Path Following": "Sau khi có được một chuỗi các điểm từ thuật toán tìm đường, đây là hành vi lèo lái giúp nhân vật di chuyển mượt mà qua các điểm đó để đến đích."
                    }
                },
                {
                    "id": 38,
                    "title": "Trang 38: Chuyển tiếp - Navigation Meshes trong Unity",
                    "image": "images/game-dev/week8/slide_38.png",
                    "notes": "Kết thúc phần giới thiệu về các thuật toán tìm đường lý thuyết.\n\nPhần tiếp theo sẽ tập trung vào giải pháp tìm đường tích hợp sẵn và mạnh mẽ của Unity: Navigation Meshes.",
                    "terms": {}
                },
                {
                    "id": 39,
                    "title": "Trang 39: Giới thiệu Navigation Meshes",
                    "image": "images/game-dev/week8/slide_39.png",
                    "notes": "Một <b>Navigation Mesh (hay NavMesh)</b> là một cấu trúc dữ liệu được sử dụng để mô hình hóa các khu vực có thể đi lại của một bản đồ ảo.\n\n- Đó là một tập hợp các đa giác lồi hai chiều (thường là tam giác) xác định khu vực nào của bản đồ ảo có thể được các tác tử đi qua.\n- Mỗi đa giác hoạt động như một nút duy nhất liên kết với các nút liền kề khác.\n- Các đa giác là lồi (convex): bất kỳ điểm nào từ bên trong đa giác có thể được tiếp cận bằng một đường thẳng từ bất kỳ điểm nào khác bên trong cùng một đa giác.",
                    "terms": {
                        "Navigation Mesh (NavMesh)": "Một cấu trúc dữ liệu biểu diễn các khu vực có thể đi lại trong một môi trường game. Thay vì một lưới ô vuông, nó sử dụng các đa giác có hình dạng và kích thước khác nhau để mô tả bề mặt, cho phép các nhân vật di chuyển một cách tự nhiên và thông minh hơn."
                    }
                },
                {
                    "id": 40,
                    "title": "Trang 40: NavMesh vs. Tìm đường dựa trên Grid/Waypoint",
                    "image": "images/game-dev/week8/slide_40.png",
                    "notes": "Bốn lợi thế khác của NavMesh so với các hệ thống tìm đường dựa trên waypoint (điểm tham chiếu):\n\n1. Các đồ thị dựa trên waypoint có xu hướng yêu cầu nhiều nút hơn, đặc biệt là trong các khu vực rộng lớn.\n\nHình ảnh minh họa sự khác biệt: đồ thị waypoint (màu đỏ) cần rất nhiều nút được đặt thủ công, trong khi NavMesh (màu xanh) tự động tạo ra một đồ thị đơn giản hơn, chỉ với các nút ở các 'cạnh' của các đa giác.",
                    "terms": {
                        "Waypoint Graph": "Một phương pháp tìm đường trong đó các nhà thiết kế đặt thủ công các nút (waypoint) tại các vị trí quan trọng trong màn chơi. Các nhân vật AI sau đó sẽ tìm đường đi giữa các waypoint này. Phương pháp này đơn giản nhưng kém linh hoạt và tốn nhiều công sức hơn NavMesh."
                    }
                },
                {
                    "id": 41,
                    "title": "Trang 41: NavMesh vs. Grid/Waypoint (2/4)",
                    "image": "images/game-dev/week8/slide_41.png",
                    "notes": "Lợi thế thứ hai của NavMesh:\n\n2. <b>Tránh chuyển động zigzag không tự nhiên:</b> Với hệ thống waypoint, đường đi được xác định là một chuỗi các đoạn thẳng nối các điểm, buộc nhân vật phải điều chỉnh và đi theo một cách máy móc. Ngược lại, NavMesh tạo ra một con đường thẳng hơn, tự nhiên hơn xuyên qua các đa giác.",
                    "terms": {}
                },
                {
                    "id": 42,
                    "title": "Trang 42: NavMesh vs. Grid/Waypoint (3/4)",
                    "image": "images/game-dev/week8/slide_42.png",
                    "notes": "Lợi thế thứ ba của NavMesh:\n\n3. <b>Tránh chướng ngại vật động một cách mạnh mẽ:</b> Hệ thống NavMesh có các thuật toán tích hợp sẵn để giúp các tác tử (agents) tự động tìm đường đi vòng qua các chướng ngại vật động (dynamic obstacles) mà không cần tính toán lại toàn bộ đường đi.",
                    "terms": {}
                },
                {
                    "id": 43,
                    "title": "Trang 43: NavMesh vs. Grid/Waypoint (4/4)",
                    "image": "images/game-dev/week8/slide_43.png",
                    "notes": "Lợi thế thứ tư của NavMesh:\n\n4. <b>Các đường đi mượt mà cho các kích thước nhân vật khác nhau:</b> Hệ thống NavMesh có thể tính toán các đường đi tối ưu cho các tác tử có bán kính khác nhau, đảm bảo chúng di chuyển một cách mượt mà và không bị va chạm vào các góc tường.",
                    "terms": {}
                },
                {
                    "id": 44,
                    "title": "Trang 44: NavMesh trong Unity - Các đối tượng",
                    "image": "images/game-dev/week8/slide_44.png",
                    "notes": "Trong Unity, việc tạo NavMesh được xử lý từ cửa sổ Navigation (<b>Window → AI → Navigation</b>). Quá trình tạo ra một NavMesh được gọi là <b>baking</b>.\n\nĐể 'nung' một NavMesh, cần phải cho Unity biết đối tượng nào là <b>navigation static</b>. Những đối tượng này sẽ không di chuyển và có thể được dùng để tính toán các khu vực có thể đi lại. Ví dụ về các đối tượng này là sàn nhà, tường, và các chướng ngại vật tĩnh.",
                    "terms": {
                        "Navigation Static": "Một tùy chọn đánh dấu một Game Object là tĩnh đối với hệ thống Navigation. Unity sẽ sử dụng các đối tượng được đánh dấu này để 'nung' (bake) NavMesh.",
                        "Baking (NavMesh)": "Quá trình Unity phân tích các đối tượng 'Navigation Static' trong scene của bạn và tự động tạo ra một lưới đa giác (NavMesh) biểu diễn các khu vực có thể đi lại."
                    }
                },
                {
                    "id": 45,
                    "title": "Trang 45: NavMesh trong Unity - Baking",
                    "image": "images/game-dev/week8/slide_45.png",
                    "notes": "Việc 'nung' NavMesh được thực hiện trong tab <b>Bake</b>, với các đối tượng được chọn. Các thông số quan trọng:\n\n- <b>Agent Radius:</b> Bán kính của tác tử. Xác định con đường hẹp nhất mà một nhân vật có thể đi qua.\n- <b>Agent Height:</b> Chiều cao của tác tử.\n- <b>Max Slope:</b> Ngưỡng độ dốc mà tại đó một con dốc trở thành một bức tường không thể đi được.\n- <b>Step Height:</b> Chiều cao bậc thang tối đa mà nhân vật có thể bước qua.",
                    "terms": {}
                },
                {
                    "id": 46,
                    "title": "Trang 46: NavMesh trong Unity - Areas",
                    "image": "images/game-dev/week8/slide_46.png",
                    "notes": "Các bề mặt khác nhau có thể có các chi phí di chuyển khác nhau. Ví dụ, đi qua bùn có thể tốn nhiều 'chi phí' hơn đi trên cỏ. Mỗi phần của NavMesh có thể được thiết lập với một giá trị chi phí thông qua việc sử dụng <b>NavMesh Areas</b>.\n\nBạn có thể định nghĩa các 'Area' (Khu vực) khác nhau như 'Walkable' (Có thể đi), 'Not Walkable' (Không thể đi), 'Water' (Nước) và gán một chi phí (Cost) cho mỗi loại. Các tác tử (agents) sẽ ưu tiên các con đường có tổng chi phí thấp hơn.",
                    "terms": {
                        "NavMesh Area": "Một loại 'nhãn' có thể được gán cho các phần của NavMesh để chỉ định các thuộc tính đặc biệt, chẳng hạn như chi phí di chuyển. Điều này cho phép AI đưa ra các quyết định thông minh hơn, ví dụ như tránh đi qua bùn lầy trừ khi đó là con đường duy nhất."
                    }
                },
                {
                    "id": 47,
                    "title": "Trang 47: NavMesh Agent (1/4) - Giới thiệu",
                    "image": "images/game-dev/week8/slide_47.png",
                    "notes": "Một <b>NavMesh agent</b> là một component giúp một nhân vật có thể tìm đường và di chuyển trong thế giới game. Nó được biểu diễn vật lý bằng một hình trụ với Bán kính (Radius) và Chiều cao (Height).\n\nAgent có khả năng truy vấn các đường đi trên NavMesh. Thay vì đi theo các đoạn thẳng nối các điểm một cách máy móc, agent sẽ di chuyển một cách thực tế hơn, có gia tốc và quay dần dần.\n\nKhi di chuyển, agent sẽ tự động tránh các chướng ngại vật cố định và cả các agent khác.",
                    "terms": {
                        "NavMesh Agent": "Một component cho phép một Game Object tìm đường một cách thông minh trên NavMesh. Nó xử lý cả việc tìm đường đi phức tạp và việc di chuyển cục bộ (local movement) như tránh chướng ngại vật."
                    }
                },
                {
                    "id": 48,
                    "title": "Trang 48: NavMesh Agent (2/4) - Component",
                    "image": "images/game-dev/week8/slide_48.png",
                    "notes": "Component <b>NavMesh Agent</b> có thể được thêm vào một nhân vật để cho phép nó điều hướng tự động trên NavMesh. Component này xử lý cả việc tìm đường và điều khiển chuyển động của nhân vật.",
                    "terms": {}
                },
                {
                    "id": 49,
                    "title": "Trang 49: NavMesh Agent (3/4) - Các tham số",
                    "image": "images/game-dev/week8/slide_49.png",
                    "notes": "Các tham số chính của NavMesh Agent:\n\n- <b>Speed / Angular Speed / Acceleration:</b> Tốc độ di chuyển / xoay / gia tốc tối đa của agent.\n- <b>Stopping Distance:</b> Khoảng cách đến mục tiêu mà tại đó agent sẽ dừng lại.\n- <b>Auto Braking:</b> Agent có nên giảm tốc khi đến gần mục tiêu không.\n- <b>Obstacle Avoidance Quality:</b> Chất lượng của việc tránh chướng ngại vật.\n- <b>Auto Repath:</b> Tự động tính toán lại một đường đi mới nếu đường đi hiện tại không còn hợp lệ.\n- <b>Area Mask:</b> Các loại NavMesh Area mà agent này có thể đi qua.",
                    "terms": {}
                },
                {
                    "id": 50,
                    "title": "Trang 50: NavMesh Agent (4/4) - Scripting",
                    "image": "images/game-dev/week8/slide_50.png",
                    "notes": "NavMesh agent có thể được điều khiển trực tiếp từ script. Việc lấy component rất đơn giản: `GetComponent<NavMeshAgent>()`.\n\nĐể ra lệnh cho agent di chuyển, bạn chỉ cần gọi hàm <b>SetDestination</b> với một vị trí `Vector3`:\n`agent.SetDestination(target.position);`\n\nCác hàm hữu ích khác bao gồm `Stop()`, `Resume()`, và `CalculatePath()` để tính toán một đường đi mà không cần di chuyển.",
                    "terms": {
                        "agent.SetDestination()": "Phương thức chính để ra lệnh cho một NavMesh Agent di chuyển đến một điểm đến cụ thể. Tác tử sẽ tự động tính toán đường đi ngắn nhất trên NavMesh và bắt đầu di chuyển."
                    }
                },
                {
                    "id": 51,
                    "title": "Trang 51: NavMesh Obstacle",
                    "image": "images/game-dev/week8/slide_51.png",
                    "notes": "Một <b>NavMesh Obstacle</b> là một chướng ngại vật <b>có thể di chuyển</b> mà một NavMesh agent phải tránh (ví dụ: cửa ra vào, tường di động...). Để đánh dấu một game object là một chướng ngại vật NavMesh, bạn cần thêm component <b>Nav Mesh Obstacle</b> vào đối tượng đó.\n\nComponent này cho phép các agent tự động tính toán lại đường đi để đi vòng qua chướng ngại vật khi nó xuất hiện trên đường đi của chúng.",
                    "terms": {
                        "NavMesh Obstacle": "Một component được sử dụng để mô tả các chướng ngại vật động hoặc có thể di chuyển mà các NavMesh Agent cần phải tránh. Không giống như các đối tượng tĩnh được 'nung' vào NavMesh, các Obstacle có thể thay đổi vị trí tại thời điểm chạy."
                    }
                },
                {
                    "id": 52,
                    "title": "Trang 52: Chuyển tiếp - Câu hỏi & Demo Lab",
                    "image": "images/game-dev/week8/slide_52.png",
                    "notes": "Kết thúc phần lý thuyết về Navigation Meshes trong Unity.\n\nPhần cuối cùng sẽ là các câu hỏi kiểm tra và xem trước nội dung buổi thực hành (Lab).",
                    "terms": {}
                },
                {
                    "id": 53,
                    "title": "Trang 53: Xem trước buổi thực hành",
                    "image": "images/game-dev/week8/slide_53.png",
                    "notes": "Chúng ta sẽ thực hiện thêm các phần demo của Bài tập lớn Phần I.\n\nBài giảng tiếp theo: <b>Game AI: Decision Making.</b>",
                    "terms": {}
                }
            ]
        }
    ]
}